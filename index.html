<!doctype html>
<html lang="fa" dir="rtl">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
    <meta name="theme-color" content="#0b0f14" />
    <title>Ø§Ù¾Ù„ÛŒÚ©ÛŒØ´Ù† Ø¨Ø§Ø²ÛŒ Ù…Ø§ÙÛŒØ§</title>
    <link rel="stylesheet" href="style.css">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Vazirmatn:wght@400;500;700;900&display=swap" rel="stylesheet">
  </head>
  <body>
    <div class="app">
      <div class="topbar">
        <div class="title" id="appTitle">Ø§Ù¾Ù„ÛŒÚ©ÛŒØ´Ù† Ø¨Ø§Ø²ÛŒ Ù…Ø§ÙÛŒØ§</div>
        <div class="topActions">
          <div class="chip clickable" id="langChip" role="button" tabindex="0" aria-label="ØªØºÛŒÛŒØ± Ø²Ø¨Ø§Ù†">
            <span class="label" id="langLabel">English</span>
            <button id="langBtn" type="button" aria-hidden="true">ğŸŒ</button>
          </div>
          <div class="chip clickable" id="helpChip" role="button" tabindex="0" aria-label="Ø±Ø§Ù‡Ù†Ù…Ø§" data-i18n-aria-label="top.help">
            <span class="label" data-i18n="top.help">Ø±Ø§Ù‡Ù†Ù…Ø§</span>
          </div>
        </div>
      </div>

      <div class="card" id="setupCard">
        <div class="bd">
          <button class="bigbtn redbar" id="backBarBtn" type="button" style="display:none" data-i18n="setup.backToSetup">Ø¨Ø§Ø²Ú¯Ø´Øª Ø¨Ù‡ ØªÙ†Ø¸ÛŒÙ…Ø§Øª Ø¨Ø§Ø²ÛŒ</button>

          <div class="row">
            <label>
              <span data-i18n="setup.scenario">Ø³Ù†Ø§Ø±ÛŒÙˆ</span>
              <select id="scenario">
                <option value="bazras">Ø¨Ø§Ø²Ù¾Ø±Ø³</option>
                <option value="namayande">Ù†Ù…Ø§ÛŒÙ†Ø¯Ù‡</option>
                <option value="mozaker">Ù…Ø°Ø§Ú©Ø±Ù‡</option>
                <option value="classic">Ú©Ù„Ø§Ø³ÛŒÚ©</option>
                <option value="takavar">ØªÚ©Ø§ÙˆØ±</option>
                <option value="kabo">Ú©Ø§Ù¾Ùˆ</option>
                <option value="pedarkhande">Ù¾Ø¯Ø±Ø®ÙˆØ§Ù†Ø¯Ù‡</option>
                <option value="zodiac">Ø²ÙˆØ¯ÛŒØ§Ú©</option>
                <option value="meeting_epic">Ù…ÛŒØªÛŒÙ†Ú¯/Ø§Ù¾ÛŒÚ©</option>
                <option value="pishrafte">Ù¾ÛŒØ´Ø±ÙØªÙ‡</option>
                <option value="shab_mafia">Ø´Ø¨ Ù…Ø§ÙÛŒØ§</option>
              </select>
            </label>
            <label>
              <span data-i18n="setup.playersCount">ØªØ¹Ø¯Ø§Ø¯ Ø¨Ø§Ø²ÛŒÚ©Ù†â€ŒÙ‡Ø§</span>
              <select id="playersCount"></select>
            </label>
          </div>

          <div class="row one">
            <label>
              <span data-i18n="setup.mafiaCount">ØªØ¹Ø¯Ø§Ø¯ Ù…Ø§ÙÛŒØ§</span>
              <select id="mafiaCount"></select>
            </label>
          </div>

          <div class="row one">
            <div class="error" id="errorBox"></div>
          </div>

          <div class="toggles" id="toggles">
            <!-- injected -->
          </div>

          <div class="row one" style="margin-top:12px">
            <div class="actions">
              <button class="btn" id="scenarioDefaultsBtn" type="button" data-i18n="setup.defaults">Ù¾ÛŒØ´â€ŒÙØ±Ø¶ Ø³Ù†Ø§Ø±ÛŒÙˆ</button>
              <button class="btn primary" id="startGameBtn" type="button" data-i18n="setup.start">Ø´Ø±ÙˆØ¹ Ø¨Ø§Ø²ÛŒ</button>
            </div>
            <button class="btn" id="resumeBtn" type="button" style="display:none">Ø§Ø¯Ø§Ù…Ù‡ Ø¨Ø§Ø²ÛŒ</button>
          </div>

          <div class="row one" id="savedGameBarRow" style="display:none; margin-top:12px">
            <div class="defaultsBar savedGame">
              <div class="txt" id="savedGameBarText" data-i18n="setup.savedGame">ÛŒÚ© Ø¨Ø§Ø²ÛŒ Ø°Ø®ÛŒØ±Ù‡ Ø´Ø¯Ù‡ Ø§Ø³Øª.</div>
              <div class="actions" id="savedGameBarActions">
                <button class="btn" id="savedGameResumeBtn" type="button" data-i18n="setup.resume">Ø§Ø¯Ø§Ù…Ù‡ Ø¨Ø§Ø²ÛŒ</button>
                <button class="btn danger" id="savedGameClearBtn" type="button" data-i18n="setup.delete">Ø­Ø°Ù</button>
              </div>
            </div>
          </div>
        </div>
      </div>

      <div class="card hidden" id="playersCard">
        <div class="hd">
          <h2 data-i18n="players.title">Ø¨Ø§Ø²ÛŒÚ©Ù†Ø§Ù†</h2>
          <span class="chip" id="playersStat">â€”</span>
        </div>
        <div class="bd">
          <div class="row one">
            <div class="pill" role="tablist" aria-label="Ø­Ø§Ù„Øª Ù†Ø§Ù…â€ŒÙ‡Ø§" data-i18n-aria-label="players.namesModeAria">
              <button id="namesDefaultBtn" type="button" class="active" data-i18n="players.namesDefault">Ø§Ø³Ø§Ù…ÛŒ Ù¾ÛŒØ´â€ŒÙØ±Ø¶</button>
              <button id="namesLastBtn" type="button" data-i18n="players.namesLast">Ø§Ø³Ø§Ù…ÛŒ Ø¨Ø§Ø²ÛŒ Ù‚Ø¨Ù„</button>
            </div>
            <div class="note" data-i18n="players.note">Ø§Ø³Ø§Ù…ÛŒ Ø¨Ø§Ø²ÛŒÚ©Ù†Ø§Ù† Ø±Ø§ ÙˆØ§Ø±Ø¯ Ú©Ù†ÛŒØ¯. Ø§Ú¯Ø± Â«Ø§Ø³Ø§Ù…ÛŒ Ø¨Ø§Ø²ÛŒ Ù‚Ø¨Ù„Â» Ø±Ø§ Ø§Ù†ØªØ®Ø§Ø¨ Ú©Ù†ÛŒØ¯ØŒ Ø§Ø² Ø°Ø®ÛŒØ±Ù‡â€ŒÛŒ Ù…Ø±ÙˆØ±Ú¯Ø± Ø§Ø³ØªÙØ§Ø¯Ù‡ Ù…ÛŒâ€ŒØ´ÙˆØ¯.</div>
            <div class="nameGrid" id="nameGrid"></div>
            <div class="error" id="errorBoxPlayers"></div>
          </div>

          <div class="row one" style="margin-top:12px">
            <button class="bigbtn primary" id="dealBtn" type="button" data-i18n="players.deal">ØªÙ‚Ø³ÛŒÙ… Ù†Ù‚Ø´</button>
            <div class="actions">
              <button class="btn" id="playersBackBtn" type="button" data-i18n="players.back">Ø¨Ø§Ø²Ú¯Ø´Øª Ø¨Ù‡ ØªÙ†Ø¸ÛŒÙ…Ø§Øª</button>
            </div>
          </div>
        </div>
      </div>

      <div class="card hidden" id="cardsCard">
        <div class="hd">
          <h2 data-i18n="cards.title">ØªÙ‚Ø³ÛŒÙ… Ù†Ù‚Ø´</h2>
          <span class="chip" id="cardsStat">â€”</span>
        </div>
        <div class="bd">
          <div class="cardsCenter">
            <div class="banner">
              <div id="cardsWho">Ù†ÙˆØ¨Øª: â€”</div>
            </div>

            <div class="note" id="cardsHint" data-i18n="cards.hint">Ø¨Ø§Ø²ÛŒÚ©Ù† ÛŒÚ© Ú©Ø§Ø±Øª Ø±Ø§ Ø§Ù†ØªØ®Ø§Ø¨ Ù…ÛŒâ€ŒÚ©Ù†Ø¯ Ùˆ Ù†Ù‚Ø´ Ø®ÙˆØ¯Ø´ Ø±Ø§ Ù…ÛŒâ€ŒØ¨ÛŒÙ†Ø¯.</div>

            <div class="cardsGrid" id="cardsGrid"></div>
          </div>

          <div class="actions wrap">
            <button class="btn" id="cardsBackBtn" type="button" data-i18n="cards.back">Ø¨Ø§Ø²Ú¯Ø´Øª</button>
            <button class="btn" id="autoAssignBtn" type="button" data-i18n="cards.autoAssign">Ø§Ø®ØªØµØ§Øµ Ø§ØªÙˆÙ…Ø§Øª Ù†Ù‚Ø´â€ŒÙ‡Ø§</button>
            <button class="btn primary" id="cardsNextBtn" type="button" disabled data-i18n="cards.next">Ø¨Ø±Ùˆ Ù…Ø±Ø­Ù„Ù‡ Ø¨Ø¹Ø¯!</button>
          </div>
        </div>
      </div>

      <div class="card hidden" id="castCard">
        <div class="bd">
          <div style="display:flex; justify-content:flex-end; margin-bottom:8px">
            <button class="btn secondary" id="castPrivacyBtn" type="button" style="padding:6px 10px; min-width:0; gap:5px">
              <svg id="castPrivacyIcon" width="16" height="16" viewBox="0 0 24 24" fill="currentColor" aria-hidden="true"><path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/></svg>
              <span id="castPrivacyLabel" data-i18n="cast.hide">Ù¾Ù†Ù‡Ø§Ù†â€ŒÚ©Ø±Ø¯Ù† Ù†Ù‚Ø´â€ŒÙ‡Ø§</span>
            </button>
          </div>
          <div class="castBox mafia" id="castMafia"></div>
          <div style="height:12px"></div>
          <div class="castBox city" id="castCity"></div>
          <div style="height:12px"></div>
          <div class="castBox" id="castInd" style="display:none"></div>

          <div class="actions">
            <button class="btn primary" id="castFlowBtn" type="button"><svg width="15" height="15" viewBox="0 0 24 24" fill="currentColor" style="vertical-align:-2px;margin-inline-end:4px" aria-hidden="true"><path d="M5.5 5.5 Q5.5 3 7.5 4.3 L18 10.7 Q20 12 18 13.3 L7.5 19.7 Q5.5 21 5.5 18.5Z"/></svg><span data-i18n="tools.flow">Ø¬Ø±ÛŒØ§Ù†</span></button>
            <button class="btn secondary" id="toolStatus" type="button"><svg width="15" height="15" viewBox="0 0 24 24" fill="currentColor" style="vertical-align:-2px;margin-inline-end:4px" aria-hidden="true"><path d="M15.5 14h-.79l-.28-.27A6.471 6.471 0 0 0 16 9.5 6.5 6.5 0 1 0 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19l-4.99-5zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z"/></svg><span data-i18n="tools.status">Ø§Ø³ØªØ¹Ù„Ø§Ù…</span></button>
            <button class="btn secondary" id="toolTimer" type="button"><svg width="15" height="15" viewBox="0 0 24 24" fill="currentColor" style="vertical-align:-2px;margin-inline-end:4px" aria-hidden="true"><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8zm.5-13H11v6l5.25 3.15.75-1.23-4.5-2.67V7z"/></svg><span data-i18n="tools.timer">ØªØ§ÛŒÙ…</span></button>
          </div>
          <div class="actions" style="margin-top:8px">
            <button class="btn" id="castBackBtn" type="button"><svg width="15" height="15" viewBox="0 0 24 24" fill="currentColor" style="vertical-align:-2px;margin-inline-end:4px" aria-hidden="true"><path d="M20 11H7.83l5.59-5.59L12 4l-8 8 8 8 1.41-1.41L7.83 13H20v-2z"/></svg><span data-i18n="cast.back">Ø¨Ø§Ø²Ú¯Ø´Øª</span></button>
            <button class="btn" id="toolRoleChange" type="button"><svg width="15" height="15" viewBox="0 0 24 24" fill="currentColor" style="vertical-align:-2px;margin-inline-end:4px" aria-hidden="true"><path d="M6.99 11L3 15l3.99 4v-3H14v-2H6.99v-3zM21 9l-3.99-4v3H10v2h7.01v3L21 9z"/></svg><span data-i18n="tools.roleChange">ØªØºÛŒÛŒØ± Ù†Ù‚Ø´</span></button>
            <button class="btn secondary" id="toolDraw" type="button"><svg width="15" height="15" viewBox="0 0 24 24" fill="currentColor" style="vertical-align:-2px;margin-inline-end:4px" aria-hidden="true"><path d="M5 3h14a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2zm2 4a1 1 0 1 0 2 0 1 1 0 0 0-2 0zm10 0a1 1 0 1 0 2 0 1 1 0 0 0-2 0zM8 11a1 1 0 1 0 0 2 1 1 0 0 0 0-2zm8 0a1 1 0 1 0 0 2 1 1 0 0 0 0-2zM8 16a1 1 0 1 0 0 2 1 1 0 0 0 0-2zm8 0a1 1 0 1 0 0 2 1 1 0 0 0 0-2z"/></svg><span data-i18n="tools.chance">Ù‚Ø±Ø¹Ù‡</span></button>
          </div>
        </div>
      </div>

    </div>

    <div class="modal" id="modal" role="dialog" aria-modal="true" aria-hidden="true">
      <div class="sheet">
        <div class="top">
          <div class="who" id="modalWho">â€”</div>
          <button class="close" id="modalCloseBtn" type="button" data-i18n="common.close">Ø¨Ø³ØªÙ†</button>
        </div>
        <div class="content">
          <div class="roleCard roleReveal" id="roleCard">
            <button class="roleHelpBtn" id="roleHelpBtn" type="button" title="Ø±Ø§Ù‡Ù†Ù…Ø§ÛŒ Ù†Ù‚Ø´" data-i18n-title="common.roleHelp">ØŸ</button>
            <div class="ricon" id="roleIcon" aria-hidden="true"></div>
            <div class="rname" id="roleName">â€”</div>
            <div class="rteam" id="roleTeam">â€”</div>
            <div class="rdesc collapsed" id="roleDesc">â€”</div>
          </div>
          <div class="note roleRevealNote" id="modalNote"></div>
        </div>
        <div class="bottom">
          <button class="btn primary" id="markRevealedBtn" type="button" data-i18n="common.seen">Ø¯ÛŒØ¯Ù…</button>
        </div>
      </div>
    </div>

    <div class="modal" id="toolModal" role="dialog" aria-modal="true" aria-hidden="true">
      <div class="sheet">
        <div class="top">
          <div class="who" id="toolTitle">â€”</div>
          <button class="close" id="toolCloseBtn" type="button" data-i18n="common.close">Ø¨Ø³ØªÙ†</button>
        </div>
        <div class="content" id="toolBody">
          <!-- injected -->
        </div>
        <div class="bottom" id="toolBottom">
          <button class="btn primary" id="toolOkBtn" type="button" data-i18n="common.close">Ø¨Ø³ØªÙ†</button>
        </div>
      </div>
    </div>

    <script src="strings.js"></script>
    <script src="roles.js"></script>
    <script src="scenarios.js"></script>
    <script src="flow-configs/classic.js"></script>
    <script src="flow-configs/pedarkhande.js"></script>
    <script src="flow-configs/zodiac.js"></script>
    <script src="flow-configs/kabo.js"></script>
    <script src="flow-configs/bazras.js"></script>
    <script src="flow-configs/namayande.js"></script>
    <script src="flow-configs/standard.js"></script>
    <script src="flow-configs.js"></script>
    <script src="guides.js"></script>
    <script src="i18n.js"></script>
    <script src="flow-engine.js"></script>
    <script src="effect-registry.js"></script>
    <script src="flow-ui.js"></script>
    <script src="flow-configs/pedarkhande-renderers.js"></script>
    <script>
        const $ = (id) => document.getElementById(id);

        const STORAGE_KEY = "mafia_v2_simple_web_state_v1";
        const LAST_NAMES_KEY = "mafia_v2_simple_web_last_names_v1";

        const LANG_KEY = "mafia_v2_simple_web_lang_v1";
        let appLang = "fa"; // "fa" | "en"




        function teamKeyFromFa(teamFa) {
          if (teamFa === "Ù…Ø§ÙÛŒØ§") return "mafia";
          if (teamFa === "Ø´Ù‡Ø±") return "city";
          return "independent";
        }
        function teamLabel(teamFa) {
          return t("teams." + teamKeyFromFa(teamFa));
        }
        function roleName(roleId) {
          const r = roles[roleId];
          if (!r) return roleId;
          if (appLang === "fa") return r.faName || roleId;
          return (ROLE_I18N[roleId] && ROLE_I18N[roleId].name) ? ROLE_I18N[roleId].name : (r.faName || roleId);
        }
        function roleHint(roleId) {
          const r = roles[roleId];
          if (!r) return "";
          if (appLang === "fa") return r.hintFa || "";
          return (ROLE_I18N[roleId] && ROLE_I18N[roleId].hint) ? ROLE_I18N[roleId].hint : (r.hintFa || "");
        }
        function roleDesc(roleId, scenario) {
          const rBase = roles[roleId];
          const rOv = getScenarioConfig(scenario).roleOverrides?.[roleId] ?? null;
          const r = rBase ? { ...rBase, ...(rOv || {}) } : null;
          if (!r) return (appLang === "fa") ? "ØªÙˆØ¶ÛŒØ­ÛŒ Ø¨Ø±Ø§ÛŒ Ø§ÛŒÙ† Ù†Ù‚Ø´ Ø«Ø¨Øª Ù†Ø´Ø¯Ù‡ Ø§Ø³Øª." : "No description is available for this role.";
          if (appLang === "fa") return r.descFa || "ØªÙˆØ¶ÛŒØ­ÛŒ Ø¨Ø±Ø§ÛŒ Ø§ÛŒÙ† Ù†Ù‚Ø´ Ø«Ø¨Øª Ù†Ø´Ø¯Ù‡ Ø§Ø³Øª.";
          if (rOv && rOv.descEn) return rOv.descEn;
          if (ROLE_I18N[roleId] && ROLE_I18N[roleId].desc) return ROLE_I18N[roleId].desc;
          return r.descFa || "No description is available for this role.";
        }



        const toggleDefs = [
          // mafia
          { key: "mafiaBoss", roleId: "mafiaBoss", group: "mafia" },
          { key: "godfather", roleId: "godfather", group: "mafia" },
          { key: "alcapone", roleId: "alcapone", group: "mafia" },
          { key: "danMafia", roleId: "danMafia", group: "mafia" },
          { key: "doctorLecter", roleId: "doctorLecter", group: "mafia" },
          { key: "jokerMafia", roleId: "jokerMafia", group: "mafia" },
          { key: "swindler", roleId: "swindler", group: "mafia" },
          { key: "nato", roleId: "nato", group: "mafia" },
          { key: "negotiator", roleId: "negotiator", group: "mafia" },
          { key: "natasha", roleId: "natasha", group: "mafia" },
          { key: "matador", roleId: "matador", group: "mafia" },
          { key: "saulGoodman", roleId: "saulGoodman", group: "mafia" },
          { key: "witch", roleId: "witch", group: "mafia" },
          { key: "executioner", roleId: "executioner", group: "mafia" },
          { key: "informant", roleId: "informant", group: "mafia" },
          { key: "magician", roleId: "magician", group: "mafia" },
          { key: "bomber", roleId: "bomber", group: "mafia" },
          { key: "don", roleId: "don", group: "mafia" },
          { key: "rebel", roleId: "rebel", group: "mafia" },
          { key: "hacker", roleId: "hacker", group: "mafia" },

          // city
          { key: "detective", roleId: "detective", group: "city" },
          { key: "investigator", roleId: "investigator", group: "city" },
          { key: "doctor", roleId: "doctor", group: "city" },
          { key: "watson", roleId: "watson", group: "city" },
          { key: "researcher", roleId: "researcher", group: "city" },
          { key: "invulnerable", roleId: "invulnerable", group: "city" },
          { key: "armored", roleId: "armored", group: "city" },
          { key: "sniper", roleId: "sniper", group: "city" },
          { key: "professional", roleId: "professional", group: "city" },
          { key: "reporter", roleId: "reporter", group: "city" },
          { key: "representative", roleId: "representative", group: "city" },
          { key: "hardJohn", roleId: "hardJohn", group: "city" },
          { key: "psychologist", roleId: "psychologist", group: "city" },
          { key: "mayor", roleId: "mayor", group: "city" },
          { key: "seller", roleId: "seller", group: "city" },
          { key: "priest", roleId: "priest", group: "city" },
          { key: "judge", roleId: "judge", group: "city" },
          { key: "commander", roleId: "commander", group: "city" },
          { key: "kadkhoda", roleId: "kadkhoda", group: "city" },
          { key: "heir", roleId: "heir", group: "city" },
          { key: "herbalist", roleId: "herbalist", group: "city" },
          { key: "armorsmith", roleId: "armorsmith", group: "city" },
          { key: "suspect", roleId: "suspect", group: "city" },
          { key: "guard", roleId: "guard", group: "city" },
          { key: "ocean", roleId: "ocean", group: "city" },
          { key: "gunslinger", roleId: "gunslinger", group: "city" },
          { key: "leon", roleId: "leon", group: "city" },
          { key: "constantine", roleId: "constantine", group: "city" },
          { key: "citizenKane", roleId: "citizenKane", group: "city" },
          { key: "guide", roleId: "guide", group: "city" },
          { key: "minemaker", roleId: "minemaker", group: "city" },
          { key: "lawyer", roleId: "lawyer", group: "city" },
          { key: "bodyguard", roleId: "bodyguard", group: "city" },

          // independent
          { key: "zodiac", roleId: "zodiac", group: "independent" },
          { key: "nostradamus", roleId: "nostradamus", group: "independent" },
        ];

        // Importance rank for roles (lower = more important).
        // Used to order roles in UI lists (cast + setup roles).
        const ROLE_RANK = {
          // --- mafia ---
          mafiaBoss: 1,
          godfather: 2,
          danMafia: 3,
          alcapone: 4,
          doctorLecter: 5,
          natasha: 6,
          negotiator: 7,
          matador: 8,
          swindler: 9,
          bomber: 10,
          magician: 11,
          nato: 12,
          jokerMafia: 13,
          saulGoodman: 14,
          informant: 15,
          witch: 16,
          executioner: 17,
          don: 18,
          rebel: 19,
          hacker: 20,
          mafia: 999,

          // --- city ---
          mayor: 1,
          judge: 2,
          commander: 3,
          representative: 4,
          detective: 5,
          investigator: 6,
          doctor: 7,
          watson: 8,
          constantine: 9,
          citizenKane: 10,
          sniper: 11,
          professional: 12,
          leon: 13,
          guard: 14,
          hardJohn: 15,
          invulnerable: 16,
          armored: 17,
          psychologist: 18,
          reporter: 19,
          kadkhoda: 20,
          heir: 21,
          herbalist: 22,
          armorsmith: 23,
          suspect: 24,
          seller: 25,
          priest: 26,
          ocean: 27,
          gunslinger: 28,
          researcher: 29,
          guide: 30,
          bodyguard: 31,
          minemaker: 32,
          lawyer: 33,
          citizen: 999,

          // --- independent ---
          zodiac: 1,
          nostradamus: 4,
        };

        function roleRank(rid) {
          return (ROLE_RANK[rid] != null) ? ROLE_RANK[rid] : 500;
        }


        function clamp(n, min, max) { return Math.max(min, Math.min(max, n)); }
        function shuffle(arr) {
          for (let i = arr.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [arr[i], arr[j]] = [arr[j], arr[i]];
          }
          return arr;
        }

        function computeSuggestedMafia(nPlayers) {
          // classic-ish: ~1/4 (step function, good up to 30 players)
          if (nPlayers <= 6) return 1;
          if (nPlayers <= 9) return 2;
          if (nPlayers <= 12) return 3;
          if (nPlayers <= 16) return 4;
          if (nPlayers <= 20) return 5;
          if (nPlayers <= 24) return 6;
          if (nPlayers <= 28) return 7;
          return 8; // 29-30
        }

        function defaultTogglesForScenario(scenario) {
          const cfg = getScenarioConfig(scenario);
          const baseOff = Object.fromEntries(toggleDefs.map((d) => [d.key, false]));
          const out = { ...baseOff };
          for (const k of (cfg.defaultToggles || [])) out[k] = true;
          return out;
        }

        function sanitizeScenarioValue(v) {
          const sel = $("scenario");
          if (!sel) return "classic";
          const vv = (v || "").trim();
          const exists = Array.from(sel.options).some((o) => o.value === vv);
          return exists ? vv : "classic";
        }

        function getAllowedToggleKeysForScenario(scenario) {
          const allowed = getScenarioConfig(scenario).allowedRoles;
          if (!allowed) return null; // null means "all allowed"
          return new Set(allowed);
        }

        function normalizeTogglesForScenario(toggles, scenario) {
          const allowed = getAllowedToggleKeysForScenario(scenario);
          if (!allowed) return { ...toggles };
          const out = { ...toggles };
          for (const def of toggleDefs) {
            if (!allowed.has(def.key)) out[def.key] = false;
          }
          return out;
        }

        function buildRolePool(nPlayers, mafiaCount, toggles) {
          if (!Number.isFinite(nPlayers) || !Number.isFinite(mafiaCount)) {
            return { ok: false, error: "Ø§Ø¹Ø¯Ø§Ø¯ Ù†Ø§Ù…Ø¹ØªØ¨Ø± Ù‡Ø³ØªÙ†Ø¯." };
          }
          if (nPlayers < 5) return { ok: false, error: "Ø­Ø¯Ø§Ù‚Ù„ Ûµ Ø¨Ø§Ø²ÛŒÚ©Ù† Ù„Ø§Ø²Ù… Ø§Ø³Øª." };
          if (mafiaCount < 1) return { ok: false, error: "ØªØ¹Ø¯Ø§Ø¯ Ù…Ø§ÙÛŒØ§ Ø¨Ø§ÛŒØ¯ Ø­Ø¯Ø§Ù‚Ù„ Û± Ø¨Ø§Ø´Ø¯." };
          if (mafiaCount >= nPlayers) return { ok: false, error: "ØªØ¹Ø¯Ø§Ø¯ Ù…Ø§ÙÛŒØ§ Ø¨Ø§ÛŒØ¯ Ú©Ù…ØªØ± Ø§Ø² ØªØ¹Ø¯Ø§Ø¯ Ø¨Ø§Ø²ÛŒÚ©Ù†â€ŒÙ‡Ø§ Ø¨Ø§Ø´Ø¯." };

          // enforce scenario availability even if state was loaded from storage
          const scenario = $("scenario") ? $("scenario").value : "";
          const safeToggles = normalizeTogglesForScenario(toggles, scenario);

          const mafiaSpecials = [];
          const citySpecials = [];
          const independentSpecials = [];

          for (const def of toggleDefs) {
            if (!safeToggles[def.key]) continue;
            if (def.group === "mafia") mafiaSpecials.push(def.roleId);
            else if (def.group === "city") citySpecials.push(def.roleId);
            else independentSpecials.push(def.roleId);
          }

          if (mafiaSpecials.length > mafiaCount) {
            const exceed = mafiaSpecials.length - mafiaCount;
            const minMafia = mafiaSpecials.length;
            return {
              ok: false,
              error: `Ù†Ù‚Ø´â€ŒÙ‡Ø§ÛŒ Ø§Ù†ØªØ®Ø§Ø¨ Ø´Ø¯Ù‡ Ù…Ø§ÙÛŒØ§ Ø²ÛŒØ§Ø¯ Ø§Ø³Øª. ÛŒØ§ ${exceed.toLocaleString("fa-IR")} Ù†Ù‚Ø´ ÙˆÛŒÚ˜Ù‡ Ø±Ø§ Ø®Ø§Ù…ÙˆØ´ Ú©Ù†ÛŒØ¯ØŒ ÛŒØ§ ØªØ¹Ø¯Ø§Ø¯ Ù…Ø§ÙÛŒØ§ Ø±Ø§ Ø­Ø¯Ø§Ù‚Ù„ Ø¨Ù‡ ${minMafia.toLocaleString("fa-IR")} Ø¨Ø±Ø³Ø§Ù†ÛŒØ¯.`,
            };
          }

          const pool = [];
          pool.push(...mafiaSpecials);
          pool.push(...Array(Math.max(0, mafiaCount - mafiaSpecials.length)).fill("mafia"));
          pool.push(...citySpecials);
          pool.push(...independentSpecials);

          const remaining = nPlayers - pool.length;
          if (remaining < 0) {
            const minPlayers = pool.length;
            const exceed = minPlayers - nPlayers;
            return {
              ok: false,
              error: `ØªØ¹Ø¯Ø§Ø¯ Ø´Ù‡Ø±ÙˆÙ†Ø¯Ù Ø³Ø§Ø¯Ù‡ Ø¯Ø±Ø³Øª Ù†ÛŒØ³Øª. ÛŒØ§ ${exceed.toLocaleString("fa-IR")} Ù†Ù‚Ø´ ÙˆÛŒÚ˜Ù‡ Ø±Ø§ Ø®Ø§Ù…ÙˆØ´ Ú©Ù†ÛŒØ¯ØŒ ÛŒØ§ ØªØ¹Ø¯Ø§Ø¯ Ø¨Ø§Ø²ÛŒÚ©Ù†â€ŒÙ‡Ø§ Ø±Ø§ Ø­Ø¯Ø§Ù‚Ù„ Ø¨Ù‡ ${minPlayers.toLocaleString("fa-IR")} Ø¨Ø±Ø³Ø§Ù†ÛŒØ¯.`,
            };
          }

          pool.push(...Array(remaining).fill("citizen"));
          shuffle(pool);
          return { ok: true, pool };
        }

        function summarizePool(pool) {
          const c = {};
          for (const r of pool) c[r] = (c[r] || 0) + 1;
          let mafiaTotal = 0;
          let cityTotal = 0;
          let independentTotal = 0;
          for (const rid of pool) {
            const t = (roles[rid] && roles[rid].teamFa) ? roles[rid].teamFa : "Ø´Ù‡Ø±";
            if (t === "Ù…Ø§ÙÛŒØ§") mafiaTotal++;
            else if (t === "Ø´Ù‡Ø±") cityTotal++;
            else independentTotal++;
          }
          return { counts: c, mafiaTotal, cityTotal, independentTotal };
        }

        function setError(msg) {
          const boxes = [$("errorBox"), $("errorBoxPlayers")].filter(Boolean);
          for (const box of boxes) {
            if (!msg) {
              box.style.display = "none";
              box.textContent = "";
            } else {
              box.style.display = "block";
              box.textContent = msg;
            }
          }
        }

        function setSaveState(enabled) {
          const el = $("saveState");
          if (!el) return;
          el.textContent = t("saveState.label", { state: enabled ? t("common.on") : t("common.off") });
        }

        function readUIState() {
          const scenario = $("scenario").value;
          const nPlayers = parseInt($("playersCount").value, 10);
          const mafiaCount = parseInt($("mafiaCount").value, 10);
          const toggles = {};
          for (const def of toggleDefs) {
            const wrap = $("tgwrap_" + def.key);
            toggles[def.key] = !!(wrap && wrap.classList.contains("on"));
          }
          return { scenario, nPlayers, mafiaCount, toggles };
        }

        function applyToggles(toggles, { disableMafiaBoss, disableSwindler } = {}) {
          // Enforce constraints by turning off roles when needed.
          if (disableSwindler && toggles) toggles.swindler = false;
          if (disableMafiaBoss && toggles) toggles.mafiaBoss = false;

          for (const def of toggleDefs) {
            const wrap = $("tgwrap_" + def.key);
            if (!wrap) continue;
            const val = !!(toggles && toggles[def.key]);
            wrap.classList.toggle("on", val);
            wrap.setAttribute("aria-pressed", val ? "true" : "false");

            const isDisabled =
              (disableSwindler && def.key === "swindler") ||
              (disableMafiaBoss && def.key === "mafiaBoss");
            wrap.classList.toggle("disabled", !!isDisabled);
            if (isDisabled) wrap.setAttribute("aria-disabled", "true");
            else wrap.removeAttribute("aria-disabled");
          }
        }

        function applyScenarioAvailability(scenario) {
          const allowed = getAllowedToggleKeysForScenario(scenario);
          const visibleCounts = { mafia: 0, city: 0, independent: 0 };
          for (const def of toggleDefs) {
            const wrap = $("tgwrap_" + def.key);
            if (!wrap) continue;
            const isAllowed = !allowed || allowed.has(def.key);
            wrap.style.display = isAllowed ? "flex" : "none";
            if (!isAllowed) {
              // When a role isn't available in this scenario, force it off.
              if (appState && appState.ui && appState.ui.toggles) appState.ui.toggles[def.key] = false;
              wrap.classList.remove("on");
              wrap.setAttribute("aria-pressed", "false");
              wrap.classList.add("disabled");
              wrap.setAttribute("aria-disabled", "true");
            } else {
              // allow interaction; actual constraints are applied via applyToggles()
              wrap.classList.remove("disabled");
              wrap.removeAttribute("aria-disabled");
              if (def.group === "mafia") visibleCounts.mafia++;
              else if (def.group === "city") visibleCounts.city++;
              else visibleCounts.independent++;
            }
          }

          // Team headers: mafia/city always shown (base roles live there). Independent shown only if any role is visible.
          const hdrM = $("teamHdr_mafia");
          const hdrC = $("teamHdr_city");
          const hdrI = $("teamHdr_independent");
          if (hdrM) hdrM.style.display = "flex";
          if (hdrC) hdrC.style.display = "flex";
          if (hdrI) hdrI.style.display = visibleCounts.independent ? "flex" : "none";
        }

        function renderToggles() {
          const host = $("toggles");
          host.innerHTML = "";

          const teamClsForGroup = (g) => (
            g === "mafia" ? "team-mafia" :
            g === "city" ? "team-city" : "team-ind"
          );
          const addHdr = (id, label, teamCls) => {
            const h = document.createElement("div");
            h.className = `teamHdr ${teamCls || ""}`.trim();
            h.id = id;
            h.textContent = label;
            host.appendChild(h);
          };

          const baseCitizen = document.createElement("div");
          baseCitizen.className = "toggle base team-city";
          baseCitizen.id = "base_citizen";
          baseCitizen.innerHTML = `
            <span class="meta">
              <span class="name">${escapeHtml(roleName("citizen"))}</span>
              <span class="hint">${escapeHtml(t("toggles.variableCount"))}</span>
            </span>
            <span class="right">
              <button class="miniHelp" type="button" data-rolehelp="citizen" aria-label="${escapeHtml(t("common.roleHelp"))}">?</button>
              <span class="countpill" id="cnt_citizen">Ã— 0</span>
            </span>
          `;
          const baseMafia = document.createElement("div");
          baseMafia.className = "toggle base team-mafia";
          baseMafia.id = "base_mafia";
          baseMafia.innerHTML = `
            <span class="meta">
              <span class="name">${escapeHtml(roleName("mafia"))}</span>
              <span class="hint">${escapeHtml(t("toggles.variableCount"))}</span>
            </span>
            <span class="right">
              <button class="miniHelp" type="button" data-rolehelp="mafia" aria-label="${escapeHtml(t("common.roleHelp"))}">?</button>
              <span class="countpill" id="cnt_mafia">Ã— 0</span>
            </span>
          `;

          const groupOrder = ["mafia", "city", "independent"];
          const groupLabel = { mafia: t("teams.mafiaTeam"), city: t("teams.cityTeam"), independent: t("teams.independent") };
          const defsByGroup = { mafia: [], city: [], independent: [] };
          for (const def of toggleDefs) {
            if (def.group === "mafia") defsByGroup.mafia.push(def);
            else if (def.group === "city") defsByGroup.city.push(def);
            else defsByGroup.independent.push(def);
          }
          for (const g of groupOrder) {
            addHdr(`teamHdr_${g}`, groupLabel[g] || g, teamClsForGroup(g));
            if (g === "mafia") host.appendChild(baseMafia);
            if (g === "city") host.appendChild(baseCitizen);
            const sorted = defsByGroup[g].slice().sort((a, b) => {
              return (roleRank(a.roleId) - roleRank(b.roleId))
                || String(a.key).localeCompare(String(b.key), "fa");
            });
            for (const def of sorted) {
            const r = roles[def.roleId];
            // If a toggle points to a missing role, skip it (prevents app crash on load)
            if (!r) continue;
            const el = document.createElement("div");
            el.className = `toggle ${teamClsForGroup(g)}`.trim();
            el.id = "tgwrap_" + def.key;
            el.dataset.key = def.key;
            el.setAttribute("role", "button");
            el.setAttribute("tabindex", "0");
            el.setAttribute("aria-pressed", "false");
            el.innerHTML = `
              <span class="meta">
                <span class="name">${escapeHtml(roleName(def.roleId))}</span>
                <span class="hint">${escapeHtml(roleHint(def.roleId))}</span>
              </span>
              <span class="right">
                <button class="miniHelp" type="button" data-rolehelp="${escapeHtml(def.roleId)}" aria-label="${escapeHtml(t("common.roleHelp"))}">?</button>
              </span>
            `;
            host.appendChild(el);
          }
          }
        }

        function fillPlayersSelect() {
          const sel = $("playersCount");
          sel.innerHTML = "";
          const fmt = (typeof toFarsiNum === "function" && appLang === "fa") ? toFarsiNum : String;
          for (let n = 5; n <= 30; n++) {
            const opt = document.createElement("option");
            opt.value = String(n);
            opt.textContent = fmt(n);
            sel.appendChild(opt);
          }
        }

        function fillMafiaSelect(nPlayers, suggested) {
          const sel = $("mafiaCount");
          const current = parseInt(sel.value || String(suggested), 10);
          sel.innerHTML = "";
          const maxMafia = Math.max(1, Math.floor((nPlayers - 1) / 2));
          const fmt = (typeof toFarsiNum === "function" && appLang === "fa") ? toFarsiNum : String;
          for (let m = 1; m <= maxMafia; m++) {
            const opt = document.createElement("option");
            opt.value = String(m);
            opt.textContent = fmt(m);
            sel.appendChild(opt);
          }
          sel.value = String(clamp(current, 1, maxMafia));
        }

        function updateQuickStat() {
          const s = readUIState();
          const res = buildRolePool(s.nPlayers, s.mafiaCount, s.toggles);
          if (!res.ok) {
            const msg = res.error || t("error.config");
            // Also show the full error in the setup page error box.
            const box = $("errorBox");
            if (box) {
              box.dataset.src = "config";
              box.style.display = "block";
              box.textContent = msg;
            }
            return;
          }
          // Clear setup error box only if it was set by config validation.
          const box = $("errorBox");
          if (box && box.dataset && box.dataset.src === "config") {
            box.style.display = "none";
            box.textContent = "";
            delete box.dataset.src;
          }
          const sum = summarizePool(res.pool);

          // update base role counters
          const cCitizen = $("cnt_citizen");
          const cMafia = $("cnt_mafia");
          const nCitizen = sum.counts.citizen || 0;
          const nMafia = sum.counts.mafia || 0;
          const fmt = (appLang === "fa" && typeof toFarsiNum === "function") ? toFarsiNum : String;
          if (cCitizen) cCitizen.textContent = `Ã— ${fmt(nCitizen)}`;
          if (cMafia) cMafia.textContent = `Ã— ${fmt(nMafia)}`;

          // Make base cards look selected when count > 0.
          const baseCitizen = $("base_citizen");
          const baseMafia = $("base_mafia");
          if (baseCitizen) baseCitizen.classList.toggle("on", nCitizen > 0);
          if (baseMafia) baseMafia.classList.toggle("on", nMafia > 0);
        }

        function shouldPersist() {
          try { return !!localStorage; } catch { return false; }
        }

        function loadLastNames() {
          if (!shouldPersist()) return null;
          const raw = localStorage.getItem(LAST_NAMES_KEY);
          if (!raw) return null;
          try {
            const v = JSON.parse(raw);
            return Array.isArray(v) ? v : null;
          } catch {
            return null;
          }
        }

        function saveLastNames(names) {
          if (!shouldPersist()) return;
          localStorage.setItem(LAST_NAMES_KEY, JSON.stringify(names));
        }

        function saveState(state) {
          if (!shouldPersist()) return;
          localStorage.setItem(STORAGE_KEY, JSON.stringify(state));
          setSaveState(true);
          // Keep the "saved game" bar in sync with state changes.
          try { if (typeof updateResumeUI === "function") updateResumeUI(); } catch {}
        }

        function loadState() {
          if (!shouldPersist()) return null;
          const raw = localStorage.getItem(STORAGE_KEY);
          if (!raw) return null;
          try { return JSON.parse(raw); } catch { return null; }
        }

        function clearState() {
          if (!shouldPersist()) return;
          localStorage.removeItem(STORAGE_KEY);
          setSaveState(false);
          try { if (typeof updateResumeUI === "function") updateResumeUI(); } catch {}
        }

        function showSetup() {
          $("playersCard").classList.add("hidden");
          $("setupCard").classList.remove("hidden");
          $("cardsCard").classList.add("hidden");
          $("castCard").classList.add("hidden");
          updateResumeUI();
          updateDocTitle();
          window.scrollTo({ top: 0, behavior: "instant" });
        }
        function showPlayers() {
          $("setupCard").classList.add("hidden");
          $("playersCard").classList.remove("hidden");
          $("cardsCard").classList.add("hidden");
          $("castCard").classList.add("hidden");
          updateDocTitle();
          window.scrollTo({ top: 0, behavior: "instant" });
        }
        function showCards() {
          $("setupCard").classList.add("hidden");
          $("playersCard").classList.add("hidden");
          $("cardsCard").classList.remove("hidden");
          $("castCard").classList.add("hidden");
          updateDocTitle();
          window.scrollTo({ top: 0, behavior: "instant" });
        }
        function showCast() {
          $("setupCard").classList.add("hidden");
          $("playersCard").classList.add("hidden");
          $("cardsCard").classList.add("hidden");
          $("castCard").classList.remove("hidden");
          $("castCard").classList.remove("cast-blurred");
          updateCastPrivacyBtn();
          updateDocTitle();
          window.scrollTo({ top: 0, behavior: "instant" });
        }
        function updateCastPrivacyBtn() {
          const blurred = $("castCard").classList.contains("cast-blurred");
          const icon = $("castPrivacyIcon");
          const label = $("castPrivacyLabel");
          if (icon) icon.innerHTML = blurred
            ? '<path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>'
            : '<path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46A11.804 11.804 0 0 0 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>';
          if (label) {
            label.setAttribute("data-i18n", blurred ? "cast.reveal" : "cast.hide");
            label.textContent = blurred
              ? (appLang === "fa" ? "Ù†Ù…Ø§ÛŒØ´ Ù†Ù‚Ø´â€ŒÙ‡Ø§" : "Reveal Roles")
              : (appLang === "fa" ? "Ù¾Ù†Ù‡Ø§Ù†â€ŒÚ©Ø±Ø¯Ù† Ù†Ù‚Ø´â€ŒÙ‡Ø§" : "Hide Roles");
          }
        }

        function openModal() {
          const m = $("modal");
          m.style.display = "flex";
          m.setAttribute("aria-hidden", "false");
        }
        function closeModal() {
          const m = $("modal");
          m.style.display = "none";
          m.setAttribute("aria-hidden", "true");
        }

        function renderCards() {
          const draw = appState.draw;
          if (!draw || !draw.deck || !draw.players) return;

          const n = draw.players.length;
          const cur = draw.currentIdx || 0;
          const done = cur >= n;

          $("cardsStat").textContent = `${Math.min(cur, n)} / ${n}`;
          $("cardsWho").textContent = done
            ? t("common.done")
            : `${t("common.turn")}: ${((appState.ui.playerNames && appState.ui.playerNames[cur]) ? appState.ui.playerNames[cur] : t("common.playerN", { n: cur + 1 }))}`;

          const nextBtn = $("cardsNextBtn");
          nextBtn.disabled = !done;

          const host = $("cardsGrid");
          host.innerHTML = "";
          for (let i = 0; i < n; i++) {
            const used = !!(draw.usedCards && draw.usedCards[i]);
            const b = document.createElement("button");
            b.type = "button";
            b.className = "cardBtn" + (used ? " used" : "");
            b.textContent = used ? t("common.taken") : t("common.cardN", { n: i + 1 });
            b.disabled = used || done;
            b.addEventListener("click", () => onPickCard(i));
            host.appendChild(b);
          }
        }

        let appState = {
          ui: {
            scenario: "classic",
            nPlayers: 10,
            mafiaCount: 3,
            toggles: defaultTogglesForScenario("classic"),
            playerNames: [],
            customized: false,
            // If user has saved "last names", default to using them.
            namesMode: (function () {
              const last = loadLastNames();
              return (last && last.some((x) => String(x || "").trim())) ? "last" : "default";
            })(), // default | last
          },
          draw: null, // cards mode: { deck, usedCards, players, currentIdx, createdAt, uiAtDraw }
          god: {
            status: null,
            lastMove: null,
            timers: null,
            chance: null,
          },
        };

        function openToolModal(title, bodyHtml, { hideBottom } = {}) {
          const tb = $("toolBody");
          const m = $("toolModal");
          // Preserve scroll position when refreshing an already-open modal (e.g. gun give, undo shot).
          const prevScroll = (m.style.display === "flex") ? tb.scrollTop : 0;
          // Also preserve nested scroll containers (e.g. voting player cards, night target grids).
          const nestedScrolls = [];
          if (m.style.display === "flex") {
            try {
              tb.querySelectorAll(".fl-scrollable").forEach((el) => {
                nestedScrolls.push(el.scrollTop);
              });
            } catch {}
          }
          $("toolTitle").textContent = title;
          tb.innerHTML = bodyHtml;
          $("toolBottom").style.display = hideBottom ? "none" : "flex";
          m.style.display = "flex";
          m.setAttribute("aria-hidden", "false");
          if (prevScroll > 0) tb.scrollTop = prevScroll;
          nestedScrolls.forEach((saved, i) => {
            try {
              const el = tb.querySelectorAll(".fl-scrollable")[i];
              if (el) el.scrollTop = saved;
            } catch {}
          });
        }
        function closeToolModal() {
          const m = $("toolModal");
          // If Flow modal is open, auto-save current selections before closing.
          // (This makes closing behave like "Next" in terms of saving.)
          try {
            if (typeof window !== "undefined" && window.__flowOnClose && typeof window.__flowOnClose === "function") {
              window.__flowOnClose();
            }
          } catch {}
          m.style.display = "none";
          m.setAttribute("aria-hidden", "true");
          // After closing any tool (especially Flow), refresh visible UI that depends on flow/player state.
          try { if (typeof renderCast === "function" && $("castCard") && !$("castCard").classList.contains("hidden")) renderCast(); } catch {}
          try { if (typeof renderCast === "function" && $("castCard") && $("castCard").classList.contains("hidden")) renderCast(); } catch {}
          try { if (typeof renderNameGrid === "function" && $("playersCard") && !$("playersCard").classList.contains("hidden")) renderNameGrid(); } catch {}
          try { if (typeof updateQuickStat === "function") updateQuickStat(); } catch {}
          try { if (typeof updateResumeUI === "function") updateResumeUI(); } catch {}
        }

        function getScenario() {
          return (appState.ui && appState.ui.scenario) ? appState.ui.scenario : (($("scenario") && $("scenario").value) || "classic");
        }

        function formatMMSS(sec) {
          const s = Math.max(0, Math.floor(sec));
          const m = Math.floor(s / 60);
          const r = s % 60;
          return String(m).padStart(1, "0") + ":" + String(r).padStart(2, "0");
        }

        function countTeamsFromDraw() {
          const draw = appState.draw;
          if (!draw || !draw.players) {
            return {
              alive: 0, dead: 0, total: 0,
              mafiaAlive: 0, mafiaDead: 0,
              cityAlive: 0, cityDead: 0,
              indAlive: 0, indDead: 0,
            };
          }
          let mafiaAlive = 0, mafiaDead = 0, cityAlive = 0, cityDead = 0, indAlive = 0, indDead = 0;
          for (const p of draw.players) {
            const rid = p.roleId || "citizen";
            const t = (roles[rid] && roles[rid].teamFa) ? roles[rid].teamFa : "Ø´Ù‡Ø±";
            const alive = p.alive !== false; // default alive
            if (t === "Ù…Ø§ÙÛŒØ§") {
              if (alive) mafiaAlive++;
              else mafiaDead++;
            } else if (t === "Ø´Ù‡Ø±") {
              if (alive) cityAlive++;
              else cityDead++;
            } else {
              if (alive) indAlive++;
              else indDead++;
            }
          }
          const total = draw.players.length;
          const alive = mafiaAlive + cityAlive + indAlive;
          const dead = mafiaDead + cityDead + indDead;
          return { alive, dead, total, mafiaAlive, mafiaDead, cityAlive, cityDead, indAlive, indDead };
        }

        function syncGodStatusFromPlayers() {
          // `appState.god` can be cleared when starting a new game; ensure it's present before syncing.
          if (!appState.god || typeof appState.god !== "object") appState.god = {};
          appState.god.status = countTeamsFromDraw();
        }

        function getAllowedRoleIdsForScenario() {
          const scenario = getScenario();
          const allowedKeys = getScenarioConfig(scenario).allowedRoles || [];
          const keyToRole = {};
          for (const d of toggleDefs) keyToRole[d.key] = d.roleId;
          const ids = new Set(["citizen", "mafia"]);
          for (const k of allowedKeys) {
            const rid = keyToRole[k] || k; // many lists are keys; some might already be roleIds
            if (roles[rid]) ids.add(rid);
          }
          return Array.from(ids);
        }

        function showWakeTool() {
          const scenario = getScenario();
          const title = t("tool.wake.title");
          const wakeOrder = getScenarioConfig(scenario).wakeOrder || {};
          const list = appLang === "en" ? (wakeOrder.en || wakeOrder.fa || []) : (wakeOrder.fa || []);
          const scenarioName = (($("scenario") && $("scenario").selectedOptions && $("scenario").selectedOptions[0]) ? $("scenario").selectedOptions[0].textContent : scenario);
          const itemsHtml = list.length
            ? `<div class="toolBox"><div style="font-weight:1100;margin-bottom:6px">${escapeHtml(t("tool.wake.scenario", { name: scenarioName }))}</div>${list.map((x, i) => `<div style="padding:6px 0;font-weight:950">${i + 1}. ${escapeHtml(x)}</div>`).join("")}</div>`
            : `<div class="toolBox">${escapeHtml(t("tool.wake.none"))}</div>`;
          openToolModal(title, itemsHtml);
        }

        function showStatusTool() {
          syncGodStatusFromPlayers();
          const s = appState.god.status;
          const out = (s && typeof s.dead === "number") ? s.dead : 0;
          const m = (s && typeof s.mafiaDead === "number") ? s.mafiaDead : 0;
          const c = (s && typeof s.cityDead === "number") ? s.cityDead : 0;
          const i = (s && typeof s.indDead === "number") ? s.indDead : 0;
          const aliveTotal = (s && typeof s.alive === "number") ? s.alive : 0;
          const mA = (s && typeof s.mafiaAlive === "number") ? s.mafiaAlive : 0;
          const cA = (s && typeof s.cityAlive === "number") ? s.cityAlive : 0;
          const iA = (s && typeof s.indAlive === "number") ? s.indAlive : 0;

          const fmtNum = (n) => {
            try {
              const loc = (appLang === "fa") ? "fa-IR" : "en-US";
              return Number(n || 0).toLocaleString(loc);
            } catch {
              return String(n || 0);
            }
          };
          const joinList = (parts) => {
            const xs = (parts || []).filter(Boolean);
            if (xs.length <= 1) return xs[0] || "";
            if (appLang === "fa") {
              if (xs.length === 2) return `${xs[0]} Ùˆ ${xs[1]}`;
              return xs.slice(0, -1).join("ØŒ ") + " Ùˆ " + xs[xs.length - 1];
            }
            if (xs.length === 2) return `${xs[0]} and ${xs[1]}`;
            return xs.slice(0, -1).join(", ") + " and " + xs[xs.length - 1];
          };
          // Colored number spans: total=amber, mafia=red, citizen=teal, indep=purple
          const numH = (val, type) => {
            const color = type === "mafia" ? "rgba(255,90,70,1)"
              : type === "citizen" ? "rgba(60,210,160,1)"
              : type === "indep" ? "rgba(190,140,255,1)"
              : "rgba(255,215,55,1)"; // total
            return `<span style="color:${color}; font-weight:1100">${fmtNum(val)}</span>`;
          };
          const teamParts = () => {
            if (appLang === "fa") {
              return [
                m ? `${numH(m, "mafia")} Ù…Ø§ÙÛŒØ§` : "",
                c ? `${numH(c, "citizen")} Ø´Ù‡Ø±ÙˆÙ†Ø¯` : "",
                i ? `${numH(i, "indep")} Ù…Ø³ØªÙ‚Ù„` : "",
              ].filter(Boolean);
            }
            const citizenLabel = (n) => n === 1 ? "Citizen" : "Citizens";
            const indepLabel = (n) => n === 1 ? "Independent" : "Independents";
            return [
              m ? `${numH(m, "mafia")} Mafia` : "",
              c ? `${numH(c, "citizen")} ${citizenLabel(c)}` : "",
              i ? `${numH(i, "indep")} ${indepLabel(i)}` : "",
            ].filter(Boolean);
          };
          const aliveParts = () => {
            if (appLang === "fa") {
              return [
                mA ? `${numH(mA, "mafia")} Ù…Ø§ÙÛŒØ§` : "",
                cA ? `${numH(cA, "citizen")} Ø´Ù‡Ø±ÙˆÙ†Ø¯` : "",
                iA ? `${numH(iA, "indep")} Ù…Ø³ØªÙ‚Ù„` : "",
              ].filter(Boolean);
            }
            const citizenLabel = (n) => n === 1 ? "Citizen" : "Citizens";
            const indepLabel = (n) => n === 1 ? "Independent" : "Independents";
            return [
              mA ? `${numH(mA, "mafia")} Mafia` : "",
              cA ? `${numH(cA, "citizen")} ${citizenLabel(cA)}` : "",
              iA ? `${numH(iA, "indep")} ${indepLabel(iA)}` : "",
            ].filter(Boolean);
          };
          // summaryText and aliveLine are HTML strings (numbers wrapped in colored spans)
          const summaryText = (() => {
            const total = out || 0;
            const parts = teamParts();
            if (total <= 0) {
              return (appLang === "fa")
                ? "Ø§Ø² Ø¨Ø§Ø²ÛŒ Ø´Ù…Ø§ Ù‡Ù†ÙˆØ² Ú©Ø³ÛŒ Ø®Ø§Ø±Ø¬ Ù†Ø´Ø¯Ù‡ Ø§Ø³Øª."
                : "From your game no one is out yet.";
            }
            if (parts.length === 1) {
              // only one team has any out â€” extract team label without number
              const teamOnlyFa = m ? "Ù…Ø§ÙÛŒØ§" : c ? "Ø´Ù‡Ø±ÙˆÙ†Ø¯" : "Ù…Ø³ØªÙ‚Ù„";
              const teamOnlyEn = m ? "Mafia" : c ? (total === 1 ? "Citizen" : "Citizens") : (total === 1 ? "Independent" : "Independents");
              if (appLang === "fa") {
                if (total === 1) return `Ø§Ø² Ø¨Ø§Ø²ÛŒ Ø´Ù…Ø§ ${numH(total, "total")} Ù†ÙØ± Ø®Ø§Ø±Ø¬ Ø´Ø¯Ù‡ Ø§Ø³ØªØ› Ø§Ùˆ ${teamOnlyFa} Ø¨ÙˆØ¯Ù‡ Ø§Ø³Øª.`;
                return `Ø§Ø² Ø¨Ø§Ø²ÛŒ Ø´Ù…Ø§ ${numH(total, "total")} Ù†ÙØ± Ø®Ø§Ø±Ø¬ Ø´Ø¯Ù‡â€ŒØ§Ù†Ø¯Ø› Ù‡Ù…Ù‡Ù” Ø¢Ù†â€ŒÙ‡Ø§ ${teamOnlyFa} Ø¨ÙˆØ¯Ù‡â€ŒØ§Ù†Ø¯.`;
              }
              const isOne = total === 1;
              const head = isOne ? `From your game ${numH(total, "total")} person is out` : `From your game ${numH(total, "total")} people are out`;
              if (isOne) {
                const withArticle = (teamOnlyEn === "Citizen") ? "a Citizen" : (teamOnlyEn === "Independent") ? "an Independent" : teamOnlyEn;
                return `${head}, they were ${withArticle}.`;
              }
              return `${head}, all of them were ${teamOnlyEn}.`;
            }
            // multiple teams
            if (appLang === "fa") {
              return `Ø§Ø² Ø¨Ø§Ø²ÛŒ Ø´Ù…Ø§ ${numH(total, "total")} Ù†ÙØ± Ø®Ø§Ø±Ø¬ Ø´Ø¯Ù‡â€ŒØ§Ù†Ø¯Ø› ${joinList(parts)}.`;
            }
            const head = (total === 1)
              ? `From your game ${numH(total, "total")} person is out`
              : `From your game ${numH(total, "total")} people are out`;
            return `${head}. ${joinList(parts)}.`;
          })();
          const aliveLine = (() => {
            const total = aliveTotal || 0;
            const parts = aliveParts();
            if (total <= 0) {
              return (appLang === "fa")
                ? "Ø¯Ø± Ø¨Ø§Ø²ÛŒ Ø´Ù…Ø§ Ú©Ø³ÛŒ Ø²Ù†Ø¯Ù‡ Ù†ÛŒØ³Øª."
                : "No one is alive in your game.";
            }
            if (appLang === "fa") {
              return `Ø¯Ø± Ø¨Ø§Ø²ÛŒ Ø´Ù…Ø§ ${numH(total, "total")} Ù†ÙØ± Ø¯Ø§Ø®Ù„ Ø¨Ø§Ø²ÛŒ Ù‡Ø³ØªÙ†Ø¯Ø› ${joinList(parts)}.`;
            }
            const head = (total === 1)
              ? `In your game ${numH(total, "total")} person is still in`
              : `In your game ${numH(total, "total")} people are still in`;
            return `${head}. ${joinList(parts)}.`;
          })();

          const timelineHtml = (() => {
            try {
              const f = (appState.god && appState.god.flow) ? ensureFlow() : null;
              const evs = (f && Array.isArray(f.events)) ? f.events.slice() : [];
              const draw = appState.draw;
              const scenario = getDrawScenarioForFlow();
              const names = getPlayerNamesForFlow();
              if (!evs.length && (!f || f.phase === "intro_day" || f.phase === "intro_night")) {
                const noneTxt = (appLang === "fa")
                  ? "Ù‡Ù†ÙˆØ² Ú†ÛŒØ²ÛŒ Ø¯Ø± Ø±ÙˆÙ†Ø¯ Ø¨Ø§Ø²ÛŒ Ø«Ø¨Øª Ù†Ø´Ø¯Ù‡ Ø§Ø³Øª."
                  : "Nothing has been recorded in the game flow yet.";
                return `<div class="toolBox" style="margin-top:12px"><div style="font-weight:1100; margin-bottom:6px">${escapeHtml(appLang === "fa" ? "Ø±ÙˆÙ†Ø¯ (Ø±ÙˆØ²/Ø´Ø¨)" : "Timeline (Day/Night)")}</div><div class="note">${escapeHtml(noneTxt)}</div></div>`;
              }

              const plainNameOf = (idx) => {
                const i = parseInt(idx, 10);
                if (!Number.isFinite(i) || i < 0 || !draw || !draw.players || i >= draw.players.length) return appLang === "fa" ? "â€”" : "â€”";
                return names[i] || t("common.playerN", { n: i + 1 });
              };
              const nameOf = (idx) => {
                const i = parseInt(idx, 10);
                if (!Number.isFinite(i) || i < 0 || !draw || !draw.players || i >= draw.players.length) return plainNameOf(i);
                const rid = (draw.players[i] && draw.players[i].roleId) ? draw.players[i].roleId : "citizen";
                const rn = (typeof roleName === "function") ? roleName(rid) : String(rid || "");
                return `${plainNameOf(i)} (${rn})`;
              };
              const nameOfWithRole = (idx, roleId) => {
                const i = parseInt(idx, 10);
                if (!Number.isFinite(i) || i < 0 || !draw || !draw.players || i >= draw.players.length) return plainNameOf(i);
                const rid = roleId || "citizen";
                const rn = (typeof roleName === "function") ? roleName(rid) : String(rid || "");
                return `${plainNameOf(i)} (${rn})`;
              };
              const listNames = (idxs) => {
                const arr = Array.isArray(idxs) ? idxs : [];
                const clean = arr.map((x) => parseInt(x, 10)).filter((x) => Number.isFinite(x));
                if (!clean.length) return appLang === "fa" ? "â€”" : "â€”";
                const parts = clean.map((i) => nameOf(i));
                // use simple join for readability
                return (appLang === "fa") ? parts.join("ØŒ ") : parts.join(", ");
              };
              const idxFrom = (v) => {
                const n = parseInt(String(v ?? "").trim(), 10);
                if (!Number.isFinite(n)) return null;
                if (!draw || !draw.players) return n;
                if (n < 0 || n >= draw.players.length) return null;
                return n;
              };
              const idxArrFrom = (v) => {
                if (v === null || v === undefined) return [];
                const arr = Array.isArray(v) ? v : [v];
                return arr.map((x) => idxFrom(x)).filter((x) => x !== null);
              };
              const hasAnyRole = (roleIds) => {
                try {
                  const ids = Array.isArray(roleIds) ? roleIds : [roleIds];
                  for (const p of (draw.players || [])) {
                    if (!p) continue;
                    if (ids.includes(p.roleId)) return true;
                  }
                  return false;
                } catch {
                  return false;
                }
              };
              const findIdxByRole = (roleIds) => {
                try {
                  const ids = Array.isArray(roleIds) ? roleIds : [roleIds];
                  for (let i = 0; i < (draw.players || []).length; i++) {
                    const p = draw.players[i];
                    if (!p) continue;
                    if (ids.includes(p.roleId)) return i;
                  }
                  return null;
                } catch {
                  return null;
                }
              };
              const phaseTitle = (day, phase) => {
                const d = fmtNum(day);
                if (phase === "night") return (appLang === "fa") ? `Ø´Ø¨ ${d}` : `Night ${d}`;
                if (phase === "midday") return (appLang === "fa") ? `Ù†ÛŒÙ…â€ŒØ±ÙˆØ² ${d}` : `Mid-day ${d}`;
                return (appLang === "fa") ? `Ø±ÙˆØ² ${d}` : `Day ${d}`;
              };
              const phaseOrder = { day: 0, midday: 1, night: 2 };
              // Only show events strictly before the current flow position so that
              // navigating backwards in the Flow window hides future-phase logs.
              const curFlowDay = f ? (f.day || 1) : Infinity;
              const curFlowPo = f ? (phaseOrder[f.phase] ?? 99) : Infinity;
              const groups = new Map(); // key -> { day, phase, items: [] }
              for (const e of evs) {
                if (!e || !e.phase || e.day === undefined || e.day === null) continue;
                const day = parseInt(e.day, 10);
                const phase = String(e.phase);
                if (!Number.isFinite(day) || !["day", "midday", "night"].includes(phase)) continue;
                // Skip events from the current phase and any phase after it.
                if (day > curFlowDay) continue;
                if (day === curFlowDay && (phaseOrder[phase] ?? 99) >= curFlowPo) {
                  // Exception: gun_shot events that have already been applied are shown
                  // even while still in "day" phase (they occur at an earlier step within the day).
                  if (e.kind === "gun_shot") {
                    const _gsRec = f && f.draft && f.draft.gunShotAppliedByDay && f.draft.gunShotAppliedByDay[String(day)];
                    if (!_gsRec || !_gsRec.applied) continue;
                    // applied â€” fall through and include in group
                  } else {
                    continue;
                  }
                }
                const key = `${day}:${phase}`;
                if (!groups.has(key)) groups.set(key, { day, phase, items: [] });
                groups.get(key).items.push(e);
              }
              // Bazras: ensure a day group exists for any day that has interrogation data,
              // even when no day-phase events have been logged yet (e.g. forced-vote step
              // precedes day_vote/day_elim, or the user is viewing from night phase).
              if (f && f.draft && f.draft.bazrasInterrogationByDay && scenario === "bazras") {
                try {
                  for (const dk of Object.keys(f.draft.bazrasInterrogationByDay)) {
                    const day = parseInt(dk, 10);
                    if (!Number.isFinite(day)) continue;
                    if (day > curFlowDay) continue;
                    // Allow current day through if a decision has already been recorded
                    // (forced-vote decision/cancel was selected â€” show result even while still in day phase).
                    const irecChk = f.draft.bazrasInterrogationByDay[dk];
                    const hasDecision = irecChk && irecChk.decision;
                    if (day === curFlowDay && (phaseOrder["day"] ?? 99) >= curFlowPo && !hasDecision) continue;
                    const key = `${day}:day`;
                    if (!groups.has(key)) groups.set(key, { day, phase: "day", items: [] });
                  }
                } catch {}
              }
              // Gun expiry: ensure a day group exists for any day where players were killed
              // for not firing their real gun.
              if (f && f.draft && f.draft.gunExpiryAppliedByDay) {
                try {
                  for (const dk of Object.keys(f.draft.gunExpiryAppliedByDay)) {
                    const day = parseInt(dk, 10);
                    if (!Number.isFinite(day) || day > curFlowDay) continue;
                    const er = f.draft.gunExpiryAppliedByDay[dk];
                    if (!er || !Array.isArray(er.killed) || !er.killed.length) continue;
                    if (day === curFlowDay && (phaseOrder["day"] ?? 99) >= curFlowPo) continue;
                    const key = `${day}:day`;
                    if (!groups.has(key)) groups.set(key, { day, phase: "day", items: [] });
                  }
                } catch {}
              }
              // Kane reveal: ensure a day group exists when someone was eliminated at start of day
              // (no day events yet for that day).
              if (f && f.draft && f.draft.kaneRevealAppliedByDay) {
                try {
                  const kane = f.draft.kaneRevealAppliedByDay;
                  for (const dk of Object.keys(kane)) {
                    const day = parseInt(dk, 10);
                    if (!Number.isFinite(day) || day > curFlowDay) continue;
                    const kaneRec = kane[dk];
                    if (!kaneRec || kaneRec.revealed !== true || kaneRec.idx == null) continue;
                    const key = `${day}:day`;
                    if (!groups.has(key)) groups.set(key, { day, phase: "day", items: [] });
                  }
                } catch {}
              }
              const keys = Array.from(groups.values())
                .sort((a, b) => (a.day - b.day) || ((phaseOrder[a.phase] ?? 99) - (phaseOrder[b.phase] ?? 99)));

              const describeNightActions = (payload, eventDay, nightStepOrder, onlyForStepId) => {
                const out = [];
                if (!payload || typeof payload !== "object") return out;
                const stepOrder = Array.isArray(nightStepOrder) && nightStepOrder.length ? nightStepOrder : null;
                const scenarioDesc = typeof getDrawScenarioForFlow === "function" ? getDrawScenarioForFlow() : "";
                const disabledIdx = (scenarioDesc === "pedarkhande" && payload.matadorDisable != null && payload.matadorDisable !== undefined && Number.isFinite(Number(payload.matadorDisable)))
                  ? parseInt(payload.matadorDisable, 10)
                  : (payload.magicianDisable != null && payload.magicianDisable !== undefined && Number.isFinite(Number(payload.magicianDisable)))
                    ? parseInt(payload.magicianDisable, 10)
                    : null;
                const mafiaShot = idxFrom(payload.mafiaShot);
                const doctorSave = idxFrom(payload.doctorSave);
                const lecterSaveForMafia = idxFrom(payload.lecterSave);
                const blocks = [];
                const add = (stepPattern, fn) => {
                  blocks.push({ pattern: stepPattern, fn });
                };
                add(/mafia|mafia_team/, () => {
                  // Matador disable (pedarkhande)
                  const matadorIdx = findIdxByRole(["matador"]);
                  const matadorDisable = idxFrom(payload.matadorDisable);
                  if (matadorDisable !== null && matadorIdx !== null) {
                    out.push((appLang === "fa")
                      ? `${nameOf(matadorIdx)} ${nameOf(matadorDisable)} Ø±Ø§ ØºÛŒØ±ÙØ¹Ø§Ù„ Ú©Ø±Ø¯.`
                      : `${nameOf(matadorIdx)} disabled ${nameOf(matadorDisable)}.`);
                  }
                  // Saul buy (pedarkhande)
                  const saulIdx = findIdxByRole(["saulGoodman"]);
                  const saulBuyTarget = idxFrom(payload.saulBuyTarget);
                  const godfatherAction = (payload.godfatherAction != null) ? String(payload.godfatherAction) : "shoot";
                  const godfatherIdx = findIdxByRole(["godfather", "mafiaBoss"]);
                  if (godfatherAction === "sixth_sense" && godfatherIdx !== null) {
                    const sixthTarget = idxFrom(payload.sixthSenseTarget);
                    const sixthRole = (payload.sixthSenseRole != null && String(payload.sixthSenseRole).trim()) ? String(payload.sixthSenseRole).trim() : null;
                    const roleName = sixthRole && roles[sixthRole] ? (appLang === "fa" ? roles[sixthRole].faName : (ROLE_I18N && ROLE_I18N[sixthRole] && ROLE_I18N[sixthRole].name) ? ROLE_I18N[sixthRole].name : roles[sixthRole].faName) : sixthRole;
                    if (sixthTarget !== null && roleName) {
                      out.push((appLang === "fa")
                        ? `${nameOf(godfatherIdx)} Ø­Ø¯Ø³ Ø²Ø¯ ${plainNameOf(sixthTarget)} Ù†Ù‚Ø´ ${roleName} Ø§Ø³Øª.`
                        : `${nameOf(godfatherIdx)} guessed ${plainNameOf(sixthTarget)} is ${roleName}.`);
                    } else {
                      out.push((appLang === "fa")
                        ? `${nameOf(godfatherIdx)} Ø§Ø² Ø­Ø³ Ø´Ø´Ù… Ø§Ø³ØªÙØ§Ø¯Ù‡ Ú©Ø±Ø¯ (Ø¨Ø¯ÙˆÙ† Ø´Ù„ÛŒÚ©).`
                        : `${nameOf(godfatherIdx)} used sixth sense (no shot).`);
                    }
                  }
                  if (godfatherAction === "saul_buy" && saulBuyTarget !== null && saulIdx !== null) {
                    try {
                      const saulRec = f && f.draft && f.draft.nightSaulBuyAppliedByDay && f.draft.nightSaulBuyAppliedByDay[String(eventDay)];
                      const succeeded = saulRec && saulRec.converted != null;
                      if (succeeded) {
                        out.push((appLang === "fa")
                          ? `${nameOf(saulIdx)} (Ø³Ø§ÙˆÙ„) ${nameOf(saulBuyTarget)} Ø±Ø§ Ø®Ø±ÛŒØ¯ Ùˆ Ø¨Ù‡ Ù…Ø§ÙÛŒØ§ ØªØ¨Ø¯ÛŒÙ„ Ú©Ø±Ø¯.`
                          : `${nameOf(saulIdx)} (Saul) bought ${nameOf(saulBuyTarget)} and converted to Mafia.`);
                      } else {
                        out.push((appLang === "fa")
                          ? `${nameOf(saulIdx)} (Ø³Ø§ÙˆÙ„) ${nameOf(saulBuyTarget)} Ø±Ø§ Ø¨Ø±Ø§ÛŒ Ø®Ø±ÛŒØ¯ Ø§Ù†ØªØ®Ø§Ø¨ Ú©Ø±Ø¯.`
                          : `${nameOf(saulIdx)} (Saul) attempted to buy ${nameOf(saulBuyTarget)}.`);
                      }
                    } catch {
                      out.push((appLang === "fa")
                        ? `${nameOf(saulIdx)} (Ø³Ø§ÙˆÙ„) ${nameOf(saulBuyTarget)} Ø±Ø§ Ø¨Ø±Ø§ÛŒ Ø®Ø±ÛŒØ¯ Ø§Ù†ØªØ®Ø§Ø¨ Ú©Ø±Ø¯.`
                        : `${nameOf(saulIdx)} (Saul) attempted to buy ${nameOf(saulBuyTarget)}.`);
                    }
                  }
                  // Kabo: Executioner guess role (correct â†’ target eliminated)
                  if (scenarioDesc === "kabo" && godfatherAction === "guess_role") {
                    try {
                      const execRec = f && f.draft && f.draft.nightExecutionerAppliedByDay && f.draft.nightExecutionerAppliedByDay[String(eventDay)];
                      const execTarget = idxFrom(payload.executionerTarget);
                      const execRole = (payload.executionerRoleGuess != null && String(payload.executionerRoleGuess).trim()) ? String(payload.executionerRoleGuess).trim() : null;
                      const roleName = execRole && roles[execRole] ? (appLang === "fa" ? roles[execRole].faName : (ROLE_I18N && ROLE_I18N[execRole] && ROLE_I18N[execRole].name) ? ROLE_I18N[execRole].name : roles[execRole].faName) : execRole;
                      if (execRec && execRec.killed != null && execTarget !== null && roleName) {
                        out.push((appLang === "fa")
                          ? `Ø¬Ù„Ø§Ø¯ Ø­Ø¯Ø³ Ø²Ø¯ ${plainNameOf(execTarget)} Ù†Ù‚Ø´ ${roleName} Ø§Ø³Øª â€” Ø¯Ø±Ø³ØªØŒ ${nameOf(execTarget)} Ø§Ø² Ø¨Ø§Ø²ÛŒ Ø®Ø§Ø±Ø¬ Ø´Ø¯.`
                          : `Executioner guessed ${plainNameOf(execTarget)} is ${roleName} â€” correct, ${nameOf(execTarget)} eliminated.`);
                      } else if (execTarget !== null && roleName) {
                        out.push((appLang === "fa")
                          ? `Ø¬Ù„Ø§Ø¯ Ø­Ø¯Ø³ Ø²Ø¯ ${plainNameOf(execTarget)} Ù†Ù‚Ø´ ${roleName} Ø§Ø³Øª â€” ØºÙ„Ø·.`
                          : `Executioner guessed ${plainNameOf(execTarget)} is ${roleName} â€” wrong.`);
                      }
                    } catch {}
                  }
                  // Kabo: Yakooza conversion
                  if (scenarioDesc === "kabo" && godfatherAction === "yakooza") {
                    try {
                      const yakRec = f && f.draft && f.draft.nightKaboYakoozaAppliedByDay && f.draft.nightKaboYakoozaAppliedByDay[String(eventDay)];
                      const yakTarget = idxFrom(payload.kaboYakoozaTarget);
                      if (yakRec && yakRec.converted != null && yakTarget !== null) {
                        out.push((appLang === "fa")
                          ? `ÛŒØ§Ú©ÙˆØ²Ø§ ${nameOf(yakTarget)} Ø±Ø§ Ø¨Ù‡ Ù…Ø§ÙÛŒØ§ ØªØ¨Ø¯ÛŒÙ„ Ú©Ø±Ø¯.`
                          : `Yakooza converted ${nameOf(yakTarget)} to Mafia.`);
                      } else if (yakTarget !== null) {
                        out.push((appLang === "fa")
                          ? `ÛŒØ§Ú©ÙˆØ²Ø§ ${nameOf(yakTarget)} Ø±Ø§ Ø¨Ø±Ø§ÛŒ Ø®Ø±ÛŒØ¯ Ø§Ù†ØªØ®Ø§Ø¨ Ú©Ø±Ø¯.`
                          : `Yakooza attempted to buy ${nameOf(yakTarget)}.`);
                      }
                    } catch {}
                  }
                  // Kabo: Witch bewitched target
                  if (scenarioDesc === "kabo") {
                    const witchTarget = idxFrom(payload.witchTarget);
                    if (witchTarget !== null) {
                      out.push((appLang === "fa")
                        ? `Ø¬Ø§Ø¯ÙˆÚ¯Ø± ${nameOf(witchTarget)} Ø±Ø§ Ù…Ø³Ø­ÙˆØ± Ú©Ø±Ø¯.`
                        : `Witch bewitched ${nameOf(witchTarget)}.`);
                    }
                  }
                  if (mafiaShot !== null) {
                    const targetRole = (draw.players[mafiaShot] && draw.players[mafiaShot].roleId) ? draw.players[mafiaShot].roleId : "citizen";
                    const alwaysImmuneToMafiaShot = (targetRole === "zodiac" || targetRole === "invulnerable" || targetRole === "armored" || targetRole === "heir");
                    const savedByDoctor = (doctorSave !== null && doctorSave === mafiaShot);
                    const savedByLecter = (lecterSaveForMafia !== null && lecterSaveForMafia === mafiaShot);
                    const mafLabel = appLang === "fa" ? "Ù…Ø§ÙÛŒØ§" : "Mafia";
                    if (savedByDoctor || savedByLecter) {
                      const saverLabel = savedByLecter && !savedByDoctor ? (appLang === "fa" ? "Ø¯Ú©ØªØ± Ù„Ú©ØªØ±" : "Dr. Lecter") : (appLang === "fa" ? "Ù¾Ø²Ø´Ú©" : "Doctor");
                      out.push((appLang === "fa")
                        ? `${mafLabel} Ø¨Ù‡ ${nameOf(mafiaShot)} Ø´Ù„ÛŒÚ© Ú©Ø±Ø¯ØŒ Ø§Ù…Ø§ ${saverLabel} Ù†Ø¬Ø§ØªØ´ Ø¯Ø§Ø¯.`
                        : `${mafLabel} shot ${nameOf(mafiaShot)}, but ${saverLabel} saved them.`);
                    } else if (alwaysImmuneToMafiaShot) {
                      out.push((appLang === "fa")
                        ? `${mafLabel} Ø¨Ù‡ ${nameOf(mafiaShot)} Ø´Ù„ÛŒÚ© Ú©Ø±Ø¯ (Ø¨Ø¯ÙˆÙ† Ø§Ø«Ø±).`
                        : `${mafLabel} shot ${nameOf(mafiaShot)} (no effect).`);
                    } else {
                      out.push((appLang === "fa")
                        ? `${mafLabel} Ø¨Ù‡ ${nameOf(mafiaShot)} Ø´Ù„ÛŒÚ© Ú©Ø±Ø¯.`
                        : `${mafLabel} shot ${nameOf(mafiaShot)}.`);
                    }
                  }
                  try {
                    const mafRec = f && f.draft && f.draft.nightMafiaAppliedByDay && f.draft.nightMafiaAppliedByDay[String(eventDay)];
                    const chainKilledIdx = (mafRec && mafRec.chainKilled != null && Number.isFinite(parseInt(mafRec.chainKilled, 10))) ? parseInt(mafRec.chainKilled, 10) : null;
                    if (chainKilledIdx !== null) {
                      out.push((appLang === "fa")
                        ? `${nameOf(chainKilledIdx)} (Ù„ÛŒÙ†Ú©â€ŒØ´Ø¯Ù‡ Ø¨Ù‡ Ù…Ø­Ù‚Ù‚) Ù†ÛŒØ² Ø§Ø² Ø¨Ø§Ø²ÛŒ Ø®Ø§Ø±Ø¬ Ø´Ø¯.`
                        : `${nameOf(chainKilledIdx)} (linked to Researcher) also eliminated.`);
                    }
                  } catch {}
                });
                add(/doctor|watson/, () => {
                  const doctorIdx = findIdxByRole(["doctor", "watson"]);
                  if (doctorIdx !== null && doctorIdx === disabledIdx) return;
                  if (doctorSave !== null && (mafiaShot === null || doctorSave !== mafiaShot) && doctorIdx !== null) {
                    out.push((appLang === "fa")
                      ? `${nameOf(doctorIdx)} ${nameOf(doctorSave)} Ø±Ø§ Ù†Ø¬Ø§Øª Ø¯Ø§Ø¯.`
                      : `${nameOf(doctorIdx)} saved ${nameOf(doctorSave)}.`);
                  }
                });
                add(/ocean/, () => {
                  const oceanIdx = findIdxByRole(["ocean"]);
                  if (oceanIdx !== null && oceanIdx === disabledIdx) return;
                  const oceanWake = idxArrFrom(payload.oceanWake);
                  if (oceanWake.length && oceanIdx !== null) {
                    out.push((appLang === "fa")
                      ? `${nameOf(oceanIdx)} Ø¨ÛŒØ¯Ø§Ø± Ú©Ø±Ø¯: ${listNames(oceanWake)}.`
                      : `${nameOf(oceanIdx)} woke: ${listNames(oceanWake)}.`);
                    try {
                      const isBad = oceanWake.some((x) => {
                        const i = idxFrom(x);
                        if (i === null || !draw || !draw.players || !draw.players[i]) return false;
                        const rid = (draw.players[i] && draw.players[i].roleId) ? draw.players[i].roleId : "citizen";
                        const teamFa = (roles[rid] && roles[rid].teamFa) ? roles[rid].teamFa : "Ø´Ù‡Ø±";
                        return teamFa === "Ù…Ø§ÙÛŒØ§" || rid === "zodiac";
                      });
                      if (isBad) {
                        out.push((appLang === "fa")
                          ? "Ø§ÙˆØ´Ù† Ø¨Ù‡ Ù…Ø§ÙÛŒØ§/Ø²ÙˆØ¯ÛŒØ§Ú© Ø¨Ø±Ø®ÙˆØ±Ø¯ Ú©Ø±Ø¯ Ùˆ Ø§Ø² Ø¨Ø§Ø²ÛŒ Ø®Ø§Ø±Ø¬ Ø´Ø¯."
                          : "Ocean woke Mafia/Zodiac and got eliminated.");
                      }
                    } catch {}
                  }
                });
                add(/professional|leon/, () => {
                  const proIdx = findIdxByRole(["professional", "leon"]);
                  const proShot = idxFrom(payload.professionalShot);
                  if (proIdx !== null && proIdx === disabledIdx) return;
                  if (proShot !== null && proIdx !== null) {
                    try {
                      const proRec = f && f.draft && f.draft.nightProAppliedByDay && f.draft.nightProAppliedByDay[String(eventDay)];
                      const vestAbsorbed = proRec && proRec.result === "vest_absorbed";
                      const tr = (draw && draw.players && draw.players[proShot] && draw.players[proShot].roleId) ? draw.players[proShot].roleId : "citizen";
                      const teamFa = (roles[tr] && roles[tr].teamFa) ? roles[tr].teamFa : "Ø´Ù‡Ø±";
                      if (vestAbsorbed) {
                        out.push((appLang === "fa")
                          ? `${nameOf(proIdx)} Ø¨Ù‡ ${nameOf(proShot)} Ø´Ù„ÛŒÚ© Ú©Ø±Ø¯ (Ø¬Ù„ÛŒÙ‚Ù‡ Ù¾Ø¯Ø±Ø®ÙˆØ§Ù†Ø¯Ù‡ Ø¬Ø°Ø¨ Ú©Ø±Ø¯).`
                          : `${nameOf(proIdx)} shot ${nameOf(proShot)} (Godfather vest absorbed).`);
                      } else if (tr === "zodiac") {
                        out.push((appLang === "fa")
                          ? `${nameOf(proIdx)} Ø¨Ù‡ ${nameOf(proShot)} Ø´Ù„ÛŒÚ© Ú©Ø±Ø¯ (Ø¨ÛŒâ€ŒØ§Ø«Ø± Ø±ÙˆÛŒ Ø²ÙˆØ¯ÛŒØ§Ú©).`
                          : `${nameOf(proIdx)} shot ${nameOf(proShot)} (no effect on Zodiac).`);
                      } else if (teamFa === "Ù…Ø§ÙÛŒØ§") {
                        out.push((appLang === "fa")
                          ? `${nameOf(proIdx)} Ø¨Ù‡ ${nameOf(proShot)} Ø´Ù„ÛŒÚ© Ú©Ø±Ø¯ Ùˆ Ø§Ùˆ Ø§Ø² Ø¨Ø§Ø²ÛŒ Ø®Ø§Ø±Ø¬ Ø´Ø¯.`
                          : `${nameOf(proIdx)} shot ${nameOf(proShot)} and they were eliminated.`);
                      } else {
                        out.push((appLang === "fa")
                          ? `${nameOf(proIdx)} Ø¨Ù‡ Ø§Ø´ØªØ¨Ø§Ù‡ Ø¨Ù‡ ${nameOf(proShot)} Ø´Ù„ÛŒÚ© Ú©Ø±Ø¯ Ùˆ Ø®ÙˆØ¯Ø´ Ø§Ø² Ø¨Ø§Ø²ÛŒ Ø®Ø§Ø±Ø¬ Ø´Ø¯.`
                          : `${nameOf(proIdx)} shot ${nameOf(proShot)} by mistake and got eliminated.`);
                      }
                    } catch {
                      out.push((appLang === "fa")
                        ? `${nameOf(proIdx)} Ø¨Ù‡ ${nameOf(proShot)} Ø´Ù„ÛŒÚ© Ú©Ø±Ø¯.`
                        : `${nameOf(proIdx)} shot ${nameOf(proShot)}.`);
                    }
                  }
                });
                add(/zodiac/, () => {
                  const zodiacIdx = findIdxByRole(["zodiac"]);
                  if (zodiacIdx !== null && zodiacIdx === disabledIdx) return;
                  const zodiacShot = idxFrom(payload.zodiacShot);
                  if (zodiacShot !== null && zodiacIdx !== null) {
                    out.push((appLang === "fa")
                      ? `${nameOf(zodiacIdx)} Ø¨Ù‡ ${nameOf(zodiacShot)} Ø´Ù„ÛŒÚ© Ú©Ø±Ø¯.`
                      : `${nameOf(zodiacIdx)} shot ${nameOf(zodiacShot)}.`);
                  }
                });
                add(/magician/, () => {
                  const magicianIdx = findIdxByRole(["magician"]);
                  const magicianDisable = idxFrom(payload.magicianDisable);
                  if (magicianDisable !== null && magicianIdx !== null) {
                    out.push((appLang === "fa")
                      ? `${nameOf(magicianIdx)} ${nameOf(magicianDisable)} Ø±Ø§ ØºÛŒØ±ÙØ¹Ø§Ù„ Ú©Ø±Ø¯.`
                      : `${nameOf(magicianIdx)} disabled ${nameOf(magicianDisable)}.`);
                  }
                });
                add(/bomber/, () => {
                  const bomberIdx = findIdxByRole(["bomber"]);
                  if (bomberIdx !== null && bomberIdx === disabledIdx) return;
                  const bombTarget = idxFrom(payload.bombTarget);
                  if (bombTarget !== null && bomberIdx !== null) {
                    const code = (payload.bombCode != null && String(payload.bombCode).trim()) ? String(payload.bombCode).trim() : null;
                    out.push((appLang === "fa")
                      ? `${nameOf(bomberIdx)} Ø¨Ù…Ø¨ Ø¬Ù„ÙˆÛŒ ${nameOf(bombTarget)} Ú¯Ø°Ø§Ø´Øª${code ? ` (Ø±Ù…Ø²: ${code})` : ""}.`
                      : `${nameOf(bomberIdx)} placed bomb in front of ${nameOf(bombTarget)}${code ? ` (code: ${code})` : ""}.`);
                  }
                });
                if (stepOrder) {
                  const runSteps = onlyForStepId != null ? [String(onlyForStepId)] : stepOrder;
                  for (const stepId of runSteps) {
                    const sid = String(stepId || "");
                    for (const { pattern, fn } of blocks) {
                      if (pattern.test(sid)) { fn(); break; }
                    }
                  }
                } else {
                  for (const { fn } of blocks) { fn(); }
                }
                // Role outputs below run per-step when onlyForStepId is set; otherwise run once.
                // When step-by-step, only add output when the current step matches this role.
                const shouldAddRole = (stepPattern) => {
                  if (!onlyForStepId) return true;
                  return stepPattern.test(String(onlyForStepId || ""));
                };
                if (shouldAddRole(/kane/)) {
                  const kaneIdx = findIdxByRole(["citizenKane"]);
                  const kaneMark = idxFrom(payload.kaneMark);
                  if (kaneMark !== null && kaneIdx !== null) {
                    out.push((appLang === "fa")
                      ? `${nameOf(kaneIdx)} Ù†Ø´Ø§Ù† Ú©Ø±Ø¯: ${nameOf(kaneMark)}.`
                      : `${nameOf(kaneIdx)} marked: ${nameOf(kaneMark)}.`);
                  }
                }
                if (shouldAddRole(/constantine/)) {
                  const constantineIdx = findIdxByRole(["constantine"]);
                  const constantineRevive = idxFrom(payload.constantineRevive);
                  if (constantineRevive !== null && constantineIdx !== null) {
                    out.push((appLang === "fa")
                      ? `${nameOf(constantineIdx)} Ø¨Ø§Ø²Ú¯Ø±Ø¯Ø§Ù†Ø¯: ${nameOf(constantineRevive)}.`
                      : `${nameOf(constantineIdx)} revived: ${nameOf(constantineRevive)}.`);
                  }
                }
                if (shouldAddRole(/heir/)) {
                // After heir inherits, roleId changes â€” find them via inheritance record as fallback.
                const heirIdx = (() => {
                  const direct = findIdxByRole(["heir"]);
                  if (direct !== null) return direct;
                  try {
                    const d = f && f.draft;
                    if (!d || !d.heirInheritedByDay) return null;
                    for (const rec of Object.values(d.heirInheritedByDay)) {
                      if (rec && rec.prevRole === "heir" && Number.isFinite(Number(rec.heirIdx))) return rec.heirIdx;
                    }
                  } catch {}
                  return null;
                })();
                const heirPick = idxFrom(payload.heirPick);
                if (heirPick !== null && heirIdx !== null) {
                  out.push((appLang === "fa")
                    ? `${nameOf(heirIdx)} Ø§Ù†ØªØ®Ø§Ø¨ Ú©Ø±Ø¯: ${nameOf(heirPick)}.`
                    : `${nameOf(heirIdx)} picked: ${nameOf(heirPick)}.`);
                }
                // Heir inheritance: show when the picked player died this night and Heir inherited.
                try {
                  const heirRec = (f && f.draft && f.draft.heirInheritedByDay && f.draft.heirInheritedByDay[String(eventDay)]) ? f.draft.heirInheritedByDay[String(eventDay)] : null;
                  if (heirRec && heirRec.heirIdx !== null && heirRec.newRole !== null) {
                    const inheritedRoleName = (() => {
                      const r = roles[heirRec.newRole];
                      if (!r) return heirRec.newRole;
                      return (appLang === "fa" && r.faName) ? r.faName : (ROLE_I18N[heirRec.newRole] && ROLE_I18N[heirRec.newRole].name) ? ROLE_I18N[heirRec.newRole].name : heirRec.newRole;
                    })();
                    out.push((appLang === "fa")
                      ? `${nameOf(heirRec.heirIdx)} Ù†Ù‚Ø´ ${inheritedRoleName} Ø±Ø§ Ø¨Ù‡ Ø§Ø±Ø« Ø¨Ø±Ø¯.`
                      : `${nameOf(heirRec.heirIdx)} inherited the ${inheritedRoleName} role.`);
                  }
                } catch {}
                }
                if (shouldAddRole(/herbalist|attar/)) {
                const herbalistIdx = findIdxByRole(["herbalist"]);
                const herbalistPoison = idxFrom(payload.herbalistPoison);
                if (herbalistPoison !== null && herbalistIdx !== null) {
                  out.push((appLang === "fa")
                    ? `${nameOf(herbalistIdx)} Ø²Ù‡Ø± Ø¯Ø§Ø¯ Ø¨Ù‡: ${nameOf(herbalistPoison)}.`
                    : `${nameOf(herbalistIdx)} poisoned: ${nameOf(herbalistPoison)}.`);
                }
                const herbalistAntidote = idxFrom(payload.herbalistAntidote);
                if (herbalistAntidote !== null && herbalistIdx !== null) {
                  out.push((appLang === "fa")
                    ? `${nameOf(herbalistIdx)} Ù¾Ø§Ø¯Ø²Ù‡Ø± Ø¯Ø§Ø¯ Ø¨Ù‡: ${nameOf(herbalistAntidote)}.`
                    : `${nameOf(herbalistIdx)} antidote to: ${nameOf(herbalistAntidote)}.`);
                } else {
                  // Log withheld antidote when previous night had poison and Herbalist decided not to give.
                  try {
                    const prevNightKey = String(Math.max(0, (eventDay || 1) - 1));
                    const prevNa = (f && f.draft && f.draft.nightActionsByNight && f.draft.nightActionsByNight[prevNightKey]) ? f.draft.nightActionsByNight[prevNightKey] : null;
                    const prevPoisonRaw = prevNa && prevNa.herbalistPoison != null && Number.isFinite(parseInt(prevNa.herbalistPoison, 10)) ? parseInt(prevNa.herbalistPoison, 10) : null;
                    if (prevPoisonRaw !== null && herbalistIdx !== null && eventDay >= 2) {
                      out.push((appLang === "fa")
                        ? `${nameOf(herbalistIdx)} Ù¾Ø§Ø¯Ø²Ù‡Ø± Ù†Ø¯Ø§Ø¯ Ø¨Ù‡: ${nameOf(prevPoisonRaw)}.`
                        : `${nameOf(herbalistIdx)} withheld antidote from ${nameOf(prevPoisonRaw)}.`);
                    }
                  } catch {}
                }
                try {
                  const herbRec = (f && f.draft && f.draft.nightHerbalistAppliedByDay && f.draft.nightHerbalistAppliedByDay[String(eventDay)]) ? f.draft.nightHerbalistAppliedByDay[String(eventDay)] : null;
                  const poisonKilled = (herbRec && herbRec.killed != null && Number.isFinite(parseInt(herbRec.killed, 10))) ? parseInt(herbRec.killed, 10) : null;
                  if (poisonKilled !== null) {
                    out.push((appLang === "fa")
                      ? `${nameOf(poisonKilled)} Ø§Ø² Ø§Ø«Ø± Ø²Ù‡Ø± Ø§Ø² Ø¨Ø§Ø²ÛŒ Ø®Ø§Ø±Ø¬ Ø´Ø¯.`
                      : `${nameOf(poisonKilled)} eliminated from poison.`);
                  }
                } catch {}
                }
                if (shouldAddRole(/armorsmith|armor/)) {
                const armorsmithIdx = findIdxByRole(["armorsmith"]);
                const armor = idxFrom(payload.armorsmithArmor);
                if (armor !== null && armorsmithIdx !== null) {
                  out.push((appLang === "fa")
                    ? `${nameOf(armorsmithIdx)} Ø¨Ù‡ ${nameOf(armor)} Ø²Ø±Ù‡ Ø¯Ø§Ø¯.`
                    : `${nameOf(armorsmithIdx)} armored ${nameOf(armor)}.`);
                }
                }
                if (shouldAddRole(/nostradamus|nost/)) {
                const nostIdx = findIdxByRole(["nostradamus"]);
                const nost = idxArrFrom(payload.nostPick3);
                if (nost.length && nostIdx !== null) {
                  out.push((appLang === "fa")
                    ? `${nameOf(nostIdx)} Ø§Ù†ØªØ®Ø§Ø¨ Ú©Ø±Ø¯: ${listNames(nost)}.`
                    : `${nameOf(nostIdx)} picked: ${listNames(nost)}.`);
                }
                }
                if (shouldAddRole(/lecter|doctorLecter/)) {
                const lecterIdx = findIdxByRole(["doctorLecter"]);
                if (lecterIdx !== null && lecterIdx === disabledIdx) { /* skip */ } else {
                const lecterSave = idxFrom(payload.lecterSave);
                if (lecterSave !== null && lecterIdx !== null) {
                  out.push((appLang === "fa")
                    ? `${plainNameOf(lecterIdx)} (Ø¯Ú©ØªØ± Ù„Ú©ØªØ±) Ù†Ø¬Ø§Øª Ø¯Ø§Ø¯: ${nameOf(lecterSave)}.`
                    : `${plainNameOf(lecterIdx)} (Dr. Lecter) saved: ${nameOf(lecterSave)}.`);
                }
                }
                }
                if (shouldAddRole(/joker/)) {
                const jokerIdx = findIdxByRole(["jokerMafia"]);
                const jokerTarget = idxFrom(payload.jokerTarget);
                if (jokerTarget !== null && jokerIdx !== null) {
                  out.push((appLang === "fa")
                    ? `${plainNameOf(jokerIdx)} (Ø¬ÙˆÚ©Ø±) Ø§Ø³ØªØ¹Ù„Ø§Ù… Ø§Ø² ${nameOf(jokerTarget)} Ø±Ø§ Ø¨Ø±Ø¹Ú©Ø³ Ú©Ø±Ø¯.`
                    : `${plainNameOf(jokerIdx)} (Joker) flipped inquiry on ${nameOf(jokerTarget)}.`);
                }
                }
                if (shouldAddRole(/swindler/)) {
                const swindlerIdx = findIdxByRole(["swindler"]);
                const swindlerTarget = idxFrom(payload.swindlerTarget);
                if (swindlerTarget !== null && swindlerIdx !== null) {
                  out.push((appLang === "fa")
                    ? `${plainNameOf(swindlerIdx)} (Ø´ÛŒØ§Ø¯) Ø±ÙˆÛŒ ${nameOf(swindlerTarget)} Ø§Ø«Ø± Ú¯Ø°Ø§Ø´Øª.`
                    : `${plainNameOf(swindlerIdx)} (Swindler) targeted ${nameOf(swindlerTarget)}.`);
                }
                }
                if (shouldAddRole(/researcher/)) {
                const researcherIdx = findIdxByRole(["researcher"]);
                const researcherLink = idxFrom(payload.researcherLink);
                if (researcherLink !== null && researcherIdx !== null) {
                  out.push((appLang === "fa")
                    ? `${plainNameOf(researcherIdx)} (Ù…Ø­Ù‚Ù‚) Ø¨Ù‡ ${nameOf(researcherLink)} Ú¯Ø±Ù‡ Ø²Ø¯.`
                    : `${plainNameOf(researcherIdx)} (Researcher) linked to ${nameOf(researcherLink)}.`);
                }
                }
                if (shouldAddRole(/natasha/)) {
                const natashaIdx = findIdxByRole(["natasha"]);
                const natashaTarget = idxFrom(payload.natashaTarget);
                if (natashaTarget !== null && natashaIdx !== null) {
                  out.push((appLang === "fa")
                    ? `${plainNameOf(natashaIdx)} (Ù†Ø§ØªØ§Ø´Ø§) ${nameOf(natashaTarget)} Ø±Ø§ Ø³Ø§Ú©Øª Ú©Ø±Ø¯.`
                    : `${plainNameOf(natashaIdx)} (Natasha) silenced ${nameOf(natashaTarget)}.`);
                }
                }
                if (shouldAddRole(/sniper/)) {
                const sniperIdx = findIdxByRole(["sniper"]);
                if (sniperIdx !== null && sniperIdx === disabledIdx) { /* skip */ } else {
                const sniperShot = idxFrom(payload.sniperShot);
                if (sniperShot !== null && sniperIdx !== null) {
                  try {
                    const tr = (draw.players[sniperShot] && draw.players[sniperShot].roleId) ? draw.players[sniperShot].roleId : "citizen";
                    const teamFa = (roles[tr] && roles[tr].teamFa) ? roles[tr].teamFa : "Ø´Ù‡Ø±";
                    if (teamFa === "Ù…Ø§ÙÛŒØ§") {
                      out.push((appLang === "fa")
                        ? `${plainNameOf(sniperIdx)} (ØªÚ©â€ŒØªÛŒØ±Ø§Ù†Ø¯Ø§Ø²) Ø¨Ù‡ ${nameOf(sniperShot)} Ø´Ù„ÛŒÚ© Ú©Ø±Ø¯ (Ù…Ø§ÙÛŒØ§ â€” Ø®Ø§Ø±Ø¬ Ø´Ø¯).`
                        : `${plainNameOf(sniperIdx)} (Sniper) shot ${nameOf(sniperShot)} (Mafia â€” eliminated).`);
                    } else {
                      out.push((appLang === "fa")
                        ? `${plainNameOf(sniperIdx)} (ØªÚ©â€ŒØªÛŒØ±Ø§Ù†Ø¯Ø§Ø²) Ø¨Ù‡ ${nameOf(sniperShot)} Ø´Ù„ÛŒÚ© Ú©Ø±Ø¯ (Ø§Ø´ØªØ¨Ø§Ù‡ â€” ØªÚ©â€ŒØªÛŒØ±Ø§Ù†Ø¯Ø§Ø² Ø®Ø§Ø±Ø¬ Ø´Ø¯).`
                        : `${plainNameOf(sniperIdx)} (Sniper) shot ${nameOf(sniperShot)} (wrong â€” Sniper eliminated).`);
                    }
                  } catch {}
                }
                }
                }
                if (shouldAddRole(/negotiator/)) {
                const negotiatorIdx = findIdxByRole(["negotiator"]);
                const negotiatorTarget = idxFrom(payload.negotiatorTarget);
                if (negotiatorTarget !== null && negotiatorIdx !== null) {
                  try {
                    const negRec = f && f.draft && f.draft.nightNegotiatorAppliedByDay
                      && f.draft.nightNegotiatorAppliedByDay[String(eventDay)];
                    const negSucceeded = negRec ? negRec.succeeded : null;
                    if (negSucceeded === true) {
                      out.push((appLang === "fa")
                        ? `${plainNameOf(negotiatorIdx)} (Ù…Ø°Ø§Ú©Ø±Ù‡â€ŒÚ©Ù†Ù†Ø¯Ù‡) Ø¨Ø§ ${plainNameOf(negotiatorTarget)} Ù…Ø°Ø§Ú©Ø±Ù‡ Ú©Ø±Ø¯ â€” Ù…ÙˆÙÙ‚ (Ø¨Ù‡ Ù…Ø§ÙÛŒØ§ ØªØ¨Ø¯ÛŒÙ„ Ø´Ø¯).`
                        : `${plainNameOf(negotiatorIdx)} (Negotiator) negotiated with ${plainNameOf(negotiatorTarget)} â€” success (converted to Mafia).`);
                    } else if (negSucceeded === false) {
                      out.push((appLang === "fa")
                        ? `${plainNameOf(negotiatorIdx)} (Ù…Ø°Ø§Ú©Ø±Ù‡â€ŒÚ©Ù†Ù†Ø¯Ù‡) Ø¨Ø§ ${nameOf(negotiatorTarget)} Ù…Ø°Ø§Ú©Ø±Ù‡ Ú©Ø±Ø¯ â€” Ø´Ú©Ø³Øª Ø®ÙˆØ±Ø¯.`
                        : `${plainNameOf(negotiatorIdx)} (Negotiator) negotiated with ${nameOf(negotiatorTarget)} â€” failed.`);
                    } else {
                      out.push((appLang === "fa")
                        ? `${plainNameOf(negotiatorIdx)} (Ù…Ø°Ø§Ú©Ø±Ù‡â€ŒÚ©Ù†Ù†Ø¯Ù‡) Ù…Ø°Ø§Ú©Ø±Ù‡ Ø¨Ø§ ${nameOf(negotiatorTarget)} Ø±Ø§ Ø§Ù†ØªØ®Ø§Ø¨ Ú©Ø±Ø¯.`
                        : `${plainNameOf(negotiatorIdx)} (Negotiator) attempted to negotiate with ${nameOf(negotiatorTarget)}.`);
                    }
                  } catch {
                    out.push((appLang === "fa")
                      ? `${plainNameOf(negotiatorIdx)} (Ù…Ø°Ø§Ú©Ø±Ù‡â€ŒÚ©Ù†Ù†Ø¯Ù‡) Ù…Ø°Ø§Ú©Ø±Ù‡ Ø¨Ø§ ${nameOf(negotiatorTarget)} Ø±Ø§ Ø§Ù†ØªØ®Ø§Ø¨ Ú©Ø±Ø¯.`
                      : `${plainNameOf(negotiatorIdx)} (Negotiator) attempted to negotiate with ${nameOf(negotiatorTarget)}.`);
                  }
                }
                }
                if (shouldAddRole(/reporter/)) {
                const reporterIdx = findIdxByRole(["reporter"]);
                const reporterTarget = idxFrom(payload.reporterTarget);
                if (reporterTarget !== null && reporterIdx !== null) {
                  try {
                    const repRec = f && f.draft && f.draft.reporterResultByNight
                      && f.draft.reporterResultByNight[String(eventDay)];
                    if (repRec && repRec.wasNegotiated !== undefined) {
                      const thumb = repRec.wasNegotiated ? "ğŸ‘" : "ğŸ‘";
                      out.push((appLang === "fa")
                        ? `${plainNameOf(reporterIdx)} (Ø®Ø¨Ø±Ù†Ú¯Ø§Ø±) Ø§Ø³ØªØ¹Ù„Ø§Ù… Ø§Ø² ${nameOf(reporterTarget)}: ${thumb} ${repRec.wasNegotiated ? "Ù…Ø°Ø§Ú©Ø±Ù‡ Ø´Ø¯Ù‡" : "Ù…Ø°Ø§Ú©Ø±Ù‡ Ù†Ø´Ø¯Ù‡"}.`
                        : `${plainNameOf(reporterIdx)} (Reporter) inquiry on ${nameOf(reporterTarget)}: ${thumb} ${repRec.wasNegotiated ? "negotiated" : "not negotiated"}.`);
                    } else {
                      out.push((appLang === "fa")
                        ? `${plainNameOf(reporterIdx)} (Ø®Ø¨Ø±Ù†Ú¯Ø§Ø±) Ø§Ø³ØªØ¹Ù„Ø§Ù… Ø§Ø² ${nameOf(reporterTarget)}.`
                        : `${plainNameOf(reporterIdx)} (Reporter) inquiry about ${nameOf(reporterTarget)}.`);
                    }
                  } catch {
                    out.push((appLang === "fa")
                      ? `${plainNameOf(reporterIdx)} (Ø®Ø¨Ø±Ù†Ú¯Ø§Ø±) Ø§Ø³ØªØ¹Ù„Ø§Ù… Ø§Ø² ${nameOf(reporterTarget)}.`
                      : `${plainNameOf(reporterIdx)} (Reporter) inquiry about ${nameOf(reporterTarget)}.`);
                  }
                }
                }
                if (shouldAddRole(/kadkhoda/)) {
                const kadkhodaIdx = findIdxByRole(["kadkhoda"]);
                const kadkhodaTarget = idxFrom(payload.kadkhodaTarget);
                if (kadkhodaTarget !== null && kadkhodaIdx !== null) {
                  out.push((appLang === "fa")
                    ? `${plainNameOf(kadkhodaIdx)} (Ú©Ø¯Ø®Ø¯Ø§) ${nameOf(kadkhodaTarget)} Ø±Ø§ Ø¨ÛŒØ¯Ø§Ø± Ú©Ø±Ø¯.`
                    : `${plainNameOf(kadkhodaIdx)} (Village Chief) linked/woke ${nameOf(kadkhodaTarget)}.`);
                }
                }
                if (shouldAddRole(/hacker/)) {
                const hackerIdx = findIdxByRole(["hacker"]);
                const hackerBlock = idxFrom(payload.hackerBlock);
                if (hackerBlock !== null && hackerIdx !== null) {
                  out.push((appLang === "fa")
                    ? `${plainNameOf(hackerIdx)} (Ù‡Ú©Ø±) ØªÙˆØ§Ù†Ø§ÛŒÛŒ ${nameOf(hackerBlock)} Ø±Ø§ Ù…Ø³Ø¯ÙˆØ¯ Ú©Ø±Ø¯.`
                    : `${plainNameOf(hackerIdx)} (Hacker) blocked ${nameOf(hackerBlock)}'s ability.`);
                }
                }
                if (shouldAddRole(/guide/)) {
                const guideIdx = findIdxByRole(["guide"]);
                const guideTarget = idxFrom(payload.guideTarget);
                if (guideTarget !== null && guideIdx !== null) {
                  try {
                    const tr = (draw.players[guideTarget] && draw.players[guideTarget].roleId) ? draw.players[guideTarget].roleId : "citizen";
                    const isMafia = detectiveInquiryIsMafia(tr);
                    if (isMafia) {
                      out.push((appLang === "fa")
                        ? `${plainNameOf(guideIdx)} (Ø±Ø§Ù‡Ù†Ù…Ø§) ${nameOf(guideTarget)} Ø±Ø§ Ø§Ù†ØªØ®Ø§Ø¨ Ú©Ø±Ø¯ â€” Ù…Ø§ÙÛŒØ§ (Ø±Ø§Ù‡Ù†Ù…Ø§ Ù„Ùˆ Ø±ÙØª).`
                        : `${plainNameOf(guideIdx)} (Guide) targeted ${nameOf(guideTarget)} â€” Mafia (Guide exposed).`);
                    } else {
                      out.push((appLang === "fa")
                        ? `${plainNameOf(guideIdx)} (Ø±Ø§Ù‡Ù†Ù…Ø§) ${nameOf(guideTarget)} Ø±Ø§ Ø§Ù†ØªØ®Ø§Ø¨ Ú©Ø±Ø¯ â€” Ø´Ù‡Ø±ÙˆÙ†Ø¯.`
                        : `${plainNameOf(guideIdx)} (Guide) targeted ${nameOf(guideTarget)} â€” Citizen.`);
                    }
                  } catch {
                    out.push((appLang === "fa")
                      ? `${plainNameOf(guideIdx)} (Ø±Ø§Ù‡Ù†Ù…Ø§) ${nameOf(guideTarget)} Ø±Ø§ Ø§Ù†ØªØ®Ø§Ø¨ Ú©Ø±Ø¯.`
                      : `${plainNameOf(guideIdx)} (Guide) targeted ${nameOf(guideTarget)}.`);
                  }
                }
                const guideInquiryTarget = idxFrom(payload.guideInquiryTarget);
                const guideInquiryIsMafia = (payload.guideInquiryIsMafia === true || payload.guideInquiryIsMafia === false) ? payload.guideInquiryIsMafia : null;
                if (guideInquiryTarget !== null && guideInquiryIsMafia !== null && guideTarget !== null) {
                  out.push((appLang === "fa")
                    ? `${nameOf(guideTarget)} (Ù‡Ø¯Ø§ÛŒØªâ€ŒØ´Ø¯Ù‡) Ø§Ø² ${nameOf(guideInquiryTarget)} Ø§Ø³ØªØ¹Ù„Ø§Ù… Ú¯Ø±ÙØª â€” ${guideInquiryIsMafia ? "âœ“ Ù…Ø§ÙÛŒØ§" : "âœ— Ø´Ù‡Ø±ÙˆÙ†Ø¯"}.`
                    : `${nameOf(guideTarget)} (guided) inquired about ${nameOf(guideInquiryTarget)} â€” ${guideInquiryIsMafia ? "âœ“ Mafia" : "âœ— Citizen"}.`);
                }
                }
                if (shouldAddRole(/bodyguard/)) {
                const bodyguardIdx = findIdxByRole(["bodyguard"]);
                const bodyguardProtect = idxFrom(payload.bodyguardProtect);
                if (bodyguardProtect !== null && bodyguardIdx !== null) {
                  out.push((appLang === "fa")
                    ? `${plainNameOf(bodyguardIdx)} (Ù…Ø­Ø§ÙØ¸) Ø§Ø² ${nameOf(bodyguardProtect)} Ù…Ø­Ø§ÙØ¸Øª Ú©Ø±Ø¯.`
                    : `${plainNameOf(bodyguardIdx)} (Bodyguard) protected ${nameOf(bodyguardProtect)}.`);
                }
                }
                if (shouldAddRole(/minemaker|mine/)) {
                const minemakerIdx = findIdxByRole(["minemaker"]);
                const minemakerTarget = idxFrom(payload.minemakerTarget);
                if (minemakerTarget !== null && minemakerIdx !== null) {
                  out.push((appLang === "fa")
                    ? `${plainNameOf(minemakerIdx)} (Ù…ÛŒÙ†â€ŒÚ¯Ø°Ø§Ø±) Ø±ÙˆÛŒ ${nameOf(minemakerTarget)} Ù…ÛŒÙ† Ú¯Ø°Ø§Ø´Øª.`
                    : `${plainNameOf(minemakerIdx)} (Minemaker) planted a mine on ${nameOf(minemakerTarget)}.`);
                }
                }
                if (shouldAddRole(/lawyer/)) {
                const lawyerIdx = findIdxByRole(["lawyer"]);
                const lawyerTarget = idxFrom(payload.lawyerTarget);
                if (lawyerTarget !== null && lawyerIdx !== null) {
                  out.push((appLang === "fa")
                    ? `${plainNameOf(lawyerIdx)} (ÙˆÚ©ÛŒÙ„) ${nameOf(lawyerTarget)} Ø±Ø§ Ø¨Ø±Ø§ÛŒ ÙØ±Ø¯Ø§ Ù…ØµÙˆÙ† Ú©Ø±Ø¯.`
                    : `${plainNameOf(lawyerIdx)} (Lawyer) granted ${nameOf(lawyerTarget)} immunity for tomorrow.`);
                }
                }
                if (shouldAddRole(/nato/)) {
                const natoIdx = findIdxByRole(["nato"]);
                const natoTarget = idxFrom(payload.natoTarget);
                const natoRoleGuess = (payload.natoRoleGuess != null && String(payload.natoRoleGuess).trim()) ? String(payload.natoRoleGuess).trim() : null;
                if (natoTarget !== null && natoIdx !== null && natoRoleGuess) {
                  const natoGuessLabel = (appLang === "fa")
                    ? ((roles[natoRoleGuess] && roles[natoRoleGuess].faName) ? roles[natoRoleGuess].faName : natoRoleGuess)
                    : ((typeof ROLE_I18N !== "undefined" && ROLE_I18N[natoRoleGuess] && ROLE_I18N[natoRoleGuess].name) ? ROLE_I18N[natoRoleGuess].name : natoRoleGuess);
                  out.push((appLang === "fa")
                    ? `${plainNameOf(natoIdx)} (Ù†Ø§ØªÙˆ) Ù†Ù‚Ø´ ${nameOf(natoTarget)} Ø±Ø§ Â«${natoGuessLabel}Â» Ø­Ø¯Ø³ Ø²Ø¯.`
                    : `${plainNameOf(natoIdx)} (NATO) guessed ${nameOf(natoTarget)}'s role as "${natoGuessLabel}".`);
                }
                }
                if (shouldAddRole(/investigator|inspector/)) {
                const investigatorIdx = findIdxByRole(["investigator"]);
                const invT1 = idxFrom(payload.investigatorT1);
                const invT2 = idxFrom(payload.investigatorT2);
                if ((invT1 !== null || invT2 !== null) && investigatorIdx !== null) {
                  const t1Str = invT1 !== null ? nameOf(invT1) : "â€”";
                  const t2Str = invT2 !== null ? nameOf(invT2) : "â€”";
                  out.push((appLang === "fa")
                    ? `${plainNameOf(investigatorIdx)} (Ø¨Ø§Ø²Ù¾Ø±Ø³) Ø¯Ùˆ Ù†ÙØ± Ø±Ø§ Ø¨Ø±Ø§ÛŒ Ø¨Ø§Ø²Ù¾Ø±Ø³ÛŒ Ø§Ù†ØªØ®Ø§Ø¨ Ú©Ø±Ø¯: ${t1Str} Ùˆ ${t2Str}.`
                    : `${plainNameOf(investigatorIdx)} (Inspector) selected two for interrogation: ${t1Str} and ${t2Str}.`);
                }
                }
                if (shouldAddRole(/sodagari/)) {
                const sodagariSacrifice = idxFrom(payload.sodagariSacrifice);
                const sodagariTarget = idxFrom(payload.sodagariTarget);
                const mafiaBossIdx = findIdxByRole(["mafiaBoss"]);
                if ((sodagariSacrifice !== null || sodagariTarget !== null) && mafiaBossIdx !== null) {
                  try {
                    const sodRec = f && f.draft && f.draft.nightSodagariAppliedByDay
                      && f.draft.nightSodagariAppliedByDay[String(eventDay)];
                    const sodSucceeded = sodRec ? sodRec.succeeded : null;
                    const sacStr = sodagariSacrifice !== null ? nameOf(sodagariSacrifice) : "â€”";
                    const tgtStr = sodagariTarget !== null ? nameOf(sodagariTarget) : "â€”";
                    if (sodSucceeded === true) {
                      out.push((appLang === "fa")
                        ? `Ø³ÙˆØ¯Ø§Ú¯Ø±ÛŒ: ${sacStr} ÙØ¯Ø§ Ø´Ø¯ (Ø­Ø°Ù) + ${tgtStr} Ø¨Ù‡ Ù…Ø§ÙÛŒØ§ ØªØ¨Ø¯ÛŒÙ„ Ø´Ø¯.`
                        : `Trade: ${sacStr} sacrificed (eliminated) + ${tgtStr} converted to Mafia.`);
                    } else if (sodSucceeded === false) {
                      out.push((appLang === "fa")
                        ? `Ø³ÙˆØ¯Ø§Ú¯Ø±ÛŒ: ${sacStr} ÙØ¯Ø§ Ø´Ø¯ + ØªØ¨Ø¯ÛŒÙ„ ${tgtStr} Ø´Ú©Ø³Øª Ø®ÙˆØ±Ø¯ (Ù†Ù‚Ø´ ÙˆØ§Ø¬Ø¯ Ø´Ø±Ø§ÛŒØ· Ù†ÛŒØ³Øª).`
                        : `Trade: ${sacStr} sacrificed + converting ${tgtStr} failed (ineligible role).`);
                    } else {
                      out.push((appLang === "fa")
                        ? `Ø³ÙˆØ¯Ø§Ú¯Ø±ÛŒ Ø§Ù†ØªØ®Ø§Ø¨ Ø´Ø¯: ÙØ¯Ø§ÛŒÛŒ=${sacStr}ØŒ Ù‡Ø¯Ù=${tgtStr}.`
                        : `Trade selected: sacrifice=${sacStr}, target=${tgtStr}.`);
                    }
                  } catch {
                    out.push((appLang === "fa")
                      ? `Ø³ÙˆØ¯Ø§Ú¯Ø±ÛŒ: ÙØ¯Ø§ÛŒÛŒ=${sodagariSacrifice !== null ? nameOf(sodagariSacrifice) : "â€”"}.`
                      : `Trade: sacrifice=${sodagariSacrifice !== null ? nameOf(sodagariSacrifice) : "â€”"}.`);
                  }
                }
                }
                if (shouldAddRole(/soldier/)) {
                // Soldier (namayande)
                const soldierIdx = findIdxByRole(["soldier"]);
                const soldierTarget = idxFrom(payload.soldierTarget);
                const soldierGunShot = idxFrom(payload.soldierGunShot);
                if (soldierTarget !== null && soldierIdx !== null) {
                  try {
                    const solRec = f && f.draft && f.draft.nightSoldierAppliedByDay
                      && f.draft.nightSoldierAppliedByDay[String(eventDay)];
                    const tRoleId = (draw.players[soldierTarget] && draw.players[soldierTarget].roleId) ? draw.players[soldierTarget].roleId : "citizen";
                    const tTeamFa = (roles[tRoleId] && roles[tRoleId].teamFa) ? roles[tRoleId].teamFa : "Ø´Ù‡Ø±";
                    if (tTeamFa === "Ù…Ø§ÙÛŒØ§") {
                      out.push((appLang === "fa")
                        ? `${plainNameOf(soldierIdx)} (Ø³Ø±Ø¨Ø§Ø²) ØªÛŒØ± Ø¨Ù‡ ${nameOf(soldierTarget)} (Ù…Ø§ÙÛŒØ§) Ø¯Ø§Ø¯ â€” Ø³Ø±Ø¨Ø§Ø² Ø®Ø§Ø±Ø¬ Ø´Ø¯.`
                        : `${plainNameOf(soldierIdx)} (Soldier) gave bullet to ${nameOf(soldierTarget)} (Mafia) â€” Soldier eliminated.`);
                    } else {
                      out.push((appLang === "fa")
                        ? `${plainNameOf(soldierIdx)} (Ø³Ø±Ø¨Ø§Ø²) ØªÛŒØ± Ø¨Ù‡ ${nameOf(soldierTarget)} (Ø´Ù‡Ø±ÙˆÙ†Ø¯) Ø¯Ø§Ø¯.`
                        : `${plainNameOf(soldierIdx)} (Soldier) gave bullet to ${nameOf(soldierTarget)} (Citizen).`);
                      if (soldierGunShot !== null) {
                        const gsRoleId = (draw.players[soldierGunShot] && draw.players[soldierGunShot].roleId) ? draw.players[soldierGunShot].roleId : "citizen";
                        const gsTeamFa = (roles[gsRoleId] && roles[gsRoleId].teamFa) ? roles[gsRoleId].teamFa : "Ø´Ù‡Ø±";
                        if (gsRoleId === "don") {
                          out.push((appLang === "fa")
                            ? `${nameOf(soldierTarget)} Ø¨Ù‡ ${nameOf(soldierGunShot)} (Ø¯ÙˆÙ† Ù…Ø§ÙÛŒØ§) Ø´Ù„ÛŒÚ© Ú©Ø±Ø¯ â€” Ø¨Ø¯ÙˆÙ† Ø§Ø«Ø±.`
                            : `${nameOf(soldierTarget)} shot ${nameOf(soldierGunShot)} (Don Mafia) â€” no effect.`);
                        } else if (gsTeamFa === "Ù…Ø§ÙÛŒØ§") {
                          out.push((appLang === "fa")
                            ? `${nameOf(soldierTarget)} Ø¨Ù‡ ${nameOf(soldierGunShot)} (Ù…Ø§ÙÛŒØ§) Ø´Ù„ÛŒÚ© Ú©Ø±Ø¯ â€” Ù…Ø§ÙÛŒØ§ Ø®Ø§Ø±Ø¬ Ø´Ø¯.`
                            : `${nameOf(soldierTarget)} shot ${nameOf(soldierGunShot)} (Mafia) â€” Mafia eliminated.`);
                        } else {
                          out.push((appLang === "fa")
                            ? `${nameOf(soldierTarget)} Ø¨Ù‡ ${nameOf(soldierGunShot)} (Ø´Ù‡Ø±ÙˆÙ†Ø¯) Ø´Ù„ÛŒÚ© Ú©Ø±Ø¯ â€” Ø®ÙˆØ¯Ø´ Ø®Ø§Ø±Ø¬ Ø´Ø¯.`
                            : `${nameOf(soldierTarget)} shot ${nameOf(soldierGunShot)} (Citizen) â€” recipient eliminated.`);
                        }
                      }
                    }
                  } catch {}
                }
                }
                if (shouldAddRole(/mafia|mafia_team/)) {
                // Neutralized shot flag (namayande)
                if (payload.neutralizedShot === true) {
                  out.push((appLang === "fa")
                    ? "Ù…Ø§ÙÛŒØ§ Ø§Ø² Ø´Ø§Øª Ø®Ù†Ø«ÛŒ Ø§Ø³ØªÙØ§Ø¯Ù‡ Ú©Ø±Ø¯ (Ù…ÛŒÙ† ÙØ¹Ø§Ù„ Ù†Ù…ÛŒâ€ŒØ´ÙˆØ¯ Ø¨Ø±Ø§ÛŒ Ù…Ø§ÙÛŒØ§)."
                    : "Mafia used neutralized shot (mine trap bypassed for mafia).");
                }
                // Don Mafia betrayal vote (namayande)
                try {
                  const betrayalRepSlot = (payload.betrayalRep != null && Number.isFinite(parseInt(payload.betrayalRep, 10))) ? parseInt(payload.betrayalRep, 10) : null;
                  const betrayalDir = payload.betrayalDir ? String(payload.betrayalDir) : null;
                  if (betrayalRepSlot !== null && betrayalDir !== null) {
                    const repPlayerIdx = (f && f.draft && Array.isArray(f.draft.representatives) && f.draft.representatives[betrayalRepSlot - 1] != null) ? f.draft.representatives[betrayalRepSlot - 1] : null;
                    const donIdx = findIdxByRole(["mafiaBoss", "don"]);
                    const repStr = repPlayerIdx !== null ? nameOf(repPlayerIdx) : (appLang === "fa" ? `Ù†Ù…Ø§ÛŒÙ†Ø¯Ù‡ ${(typeof toFarsiNum === "function" ? toFarsiNum(betrayalRepSlot) : betrayalRepSlot)}` : `Rep ${betrayalRepSlot}`);
                    const dirStr = betrayalDir === "more" ? (appLang === "fa" ? "Ø±Ø£ÛŒ Ø¨ÛŒØ´ØªØ±" : "more votes") : (appLang === "fa" ? "Ø±Ø£ÛŒ Ú©Ù…ØªØ±" : "fewer votes");
                    const donStr = donIdx !== null ? `${plainNameOf(donIdx)} (${appLang === "fa" ? "Ø¯ÙˆÙ† Ù…Ø§ÙÛŒØ§" : "Don Mafia"})` : (appLang === "fa" ? "Ø¯ÙˆÙ† Ù…Ø§ÙÛŒØ§" : "Don Mafia");
                    out.push((appLang === "fa")
                      ? `${donStr} Ø±Ø£ÛŒ Ø®ÛŒØ§Ù†Øª Ø±ÙˆÛŒ ${repStr} Ú¯Ø°Ø§Ø´Øª (${dirStr}).`
                      : `${donStr} placed betrayal vote on ${repStr} (${dirStr}).`);
                  }
                } catch {}
                }
                return out;
              };

              const describe = (e) => {
                const k = String(e.kind || "");
                const d0 = e.data || null;
                const out = [];
                if (k === "day_elim_out") {
                  const outIdx = d0 && d0.out !== null && d0.out !== undefined && Number.isFinite(Number(d0.out)) ? parseInt(d0.out, 10) : null;
                  if (outIdx !== null && !(d0 && d0.preview)) {
                    const dayKey = String(e.day || 1);
                    const faceOffRec = f && f.draft && f.draft.endCardActionAppliedByDay && f.draft.endCardActionAppliedByDay[dayKey];
                    const elimRole = (faceOffRec && faceOffRec.cardId === "face_change" && faceOffRec.prevState && faceOffRec.prevState.outRole)
                      ? faceOffRec.prevState.outRole : null;
                    const elimName = elimRole ? nameOfWithRole(outIdx, elimRole) : nameOf(outIdx);
                    if (d0 && d0.kaboShot) {
                      out.push((appLang === "fa")
                        ? `${elimName} Ø¨Ø§ Ú¯Ù„ÙˆÙ„Ù‡ ÙˆØ§Ù‚Ø¹ÛŒ Ú©Ø§Ù¾Ùˆ Ø§Ø² Ø¨Ø§Ø²ÛŒ Ø®Ø§Ø±Ø¬ Ø´Ø¯.`
                        : `${elimName} was eliminated by the Capo's real bullet.`);
                    } else {
                      out.push((appLang === "fa")
                        ? `${elimName} Ø¨Ø§ Ø±Ø£ÛŒ Ø§Ø² Ø¨Ø§Ø²ÛŒ Ø®Ø§Ø±Ø¬ Ø´Ø¯${d0 && d0.draw ? " (Ù‚Ø±Ø¹Ù‡)" : ""}.`
                        : `${elimName} was eliminated by voting${d0 && d0.draw ? " (draw)" : ""}.`);
                    }
                    try {
                      const rec = f && f.draft && f.draft.dayElimAppliedByDay && f.draft.dayElimAppliedByDay[String(e.day)];
                      if (rec && Number.isFinite(Number(rec.chainOut))) {
                        const chainIdx = parseInt(rec.chainOut, 10);
                        if (draw.players[chainIdx]) {
                          out.push((appLang === "fa")
                            ? `${nameOf(chainIdx)} (Ú©Ù‡ Ù…Ø­Ù‚Ù‚ Ø¨Ø§ Ø§Ùˆ Ù„ÛŒÙ†Ú© Ø¯Ø§Ø´Øª) Ù†ÛŒØ² Ø§Ø² Ø¨Ø§Ø²ÛŒ Ø®Ø§Ø±Ø¬ Ø´Ø¯.`
                            : `${nameOf(chainIdx)} (linked to Researcher) was also eliminated.`);
                        }
                      }
                    } catch {}
                  }
                } else if (k === "gun_shot") {
                  const sh = d0 && Number.isFinite(Number(d0.shooter)) ? parseInt(d0.shooter, 10) : null;
                  const tg = d0 && Number.isFinite(Number(d0.target)) ? parseInt(d0.target, 10) : null;
                  const tp = d0 && d0.type ? String(d0.type) : "real";
                  if (sh !== null && tg !== null) {
                    if (tp === "fake") {
                      out.push((appLang === "fa")
                        ? `${nameOf(sh)} Ø¨Ø§ ØªÙÙ†Ú¯Ù Ù…Ø´Ù‚ÛŒ Ø¨Ù‡ ${nameOf(tg)} Ø´Ù„ÛŒÚ© Ú©Ø±Ø¯ (Ø¨Ø¯ÙˆÙ† Ø§Ø«Ø±).`
                        : `${nameOf(sh)} used a fake gun and shot ${nameOf(tg)} (no effect).`);
                    } else {
                      out.push((appLang === "fa")
                        ? `${nameOf(sh)} Ø¨Ø§ ØªÙÙ†Ú¯Ù ÙˆØ§Ù‚Ø¹ÛŒ Ø¨Ù‡ ${nameOf(tg)} Ø´Ù„ÛŒÚ© Ú©Ø±Ø¯.`
                        : `${nameOf(sh)} used a real gun and shot ${nameOf(tg)}.`);
                      // Researcher chain kill via gun shot
                      try {
                        const gsRec = f && f.draft && f.draft.gunShotAppliedByDay && f.draft.gunShotAppliedByDay[String(e.day)];
                        const gsShot = gsRec && Array.isArray(gsRec.shots) ? gsRec.shots.find((s) => parseInt(s.shooter, 10) === sh && parseInt(s.target, 10) === tg) : null;
                        if (gsShot && Number.isFinite(Number(gsShot.chainKilled))) {
                          const chainIdx = parseInt(gsShot.chainKilled, 10);
                          if (draw.players[chainIdx]) {
                            out.push((appLang === "fa")
                              ? `${nameOf(chainIdx)} (Ú©Ù‡ Ù…Ø­Ù‚Ù‚ Ø¨Ø§ Ø§Ùˆ Ù„ÛŒÙ†Ú© Ø¯Ø§Ø´Øª) Ù†ÛŒØ² Ø§Ø² Ø¨Ø§Ø²ÛŒ Ø®Ø§Ø±Ø¬ Ø´Ø¯.`
                              : `${nameOf(chainIdx)} (linked to Researcher) was also eliminated.`);
                          }
                        }
                      } catch {}
                    }
                  }
                } else if (k === "gun_give") {
                  const from = d0 && Number.isFinite(Number(d0.from)) ? parseInt(d0.from, 10) : null;
                  const to = d0 && Number.isFinite(Number(d0.to)) ? parseInt(d0.to, 10) : null;
                  const tp = d0 && d0.type ? String(d0.type) : "real";
                  if (to !== null) {
                    const giverLabel = from !== null ? nameOf(from) : (appLang === "fa" ? "ØªÙÙ†Ú¯Ø¯Ø§Ø±" : "Gunslinger");
                    out.push((appLang === "fa")
                      ? `${giverLabel} ØªÙÙ†Ú¯ (${tp === "fake" ? "Ù…Ø´Ù‚ÛŒ" : "ÙˆØ§Ù‚Ø¹ÛŒ"}) Ø¨Ù‡ ${nameOf(to)} Ø¯Ø§Ø¯.`
                      : `${giverLabel} gave a ${tp === "fake" ? "fake" : "real"} gun to ${nameOf(to)}.`);
                  }
                } else if (k === "gun_remove") {
                  const to = d0 && Number.isFinite(Number(d0.to)) ? parseInt(d0.to, 10) : null;
                  if (to !== null) {
                    out.push((appLang === "fa")
                      ? `ØªÙÙ†Ú¯Ù ${nameOf(to)} Ø­Ø°Ù Ø´Ø¯.`
                      : `Removed gun from ${nameOf(to)}.`);
                  }
                } else if (k === "detective_query") {
                  const target = d0 ? idxFrom(d0.target) : null;
                  const isMafia = d0 && typeof d0.isMafia === "boolean" ? d0.isMafia : null;
                  const detIdx = findIdxByRole(["detective"]);
                  if (target !== null && isMafia !== null && detIdx !== null) {
                    const thumb = isMafia ? "ğŸ‘" : "ğŸ‘";
                    out.push((appLang === "fa")
                      ? `Ø§Ø³ØªØ¹Ù„Ø§Ù… ${nameOf(detIdx)} Ø§Ø² ${nameOf(target)}: ${thumb} ${isMafia ? "Ù…Ø§ÙÛŒØ§" : "Ø´Ù‡Ø±ÙˆÙ†Ø¯"}.`
                      : `${nameOf(detIdx)} inquiry on ${nameOf(target)}: ${thumb} ${isMafia ? "Mafia" : "Citizen"}.`);
                  }
                } else if (k === "night_actions") {
                  const nightSteps = (typeof getFlowConfig === "function" && scenario) ? (getFlowConfig(scenario).night || []) : [];
                  out.push(...describeNightActions(d0, e.day, nightSteps));
                } else if (k === "bomb_resolve") {
                  try {
                    if (!d0 || typeof d0 !== "object") return out;
                    const target = idxFrom(d0.target);
                    const killed = idxFrom(d0.killed);
                    const ok = (d0.ok === true);
                    const sac = (d0.guardSacrifice === true);
                    const guess = (d0.guess != null) ? String(d0.guess).trim() : "";
                    const code = (d0.code != null) ? String(d0.code).trim() : "";
                    if (target === null) return out;
                    if (sac) {
                      out.push((appLang === "fa")
                        ? `Ø¨Ù…Ø¨Ù Ø¬Ù„ÙˆÛŒ ${nameOf(target)} Ø¨Ø§ ÙØ¯Ø§Ú©Ø§Ø±ÛŒÙ Ù…Ø­Ø§ÙØ¸ Ø­Ù„ Ø´Ø¯ (Ø­Ø¯Ø³: ${guess || "â€”"} / Ú©Ø¯: ${code || "â€”"}).`
                        : `Bomb in front of ${nameOf(target)} was resolved by Guard sacrifice (guess: ${guess || "â€”"} / code: ${code || "â€”"}).`);
                      if (!ok && killed !== null) {
                        out.push((appLang === "fa")
                          ? `${nameOf(killed)} Ø¨Ù‡â€ŒØ®Ø§Ø·Ø± Ø­Ø¯Ø³Ù ØºÙ„Ø·Ù Ú©Ø¯Ù Ø¨Ù…Ø¨ Ú©Ø´ØªÙ‡ Ø´Ø¯.`
                          : `${nameOf(killed)} died due to wrong bomb code guess.`);
                      }
                    } else {
                      if (ok) {
                        out.push((appLang === "fa")
                          ? `${nameOf(target)} Ú©Ø¯Ù Ø¨Ù…Ø¨ Ø±Ø§ Ø¯Ø±Ø³Øª Ø­Ø¯Ø³ Ø²Ø¯ Ùˆ Ø¨Ù…Ø¨ Ø®Ù†Ø«ÛŒ Ø´Ø¯.`
                          : `${nameOf(target)} guessed the bomb code and it was neutralized.`);
                      } else {
                        out.push((appLang === "fa")
                          ? `${nameOf(target)} Ú©Ø¯Ù Ø¨Ù…Ø¨ Ø±Ø§ ØºÙ„Ø· Ø­Ø¯Ø³ Ø²Ø¯ Ùˆ Ú©Ø´ØªÙ‡ Ø´Ø¯.`
                          : `${nameOf(target)} guessed the bomb code wrong and died.`);
                      }
                    }
                  } catch {}
                } else if (k === "end_card_action") {
                  const outIdx = d0 && d0.out !== null && d0.out !== undefined && Number.isFinite(Number(d0.out)) ? parseInt(d0.out, 10) : null;
                  const cardId = d0 && d0.cardId ? String(d0.cardId) : "";
                  const targetIdx = (d0 && d0.target !== null && d0.target !== undefined && Number.isFinite(Number(d0.target))) ? parseInt(d0.target, 10) : null;
                  const targets = Array.isArray(d0 && d0.targets) ? d0.targets.map((x) => parseInt(x, 10)).filter((x) => Number.isFinite(x)) : [];
                  if (outIdx !== null) {
                    try {
                      const cfg = getScenarioConfig(scenario);
                      const endCards = cfg.eliminationCards || [];
                      const cardInfo = endCards.find((x) => x.id === cardId);
                      const cardLabel = cardInfo ? (appLang === "fa" ? cardInfo.fa : cardInfo.en) : cardId;
                      if (cardId === "face_change" && targetIdx !== null) {
                        const dayKey = String(e.day || 1);
                        const faceOffRec = f && f.draft && f.draft.endCardActionAppliedByDay && f.draft.endCardActionAppliedByDay[dayKey];
                        const outRole = (faceOffRec && faceOffRec.prevState && faceOffRec.prevState.outRole) ? faceOffRec.prevState.outRole : null;
                        const tgtRole = (faceOffRec && faceOffRec.prevState && faceOffRec.prevState.tgtRole) ? faceOffRec.prevState.tgtRole : null;
                        const outName = outRole ? nameOfWithRole(outIdx, outRole) : nameOf(outIdx);
                        const tgtName = tgtRole ? nameOfWithRole(targetIdx, tgtRole) : nameOf(targetIdx);
                        out.push((appLang === "fa")
                          ? `${outName} (${cardLabel}) Ù†Ù‚Ø´ Ø®ÙˆØ¯ Ø±Ø§ Ø¨Ø§ ${tgtName} Ø¹ÙˆØ¶ Ú©Ø±Ø¯.`
                          : `${outName} (${cardLabel}) swapped role with ${tgtName}.`);
                      } else if (cardId === "handcuffs" && targetIdx !== null) {
                        out.push((appLang === "fa")
                          ? `${nameOf(outIdx)} (${cardLabel}) ${nameOf(targetIdx)} Ø±Ø§ Ø¯Ø³ØªØ¨Ù†Ø¯ Ø²Ø¯.`
                          : `${nameOf(outIdx)} (${cardLabel}) handcuffed ${nameOf(targetIdx)}.`);
                      } else if (cardId === "beautiful_mind" && targetIdx !== null) {
                        out.push((appLang === "fa")
                          ? `${nameOf(outIdx)} (${cardLabel}) Ù†ÙˆØ³ØªØ±Ø§Ø¯Ø§Ù…ÙˆØ³ Ø±Ø§ Ø¯Ø±Ø³Øª Ø­Ø¯Ø³ Ø²Ø¯Ø› Ø¨Ø§Ø²Ú¯Ø´Øª Ø¨Ù‡ Ø¨Ø§Ø²ÛŒ Ø¨Ø§ Ù†Ù‚Ø´ Ø®ÙˆØ¯ØŒ ${nameOf(targetIdx)} Ø®Ø§Ø±Ø¬ Ø´Ø¯.`
                          : `${nameOf(outIdx)} (${cardLabel}) guessed Nostradamus correctly; returned to game with own role, ${nameOf(targetIdx)} eliminated.`);
                      } else if (cardId === "silence_lambs" && targets.length) {
                        const names = targets.map(nameOf).join(appLang === "fa" ? "ØŒ " : ", ");
                        out.push((appLang === "fa")
                          ? `${nameOf(outIdx)} (${cardLabel}) ${names} Ø±Ø§ Ø³Ø§Ú©Øª Ú©Ø±Ø¯.`
                          : `${nameOf(outIdx)} (${cardLabel}) silenced ${names}.`);
                      } else if (cardLabel) {
                        out.push((appLang === "fa")
                          ? `${nameOf(outIdx)} â€” ${cardLabel}.`
                          : `${nameOf(outIdx)} â€” ${cardLabel}.`);
                      }
                    } catch {}
                  }
                }
                return out;
              };

              const blocks = keys.map((g) => {
                const stepOrder = (() => {
                  try {
                    if (typeof getFlowSteps === "function" && f) {
                      const steps = getFlowSteps({ ...f, phase: g.phase, day: g.day });
                      return Array.isArray(steps) ? steps.map((s) => (s && s.id) ? s.id : null).filter(Boolean) : [];
                    }
                    if (g.phase === "day" && f && f.draft && f.draft.dayStepsByDay && Array.isArray(f.draft.dayStepsByDay[String(g.day)])) {
                      return f.draft.dayStepsByDay[String(g.day)];
                    }
                    if (g.phase === "night" && typeof getFlowConfig === "function") {
                      const cfg = getFlowConfig(scenario);
                      return Array.isArray(cfg && cfg.night) ? cfg.night : [];
                    }
                  } catch {}
                  return [];
                })();
                const orderOf = (e) => {
                  const sid = e.stepId;
                  if (sid && stepOrder.length) {
                    const i = stepOrder.indexOf(sid);
                    if (i >= 0) return i;
                  }
                  const si = (e.stepIndex != null && e.stepIndex >= 0) ? e.stepIndex : 0;
                  return 999000 + si;
                };
                const items = (g.items || []).slice().sort((a, b) => {
                  const oa = orderOf(a);
                  const ob = orderOf(b);
                  if (oa !== ob) return oa - ob;
                  return (Number(a.at || 0) - Number(b.at || 0));
                });
                const lines = [];
                if (g.phase === "night" && stepOrder.length) {
                  const nightEv = items.find((e) => e && e.kind === "night_actions");
                  const nightPayload = nightEv && nightEv.data ? nightEv.data : null;
                  const nightDay = nightEv ? nightEv.day : g.day;
                  const nightSteps = (typeof getFlowConfig === "function" && scenario) ? (getFlowConfig(scenario).night || []) : stepOrder;
                  for (const stepId of stepOrder) {
                    const sid = String(stepId || "");
                    for (const e of items) {
                      if (e.kind === "night_actions") continue;
                      if (e.stepId === sid) {
                        const xs = describe(e);
                        for (const s of xs) if (s) lines.push(s);
                      }
                    }
                    if (nightPayload) {
                      const stepLines = describeNightActions(nightPayload, nightDay, nightSteps, sid);
                      for (const s of stepLines) if (s) lines.push(s);
                    }
                  }
                } else if (g.phase === "day" && stepOrder.length) {
                  for (const stepId of stepOrder) {
                    const sid = String(stepId || "");
                    for (const e of items) {
                      if (e.stepId === sid) {
                        const xs = describe(e);
                        for (const s of xs) if (s) lines.push(s);
                      }
                    }
                    if (/day_gun_expiry/.test(sid) && f && f.draft && f.draft.gunExpiryAppliedByDay) {
                      try {
                        const xr = f.draft.gunExpiryAppliedByDay[String(g.day)];
                        if (xr && Array.isArray(xr.killed) && xr.killed.length) {
                          for (const { idx } of xr.killed) {
                            if (idx != null && draw.players[idx]) {
                              lines.push(appLang === "fa"
                                ? `${nameOf(idx)} ØªÙÙ†Ú¯ ÙˆØ§Ù‚Ø¹ÛŒ Ø®ÙˆØ¯ Ø±Ø§ Ø´Ù„ÛŒÚ© Ù†Ú©Ø±Ø¯ Ùˆ Ø§Ø² Ø¨Ø§Ø²ÛŒ Ø®Ø§Ø±Ø¬ Ø´Ø¯.`
                                : `${nameOf(idx)} did not fire their real gun and was eliminated.`);
                            }
                          }
                        }
                      } catch {}
                    }
                  }
                } else {
                  for (const e of items) {
                    const xs = describe(e);
                    for (const s of xs) if (s) lines.push(s);
                  }
                }
                // de-dupe identical adjacent lines for cleanliness
                const clean = [];
                for (const s of lines) {
                  if (!s) continue;
                  if (!clean.length || clean[clean.length - 1] !== s) clean.push(s);
                }
                // Kabo scenario: inject trust/suspects/shoot data from draft (not in events log)
                if (f && f.draft && scenario === "kabo") {
                  try {
                    const dk = String(g.day);
                    if (g.phase === "day") {
                      const trusted = f.draft.kaboTrustedByDay && f.draft.kaboTrustedByDay[dk];
                      if (trusted != null) {
                        clean.push(appLang === "fa" ? `Ù…Ø¹ØªÙ…Ø¯: ${nameOf(trusted)}.` : `Trusted: ${nameOf(trusted)}.`);
                      } else if (Number(dk) === 1) {
                        clean.push(appLang === "fa" ? "Ø±Ø£ÛŒ Ø§Ø¹ØªÙ…Ø§Ø¯: ØªØ³Ø§ÙˆÛŒ â€” Ù…Ø¹ØªÙ…Ø¯ÛŒ Ø§Ù†ØªØ®Ø§Ø¨ Ù†Ø´Ø¯." : "Trust vote: Tie â€” no Trusted person selected.");
                      }
                      const suspects = f.draft.kaboSuspectsByDay && f.draft.kaboSuspectsByDay[dk];
                      if (suspects && Array.isArray(suspects) && suspects.length) {
                        clean.push(appLang === "fa"
                          ? `Ù…Ø¸Ù†ÙˆÙ†Ø§Ù†: ${suspects.map(nameOf).join("ØŒ ")}.`
                          : `Suspects: ${suspects.map(nameOf).join(", ")}.`);
                      }
                      const kaboGun = f.draft.kaboGunByDay && f.draft.kaboGunByDay[dk];
                      if (kaboGun === "gun1" || kaboGun === "gun2") {
                        const gunLabel = kaboGun === "gun1" ? (appLang === "fa" ? "Ú¯Ù„ÙˆÙ„Ù‡ Û±" : "Gun 1") : (appLang === "fa" ? "Ú¯Ù„ÙˆÙ„Ù‡ Û²" : "Gun 2");
                        clean.push(appLang === "fa" ? `Ú†Ø±Øª Ø±ÙˆØ²: Ú©Ø§Ù¾Ùˆ Ú¯Ù„ÙˆÙ„Ù‡ ÙˆØ§Ù‚Ø¹ÛŒ Ø±Ø§ Â«${gunLabel}Â» ØªØ¹ÛŒÛŒÙ† Ú©Ø±Ø¯.` : `Mid-day: Capo set real bullet as ${gunLabel}.`);
                      }
                      const kaboShoot = f.draft.kaboShootByDay && f.draft.kaboShootByDay[dk];
                      if (kaboShoot) {
                        const g1n = kaboShoot.gun1 != null ? nameOf(kaboShoot.gun1) : (appLang === "fa" ? "Ù‡ÙˆØ§" : "air");
                        const g2n = kaboShoot.gun2 != null ? nameOf(kaboShoot.gun2) : (appLang === "fa" ? "Ù‡ÙˆØ§" : "air");
                        clean.push(appLang === "fa" ? `Ú¯Ù„ÙˆÙ„Ù‡ Û± â† ${g1n}` : `Gun 1 â†’ ${g1n}`);
                        clean.push(appLang === "fa" ? `Ú¯Ù„ÙˆÙ„Ù‡ Û² â† ${g2n}` : `Gun 2 â†’ ${g2n}`);
                      }
                    }
                  } catch {}
                }
                // Bazras scenario: inject interrogation outcome from draft
                if (f && f.draft && scenario === "bazras") {
                  try {
                    const dk = String(g.day);
                    if (g.phase === "day") {
                      const irec = f.draft.bazrasInterrogationByDay && f.draft.bazrasInterrogationByDay[dk];
                      if (irec && irec.decision === "cancel") {
                        clean.push(appLang === "fa" ? "Ø¨Ø§Ø²Ù¾Ø±Ø³ Ø¨Ø§Ø²Ù¾Ø±Ø³ÛŒ Ø±Ø§ Ù„ØºÙˆ Ú©Ø±Ø¯." : "Inspector cancelled interrogation.");
                      } else if (irec && irec.decision === "continue") {
                        // Derive winner: from applied state (prevEliminated/outcome) OR from pending vote counts.
                        let fvElim = null;
                        let fvTie = (irec.outcome === "tie");
                        if (!fvTie && irec.prevEliminated != null) {
                          fvElim = irec.prevEliminated;
                        } else if (!fvTie && irec.votes) {
                          // Votes counted but Next not yet clicked â€” compute from pending votes.
                          const prevNKfv = String(Math.max(0, parseInt(dk, 10) - 1));
                          const invTfv = f.draft.investigatorTargetsByNight && f.draft.investigatorTargetsByNight[prevNKfv];
                          const ft1 = invTfv && invTfv.t1 != null ? invTfv.t1 : null;
                          const ft2 = invTfv && invTfv.t2 != null ? invTfv.t2 : null;
                          if (ft1 != null && ft2 != null) {
                            const pv1 = Math.max(0, parseInt(irec.votes[ft1] || 0, 10));
                            const pv2 = Math.max(0, parseInt(irec.votes[ft2] || 0, 10));
                            if (pv1 > 0 || pv2 > 0) {
                              if (pv1 > pv2) fvElim = ft1;
                              else if (pv2 > pv1) fvElim = ft2;
                              else fvTie = true;
                            }
                          }
                        }
                        if (fvTie) {
                          clean.push(appLang === "fa" ? "Ø¨Ø§Ø²Ù¾Ø±Ø³ÛŒ Ø§Ø¯Ø§Ù…Ù‡ ÛŒØ§ÙØª â€” Ø±Ø£ÛŒ ØªØ³Ø§ÙˆÛŒ (Ú©Ø³ÛŒ Ø®Ø§Ø±Ø¬ Ù†Ø´Ø¯)." : "Interrogation continued â€” tie vote (no elimination).");
                        } else if (fvElim != null) {
                          clean.push(appLang === "fa"
                            ? `Ø¨Ø§Ø²Ù¾Ø±Ø³ÛŒ Ø§Ø¯Ø§Ù…Ù‡ ÛŒØ§ÙØª â€” ${nameOf(fvElim)} Ø¨Ø§ Ø±Ø£ÛŒ Ø§Ø¬Ø¨Ø§Ø±ÛŒ Ø§Ø² Ø¨Ø§Ø²ÛŒ Ø®Ø§Ø±Ø¬ Ø´Ø¯.`
                            : `Interrogation continued â€” ${nameOf(fvElim)} was eliminated by forced vote.`);
                        }
                      }
                    }
                  } catch {}
                }
                // Gun expiry: already injected at day_gun_expiry step when using step-order rendering
                if (f && f.draft && f.draft.gunExpiryAppliedByDay && !(g.phase === "day" && stepOrder.length)) {
                  try {
                    const dk = String(g.day);
                    if (g.phase === "day") {
                      const xr = f.draft.gunExpiryAppliedByDay[dk];
                      if (xr && Array.isArray(xr.killed) && xr.killed.length) {
                        for (const { idx } of xr.killed) {
                          if (idx != null && draw.players[idx]) {
                            clean.push(appLang === "fa"
                              ? `${nameOf(idx)} ØªÙÙ†Ú¯ ÙˆØ§Ù‚Ø¹ÛŒ Ø®ÙˆØ¯ Ø±Ø§ Ø´Ù„ÛŒÚ© Ù†Ú©Ø±Ø¯ Ùˆ Ø§Ø² Ø¨Ø§Ø²ÛŒ Ø®Ø§Ø±Ø¬ Ø´Ø¯.`
                              : `${nameOf(idx)} did not fire their real gun and was eliminated.`);
                          }
                        }
                      }
                    }
                  } catch {}
                }
                // Pedarkhande: inject Kane reveal when Citizen Kane marked mafia (no day events yet)
                if (f && f.draft && scenario === "pedarkhande" && g.phase === "day") {
                  try {
                    const kaneRec = f.draft.kaneRevealAppliedByDay && f.draft.kaneRevealAppliedByDay[String(g.day)];
                    if (kaneRec && kaneRec.revealed === true && kaneRec.idx != null && draw.players[kaneRec.idx]) {
                      const kaneIdx = findIdxByRole(["citizenKane"]);
                      const revealedName = nameOf(kaneRec.idx);
                      clean.push(appLang === "fa"
                        ? `${kaneIdx != null ? nameOf(kaneIdx) : "Ù‡Ù…Ø´Ù‡Ø±ÛŒ Ú©ÛŒÙ†"} ${revealedName} Ø±Ø§ Ø§ÙØ´Ø§ Ú©Ø±Ø¯ (Ù…Ø§ÙÛŒØ§) â€” Ø¯Ø± Ø¨Ø§Ø²ÛŒ Ù…ÛŒâ€ŒÙ…Ø§Ù†Ø¯.`
                        : `${kaneIdx != null ? nameOf(kaneIdx) : "Citizen Kane"} revealed ${revealedName} (mafia) â€” remains in game.`);
                    }
                  } catch {}
                }
                // Show block if we have clean lines, or eliminated/revived (even if no events)
                const eliminated = (typeof getEliminatedForStatusCheck === "function" && f)
                  ? getEliminatedForStatusCheck(f, g.day, g.phase)
                  : [];
                const revived = (typeof getRevivedForStatusCheck === "function" && f)
                  ? getRevivedForStatusCheck(f, g.day, g.phase)
                  : [];
                const changedRoles = (typeof getChangedRolesForStatusCheck === "function" && f)
                  ? getChangedRolesForStatusCheck(f, g.day, g.phase)
                  : [];
                if (!clean.length && !eliminated.length && !revived.length && !changedRoles.length) return "";

                const elimLabel = appLang === "fa" ? "Ø®Ø§Ø±Ø¬â€ŒØ´Ø¯Ú¯Ø§Ù†:" : "Eliminated:";
                const elimRow = eliminated.length
                  ? `<li style="list-style:none; margin-top:8px; padding-top:7px; border-top:1px solid rgba(255,255,255,.18); color:rgba(255,110,70,.95); font-weight:1000">
                      ${escapeHtml(elimLabel)} ${eliminated.map(plainNameOf).map(escapeHtml).join("ØŒ\u200f ")}
                    </li>`
                  : "";
                const revLabel = appLang === "fa" ? "Ø¨Ø±Ú¯Ø´Øªâ€ŒÛŒØ§ÙØªÚ¯Ø§Ù†:" : "Revived:";
                const revRow = revived.length
                  ? `<li style="list-style:none; margin-top:6px; color:rgba(74,222,128,.95); font-weight:1000">
                      ${escapeHtml(revLabel)} ${revived.map(plainNameOf).map(escapeHtml).join("ØŒ\u200f ")}
                    </li>`
                  : "";
                const changedLabel = appLang === "fa" ? "ØªØºÛŒÛŒØ± Ù†Ù‚Ø´:" : "Changed Roles:";
                const formatChangedEntry = (entry) => {
                  if (entry.type === "face_off") {
                    const outRn = (typeof roleName === "function") ? roleName(entry.tgtRole) : entry.tgtRole;
                    const tgtRn = (typeof roleName === "function") ? roleName(entry.outRole) : entry.outRole;
                    return (appLang === "fa")
                      ? `${plainNameOf(entry.out)} Ø´Ø¯ ${outRn}ØŒ ${plainNameOf(entry.target)} Ø´Ø¯ ${tgtRn}`
                      : `${plainNameOf(entry.out)} became ${outRn}, ${plainNameOf(entry.target)} became ${tgtRn}`;
                  }
                  if (entry.type === "saul_buy" || entry.type === "heir_inherit") {
                    const rn = (typeof roleName === "function") ? roleName(entry.newRole) : entry.newRole;
                    return (appLang === "fa")
                      ? `${plainNameOf(entry.idx)} Ø´Ø¯ ${rn}`
                      : `${plainNameOf(entry.idx)} became ${rn}`;
                  }
                  return "";
                };
                const changedRow = changedRoles.length
                  ? `<li style="list-style:none; margin-top:6px; color:rgba(251,191,36,.95); font-weight:1000">
                      ${escapeHtml(changedLabel)} ${changedRoles.map((e) => escapeHtml(formatChangedEntry(e))).filter(Boolean).join("Ø›\u200f ")}
                    </li>`
                  : "";

                return `
                  <div class="toolBox" style="margin-top:12px">
                    <div style="font-weight:1100; margin-bottom:6px">${escapeHtml(phaseTitle(g.day, g.phase))}</div>
                    <ul style="margin:0; padding-${appLang === "fa" ? "right" : "left"}:18px; line-height:1.9">
                      ${clean.map((s) => `<li>${escapeHtml(s)}</li>`).join("")}
                      ${elimRow}
                      ${revRow}
                      ${changedRow}
                    </ul>
                  </div>
                `;
              }).filter(Boolean).join("");

              // Intro Night block â€” shown once game has advanced past intro phases.
              const introNightBlock = (() => {
                try {
                  if (!f || f.phase === "intro_day" || f.phase === "intro_night") return "";
                  const d = f.draft || {};
                  const introNight = d.nightActionsByNight && d.nightActionsByNight["0"];
                  const clean = [];

                  // Nostradamus chose side (pedarkhande)
                  if (scenario === "pedarkhande" && (d.nostradamusChosenSide === "mafia" || d.nostradamusChosenSide === "citizen")) {
                    const nostIdx = findIdxByRole(["nostradamus"]);
                    if (nostIdx !== null) {
                      const sideLabel = d.nostradamusChosenSide === "mafia" ? (appLang === "fa" ? "Ù…Ø§ÙÛŒØ§" : "Mafia") : (appLang === "fa" ? "Ø´Ù‡Ø±" : "Citizens");
                      clean.push(appLang === "fa"
                        ? `${nameOf(nostIdx)} Ø³Ø§ÛŒØ¯ ${sideLabel} Ø±Ø§ Ø§Ù†ØªØ®Ø§Ø¨ Ú©Ø±Ø¯.`
                        : `${nameOf(nostIdx)} chose ${sideLabel} side.`);
                    }
                  }
                  // Heir successor pick
                  if (introNight && introNight.heirPick != null) {
                    const heirPlayerIdx = (draw.players || []).findIndex((p) => p && p.roleId === "heir");
                    const pickIdx = parseInt(introNight.heirPick, 10);
                    if (Number.isFinite(pickIdx)) {
                      const heirName = heirPlayerIdx >= 0 ? nameOf(heirPlayerIdx) : (appLang === "fa" ? "ÙˆØ§Ø±Ø«" : "Heir");
                      clean.push(appLang === "fa"
                        ? `${heirName} Ø¬Ø§Ù†Ø´ÛŒÙ† Ø§Ù†ØªØ®Ø§Ø¨ Ú©Ø±Ø¯: ${nameOf(pickIdx)}.`
                        : `${heirName} picked successor: ${nameOf(pickIdx)}.`);
                    }
                  }

                  if (!clean.length) return "";
                  const introTitle = appLang === "fa" ? "Ø´Ø¨ Ù…Ø¹Ø§Ø±ÙÙ‡" : "Intro Night";
                  return `
                    <div class="toolBox" style="margin-top:12px">
                      <div style="font-weight:1100; margin-bottom:6px">${escapeHtml(introTitle)}</div>
                      <ul style="margin:0; padding-${appLang === "fa" ? "right" : "left"}:18px; line-height:1.9">
                        ${clean.map((s) => `<li>${escapeHtml(s)}</li>`).join("")}
                      </ul>
                    </div>
                  `;
                } catch { return ""; }
              })();

              const title = escapeHtml(appLang === "fa" ? "Ø±ÙˆÙ†Ø¯ (Ø±ÙˆØ²/Ø´Ø¨)" : "Timeline (Day/Night)");
              return `
                <div style="margin-top:12px">
                  <div style="font-weight:1200; margin-bottom:6px">${title}</div>
                  ${introNightBlock}${blocks || (!introNightBlock ? `<div class="note">${escapeHtml(appLang === "fa" ? "Ú†ÛŒØ²ÛŒ Ø¨Ø±Ø§ÛŒ Ù†Ù…Ø§ÛŒØ´ Ù†ÛŒØ³Øª." : "Nothing to show.")}</div>` : "")}
                </div>
              `;
            } catch {
              return "";
            }
          })();

          openToolModal(t("tool.status.title"), `
            <div class="toolBox" style="font-weight:950; line-height:1.9">
              <div>${summaryText}</div>
              <div class="note" style="margin-top:10px">${aliveLine}</div>
            </div>
            ${timelineHtml}
          `);
        }

        function showLastMoveTool() {
          const scenario = getScenario();
          const _lmCfg = getScenarioConfig(scenario);
          const supports = !!_lmCfg.features?.lastMove;
          if (!supports) {
            openToolModal(t("tool.lastMove.title"), `<div class="toolBox">${escapeHtml(t("tool.lastMove.none"))}</div>`);
            return;
          }
          const lastMoveCards = _lmCfg.eliminationCards || [];
          const labelFor = (id) => {
            const c = lastMoveCards.find((x) => x.id === id);
            if (!c) return String(id || "");
            return appLang === "fa" ? c.fa : c.en;
          };
          if (!appState.god.lastMove || typeof appState.god.lastMove !== "object") {
            appState.god.lastMove = { last: null, at: null, used: [] };
          } else {
            if (!Array.isArray(appState.god.lastMove.used)) appState.god.lastMove.used = [];
          }
          const used = new Set(appState.god.lastMove.used || []);
          const remaining = lastMoveCards.filter((c) => !used.has(c.id));
          const lastId = appState.god.lastMove && appState.god.lastMove.last ? appState.god.lastMove.last : null;
          const last = lastId ? labelFor(lastId) : null;

          const listHtml = lastMoveCards.map((c) => {
            const isUsed = used.has(c.id);
            const txt = labelFor(c.id);
            const st = isUsed
              ? 'opacity:.45; filter:saturate(.2); text-decoration:line-through;'
              : '';
            return `<div style="padding:6px 0;font-weight:950;${st}">${escapeHtml(txt)}</div>`;
          }).join("");
          openToolModal(t("tool.lastMove.title"), `
            <div class="toolBox">
              <div style="font-weight:1100;margin-bottom:8px">${escapeHtml(t("tool.lastMove.header"))}</div>
              ${listHtml}
              <div style="height:10px"></div>
              <button class="btn primary" id="lm_draw" type="button">${escapeHtml(t("tool.lastMove.draw"))}</button>
              <div class="note" id="lm_note" style="display:none; margin-top:10px"></div>
              <div style="height:10px"></div>
              <div style="font-weight:1100">${escapeHtml(t("tool.lastMove.result"))} <span id="lm_res">${last ? escapeHtml(last) : "â€”"}</span></div>
            </div>
          `);
          $("lm_draw").onclick = () => {
            const note = $("lm_note");
            if (!remaining.length) {
              if (note) {
                note.style.display = "block";
                note.textContent = t("tool.lastMove.allUsed");
              }
              return;
            }
            const picked = remaining[Math.floor(Math.random() * remaining.length)];
            appState.god.lastMove.last = picked.id;
            appState.god.lastMove.at = Date.now();
            if (!Array.isArray(appState.god.lastMove.used)) appState.god.lastMove.used = [];
            appState.god.lastMove.used.push(picked.id);
            saveState(appState);
            // re-render to grey out used + update remaining list
            showLastMoveTool();
          };
          // disable button if no remaining
          if (!remaining.length) {
            const btn = $("lm_draw");
            if (btn) btn.disabled = true;
            const note = $("lm_note");
            if (note) {
              note.style.display = "block";
              note.textContent = t("tool.lastMove.allUsed");
            }
          }
        }

        let bombApplyJustHappened = false;


        function showRoleChangeTool() {
          const draw = appState.draw;
          if (!draw || !draw.players) {
            openToolModal(t("tool.roleChange.title"), `<div class="toolBox">${escapeHtml(t("tool.roleChange.needDeal"))}</div>`);
            return;
          }
          const roleIds = getAllowedRoleIdsForScenario();
          const playerOpts = draw.players.map((p, i) => {
            const name = (appState.ui.playerNames && appState.ui.playerNames[i]) ? appState.ui.playerNames[i] : t("common.playerN", { n: i + 1 });
            return `<option value="${i}">${escapeHtml(name)}</option>`;
          }).join("");
          const roleOpts = roleIds.map((rid) => `<option value="${rid}">${escapeHtml(roleName(rid))}</option>`).join("");

          openToolModal(t("tool.roleChange.title"), `
            <div class="toolBox">
              <div style="font-weight:1100;margin-bottom:10px">${escapeHtml(t("tool.roleChange.pick"))}</div>
              <div class="row one">
                <label>${escapeHtml(t("tool.roleChange.labelPlayer"))}
                  <select id="rc_player">${playerOpts}</select>
                </label>
                <label>${escapeHtml(t("tool.roleChange.labelRole"))}
                  <select id="rc_role">${roleOpts}</select>
                </label>
              </div>
              <div style="height:10px"></div>
              <button class="btn primary" id="rc_apply" type="button">${escapeHtml(t("tool.roleChange.apply"))}</button>
              <div style="height:10px"></div>
              <button class="btn" id="rc_shuffle_all" type="button">${escapeHtml(t("tool.roleChange.shuffleAll"))}</button>
              <div class="note" id="rc_shuffle_note" style="display:none">
                ${escapeHtml(t("tool.roleChange.shuffleWarn"))}
              </div>
            </div>
          `);

          $("rc_apply").onclick = () => {
            const idx = parseInt($("rc_player").value, 10);
            const rid = $("rc_role").value;
            if (!Number.isFinite(idx) || !roles[rid]) return;
            draw.players[idx].roleId = rid;
            saveState(appState);
            renderCast();
            closeToolModal();
          };

          // Dangerous action: require confirmation click.
          let shuffleArmed = false;
          let shuffleArmTimer = null;
          const shuffleBtn = $("rc_shuffle_all");
          const shuffleNote = $("rc_shuffle_note");
          const disarmShuffle = () => {
            shuffleArmed = false;
            if (shuffleArmTimer) { try { clearTimeout(shuffleArmTimer); } catch {} }
            shuffleArmTimer = null;
            if (shuffleBtn) {
              shuffleBtn.classList.remove("danger");
              shuffleBtn.textContent = t("tool.roleChange.shuffleAll");
            }
            if (shuffleNote) shuffleNote.style.display = "none";
          };
          if (shuffleBtn) {
            shuffleBtn.onclick = () => {
              if (!shuffleArmed) {
                shuffleArmed = true;
                if (shuffleBtn) {
                  shuffleBtn.classList.add("danger");
                  shuffleBtn.textContent = t("tool.roleChange.shuffleConfirm");
                }
                if (shuffleNote) shuffleNote.style.display = "block";
                if (shuffleArmTimer) { try { clearTimeout(shuffleArmTimer); } catch {} }
                shuffleArmTimer = setTimeout(disarmShuffle, 6000);
                return;
              }
              // confirmed: Shuffle role assignments across all players (preserve role multiset).
              const roleIds = draw.players.map((p) => p.roleId || "citizen");
              shuffle(roleIds);
              for (let i = 0; i < draw.players.length; i++) {
                draw.players[i].roleId = roleIds[i];
                draw.players[i].revealed = true; // role list screen assumes roles are known to narrator
              }
              saveState(appState);
              renderCast();
              closeToolModal();
            };
          }
        }

        function showChanceTool() {
          const draw = appState.draw;
          if (!draw || !draw.players) {
            openToolModal(t("tool.chance.title"), `<div class="toolBox">${escapeHtml(t("tool.roleChange.needDeal"))}</div>`);
            return;
          }
          const n = draw.players.length;
          openToolModal(t("tool.chance.title"), `
            <div class="toolBox">
              <div style="font-weight:1100;margin-bottom:10px">${escapeHtml(t("tool.chance.ask"))}</div>
              <label>
                ${escapeHtml(t("tool.chance.count"))}
                <select id="ch_n">
                  ${Array.from({ length: Math.min(10, n) }, (_, i) => i + 2)
                    .filter((k) => k <= n)
                    .map((k) => `<option value="${k}">${k}</option>`)
                    .join("")}
                </select>
              </label>
              <div style="height:10px"></div>
              <button class="btn primary" id="ch_spin" type="button">${escapeHtml(t("tool.chance.spin"))}</button>
              <div style="height:10px"></div>
              <div style="font-weight:1100">${escapeHtml(t("tool.chance.result"))}</div>
              <div id="ch_res" style="padding-top:6px; font-weight:950; line-height:1.9">â€”</div>
            </div>
          `);
          $("ch_spin").onclick = () => {
            const k = parseInt($("ch_n").value, 10);
            const kk = Math.max(1, Math.min(n, Number.isFinite(k) ? k : 1));
            const picked = 1 + Math.floor(Math.random() * kk);
            const res = t("common.playerN", { n: picked });
            $("ch_res").textContent = res;
            appState.god.chance = { last: picked, at: Date.now() };
            saveState(appState);
          };
        }

        let timerInterval = null;
        let audioCtx = null;
        let audioUnlocked = false;
        function ensureTimers() {
          if (appState.god.timers) return;
          appState.god.timers = {
            talk: 50,
            challenge: 40,
            defense: 60,
            chaos: 120,
            running: null, // key
            remaining: { talk: 50, challenge: 40, defense: 60, chaos: 120 },
            startedAt: null,
          };
        }
        function stopTimerInterval() {
          if (timerInterval) clearInterval(timerInterval);
          timerInterval = null;
        }

        function unlockAudio() {
          try {
            const AC = window.AudioContext || window.webkitAudioContext;
            if (!AC) return false;
            if (!audioCtx) audioCtx = new AC();
            // On iOS Safari, resume must happen during a user gesture.
            if (audioCtx.state === "suspended") {
              try { audioCtx.resume(); } catch {}
            }
            // Play an almost-silent blip to "unlock" audio output.
            const now = audioCtx.currentTime;
            const g = audioCtx.createGain();
            g.gain.setValueAtTime(0.00001, now);
            g.connect(audioCtx.destination);
            const o = audioCtx.createOscillator();
            o.type = "sine";
            o.frequency.setValueAtTime(440, now);
            o.connect(g);
            o.start(now);
            o.stop(now + 0.01);
            audioUnlocked = true;
            return true;
          } catch {
            return false;
          }
        }

        function playBeep() {
          try {
            const AC = window.AudioContext || window.webkitAudioContext;
            if (!AC) return;
            if (!audioCtx) audioCtx = new AC();
            if (audioCtx.state === "suspended") {
              // If we didn't unlock earlier via a user tap, iOS may block this resume.
              try { audioCtx.resume(); } catch {}
            }

            const now = audioCtx.currentTime;
            const gain = audioCtx.createGain();
            gain.gain.setValueAtTime(0.0001, now);
            gain.gain.linearRampToValueAtTime(0.22, now + 0.01);
            gain.gain.exponentialRampToValueAtTime(0.0001, now + 0.35);
            gain.connect(audioCtx.destination);

            const osc = audioCtx.createOscillator();
            osc.type = "sine";
            osc.frequency.setValueAtTime(880, now);
            osc.connect(gain);
            osc.start(now);
            osc.stop(now + 0.36);

            // small second beep
            const gain2 = audioCtx.createGain();
            gain2.gain.setValueAtTime(0.0001, now + 0.45);
            gain2.gain.linearRampToValueAtTime(0.20, now + 0.46);
            gain2.gain.exponentialRampToValueAtTime(0.0001, now + 0.72);
            gain2.connect(audioCtx.destination);

            const osc2 = audioCtx.createOscillator();
            osc2.type = "sine";
            osc2.frequency.setValueAtTime(880, now + 0.45);
            osc2.connect(gain2);
            osc2.start(now + 0.45);
            osc2.stop(now + 0.73);
          } catch {
            // ignore audio errors (autoplay policies, etc.)
          }
        }
        function tickTimers() {
          const t = appState.god.timers;
          if (!t || !t.running) return;
          if (!t.startedAt) t.startedAt = Date.now();
          const now = Date.now();
          const elapsed = Math.floor((now - t.startedAt) / 1000);
          const base = t.remaining[t.running + "_base"] ?? t.remaining[t.running];
          const rem = Math.max(0, base - elapsed);
          t.remaining[t.running] = rem;
          const el = document.getElementById("tm_" + t.running);
          if (el) el.textContent = formatMMSS(rem);
          if (rem <= 0) {
            const endedKey = t.running;
            t.running = null;
            t.startedAt = null;
            stopTimerInterval();
            playBeep();
            // reset this timer to runner-configured duration
            if (endedKey && typeof t[endedKey] === "number") {
              t.remaining[endedKey] = t[endedKey];
              delete t.remaining[endedKey + "_base"];
              const el2 = document.getElementById("tm_" + endedKey);
              if (el2) el2.textContent = formatMMSS(t.remaining[endedKey]);
            }
            saveState(appState);
          }
          // refresh play/pause icons if tool is open
          updateTimerIcons();
        }

        function updateTimerIcons() {
          const t = appState.god.timers;
          if (!t) return;
          const playSvg = `<svg viewBox="0 0 24 24" fill="currentColor" aria-hidden="true"><path d="M8 6.82v10.36c0 .79.87 1.27 1.54.84l8.14-5.18a1 1 0 0 0 0-1.68L9.54 5.98A1 1 0 0 0 8 6.82z"/></svg>`;
          const pauseSvg = `<svg viewBox="0 0 24 24" fill="currentColor" aria-hidden="true"><rect x="6" y="4" width="4" height="16" rx="2"/><rect x="14" y="4" width="4" height="16" rx="2"/></svg>`;
          const set = (key) => {
            const b = document.getElementById("tm_btn_" + key);
            if (!b) return;
            const running = (t.running === key);
            b.innerHTML = running ? pauseSvg : playSvg;
            b.classList.toggle("is-running", running);
          };
          set("talk");
          set("challenge");
          set("defense");
          set("chaos");
        }

        function showTimerPicker(key, returnFn) {
          ensureTimers();
          const tmr = appState.god.timers;
          const labels = { talk: t("tool.timer.turn"), challenge: t("tool.timer.challenge"), defense: t("tool.timer.defense") };
          const presets = [
            10, 15, 20, 30, 40, 45, 50, 55, 60, 75, 90, 120, 150, 180,
          ];
          openToolModal(t("tool.timer.pick.title"), `
            <div class="toolBox">
              <div style="font-weight:1100;margin-bottom:10px">${escapeHtml(t("tool.timer.pick.ask", { label: labels[key] || key }))}</div>
              <label>
                ${escapeHtml(t("tool.timer.pick.seconds"))}
                <select id="tp_val">
                  ${presets.map((s) => `<option value="${s}" ${tmr[key] === s ? "selected" : ""}>${s}</option>`).join("")}
                </select>
              </label>
              <div style="height:12px"></div>
              <button class="btn primary" id="tp_apply" type="button">${escapeHtml(t("tool.timer.pick.apply"))}</button>
              <div style="height:10px"></div>
              <button class="btn" id="tp_cancel" type="button">${escapeHtml(t("tool.timer.pick.back"))}</button>
            </div>
          `, { hideBottom: true });

          $("tp_apply").onclick = () => {
            const v = parseInt($("tp_val").value, 10);
            if (!Number.isFinite(v) || v <= 0) return;
            // stop if currently running this timer
            if (tmr.running === key) {
              tmr.running = null;
              tmr.startedAt = null;
              stopTimerInterval();
            }
            tmr[key] = v;
            tmr.remaining[key] = v;
            delete tmr.remaining[key + "_base"];
            saveState(appState);
            (returnFn || showTimerTool)();
          };
          $("tp_cancel").onclick = () => (returnFn || showTimerTool)();
        }
        function startOrPauseTimer(key) {
          ensureTimers();
          const t = appState.god.timers;
          // iOS Safari: unlock audio during a user gesture (button click).
          if (!audioUnlocked) unlockAudio();
          if (t.running === key) {
            // pause
            t.running = null;
            t.startedAt = null;
            stopTimerInterval();
            saveState(appState);
            updateTimerIcons();
            return;
          }
          // set base snapshot
          t.remaining[key + "_base"] = t.remaining[key];
          t.running = key;
          t.startedAt = Date.now();
          stopTimerInterval();
          timerInterval = setInterval(tickTimers, 250);
          saveState(appState);
          updateTimerIcons();
        }
        function resetSingleTimer(key) {
          ensureTimers();
          const t = appState.god.timers;
          if (t.running === key) {
            t.running = null;
            t.startedAt = null;
            stopTimerInterval();
          }
          t.remaining[key] = t[key];
          delete t.remaining[key + "_base"];
          saveState(appState);
          const el = document.getElementById("tm_" + key);
          if (el) el.textContent = formatMMSS(t.remaining[key]);
          updateTimerIcons();
        }
        function resetTimers() {
          ensureTimers();
          const t = appState.god.timers;
          t.running = null;
          t.startedAt = null;
          t.remaining = { talk: t.talk, challenge: t.challenge, defense: t.defense };
          try { delete t.remaining.talk_base; delete t.remaining.challenge_base; delete t.remaining.defense_base; } catch {}
          stopTimerInterval();
          saveState(appState);
          updateTimerIcons();
          // update visible numbers immediately (if tool is open)
          try {
            const a = document.getElementById("tm_talk");
            const b = document.getElementById("tm_challenge");
            const c = document.getElementById("tm_defense");
            if (a) a.textContent = formatMMSS(t.remaining.talk);
            if (b) b.textContent = formatMMSS(t.remaining.challenge);
            if (c) c.textContent = formatMMSS(t.remaining.defense);
          } catch {}
        }
        function showDrawTool() {
          const draw = appState.draw;
          if (!draw || !draw.players) {
            openToolModal(t("tools.chance"), `<p style="padding:8px 0;color:var(--muted)">${appLang === "fa" ? "Ø¯Ø§Ø¯Ù‡â€ŒØ§ÛŒ Ù…ÙˆØ¬ÙˆØ¯ Ù†ÛŒØ³Øª." : "No data available."}</p>`, { hideBottom: true });
            return;
          }
          const getName = (i) => (appState.ui.playerNames && appState.ui.playerNames[i]) ? appState.ui.playerNames[i] : t("common.playerN", { n: i + 1 });
          const alivePlayers = draw.players.map((p, i) => ({ ...p, idx: i })).filter(p => p.alive !== false);
          if (alivePlayers.length === 0) {
            openToolModal(t("tools.chance"), `<p style="padding:8px 0;color:var(--muted)">${appLang === "fa" ? "Ø¨Ø§Ø²ÛŒÚ©Ù† Ø²Ù†Ø¯Ù‡â€ŒØ§ÛŒ ÙˆØ¬ÙˆØ¯ Ù†Ø¯Ø§Ø±Ø¯." : "No alive players."}</p>`, { hideBottom: true });
            return;
          }

          const S_IDLE = `background:rgba(255,255,255,.05);border:2px solid rgba(255,255,255,.10);color:var(--muted);font-weight:950;`;
          const S_SEL  = `background:rgba(99,179,237,.22);border:2px solid #63b3ed;color:#fff;font-weight:1100;`;
          const S_WIN  = `background:rgba(53,208,127,.28);border:2px solid rgba(53,208,127,.9);color:#fff;font-weight:1100;`;
          const CARD_BASE = `width:100%;aspect-ratio:1/1;border-radius:14px;cursor:pointer;display:flex;align-items:center;justify-content:center;text-align:center;padding:8px;font-size:13px;line-height:1.3;transition:background .12s,border-color .12s;box-shadow:0 4px 12px rgba(0,0,0,.25);`;

          const cards = alivePlayers.map(p =>
            `<button class="drawCard" data-idx="${p.idx}" type="button" style="${CARD_BASE}${S_IDLE}">${escapeHtml(getName(p.idx))}</button>`
          ).join("");

          const bodyHtml = `
            <div style="padding:4px 0 8px">
              <div class="note" style="margin-bottom:10px">${escapeHtml(appLang === "fa" ? "Ø¨Ø§Ø²ÛŒÚ©Ù†Ø§Ù† Ø´Ø±Ú©Øªâ€ŒÚ©Ù†Ù†Ø¯Ù‡ Ø±Ø§ Ø§Ù†ØªØ®Ø§Ø¨ Ú©Ù†ÛŒØ¯:" : "Select players to include in the draw:")}</div>
              <div id="drawGrid" style="display:grid;grid-template-columns:repeat(3,1fr);gap:8px;max-height:52vh;overflow:auto;-webkit-overflow-scrolling:touch;">${cards}</div>
              <div style="margin-top:14px;display:flex;gap:8px;">
                <button id="drawBtn" class="btn primary" type="button" style="flex:1;opacity:0.45" disabled>${appLang === "fa" ? "Ù‚Ø±Ø¹Ù‡â€ŒÚ©Ø´ÛŒ" : "Draw"}</button>
                <button id="drawEliminateBtn" class="btn" style="flex:1;background:#dc2626;color:#fff;border-color:#dc2626;display:none" type="button">${appLang === "fa" ? "Ø­Ø°Ù Ø§Ø² Ø¨Ø§Ø²ÛŒ" : "Eliminate"}</button>
              </div>
            </div>`;

          openToolModal(t("tools.chance"), bodyHtml, { hideBottom: true });

          const grid = document.getElementById("drawGrid");
          const drawBtn = document.getElementById("drawBtn");
          const elimBtn = document.getElementById("drawEliminateBtn");
          const selected = new Set();
          let winnerIdx = null;

          const refreshDrawBtn = () => {
            const hasSelected = selected.size > 0;
            drawBtn.disabled = !hasSelected;
            drawBtn.style.opacity = hasSelected ? "" : "0.45";
          };

          grid.addEventListener("click", (e) => {
            const card = e.target.closest(".drawCard");
            if (!card || winnerIdx !== null) return;
            const idx = parseInt(card.dataset.idx, 10);
            if (selected.has(idx)) {
              selected.delete(idx);
              card.style.cssText = CARD_BASE + S_IDLE;
            } else {
              selected.add(idx);
              card.style.cssText = CARD_BASE + S_SEL;
            }
            refreshDrawBtn();
          });

          drawBtn.addEventListener("click", () => {
            if (selected.size === 0) return;
            const pool = Array.from(selected);
            winnerIdx = pool[Math.floor(Math.random() * pool.length)];
            // Update all cards: dim non-winners, highlight winner
            grid.querySelectorAll(".drawCard").forEach(card => {
              const idx = parseInt(card.dataset.idx, 10);
              card.style.cssText = CARD_BASE + (idx === winnerIdx ? S_WIN : S_IDLE);
            });
            drawBtn.disabled = true;
            drawBtn.style.opacity = "0.45";
            elimBtn.style.display = "";
          });

          elimBtn.addEventListener("click", () => {
            if (winnerIdx === null) return;
            setPlayerLife(winnerIdx, { alive: false, reason: "vote" });
            renderCast();
            closeToolModal();
          });
        }

        function showTimerTool() {
          ensureTimers();
          const tmr = appState.god.timers;
          // iOS Safari: opening timer tool is a user gesture; unlock audio here.
          if (!audioUnlocked) unlockAudio();
          openToolModal(t("tool.timer.title"), `
            <div class="timerRow">
              <div class="timerCard">
                <div class="tname">${escapeHtml(t("tool.timer.turn"))}</div>
                <div class="tval clickable" id="tm_talk">${formatMMSS(tmr.remaining.talk)}</div>
                <button class="tbtn" id="tm_btn_talk" type="button" aria-label="Play/Pause"></button>
              </div>
              <div class="timerCard">
                <div class="tname">${escapeHtml(t("tool.timer.challenge"))}</div>
                <div class="tval clickable" id="tm_challenge">${formatMMSS(tmr.remaining.challenge)}</div>
                <button class="tbtn" id="tm_btn_challenge" type="button" aria-label="Play/Pause"></button>
              </div>
              <div class="timerCard" style="grid-column: 1 / -1;">
                <div class="tname">${escapeHtml(t("tool.timer.defense"))}</div>
                <div class="tval clickable" id="tm_defense">${formatMMSS(tmr.remaining.defense)}</div>
                <button class="tbtn" id="tm_btn_defense" type="button" aria-label="Play/Pause"></button>
              </div>
            </div>
            <div class="timerActions">
              <button class="reset" id="tm_reset" type="button">${escapeHtml(t("tool.timer.reset"))}</button>
              <button class="close" id="tm_close" type="button">${escapeHtml(t("tool.timer.close"))}</button>
            </div>
          `, { hideBottom: true });

          $("tm_btn_talk").onclick = () => startOrPauseTimer("talk");
          $("tm_btn_challenge").onclick = () => startOrPauseTimer("challenge");
          $("tm_btn_defense").onclick = () => startOrPauseTimer("defense");
          $("tm_talk").onclick = () => showTimerPicker("talk");
          $("tm_challenge").onclick = () => showTimerPicker("challenge");
          $("tm_defense").onclick = () => showTimerPicker("defense");
          $("tm_reset").onclick = resetTimers;
          $("tm_close").onclick = closeToolModal;

          updateTimerIcons();

          // if a timer is running, ensure UI ticks
          if (appState.god.timers.running && !timerInterval) {
            timerInterval = setInterval(tickTimers, 250);
          }
        }

        function ensureNamesLength(n) {
          if (!Array.isArray(appState.ui.playerNames)) appState.ui.playerNames = [];
          const cur = appState.ui.playerNames.slice(0, n);
          while (cur.length < n) cur.push("");
          appState.ui.playerNames = cur;
        }

        function setNamesMode(mode) {
          appState.ui.namesMode = mode;
          $("namesDefaultBtn").classList.toggle("active", mode === "default");
          $("namesLastBtn").classList.toggle("active", mode === "last");
          if (mode === "last") {
            const last = loadLastNames();
            if (last && last.length) {
              ensureNamesLength(appState.ui.nPlayers);
              for (let i = 0; i < appState.ui.nPlayers; i++) {
                appState.ui.playerNames[i] = (last[i] || "").trim();
              }
            }
          }
          renderNameGrid();
          saveState(appState);
        }

        function renderNameGrid() {
          const host = $("nameGrid");
          host.innerHTML = "";
          ensureNamesLength(appState.ui.nPlayers);
          for (let i = 0; i < appState.ui.nPlayers; i++) {
            const row = document.createElement("div");
            row.className = "nameRow";
            row.innerHTML = `
              <div class="num">${i + 1}</div>
              <input id="nm_${i}" type="text" inputmode="text" placeholder="${escapeHtml(t("common.playerN", { n: i + 1 }))}" value="${escapeHtml(appState.ui.playerNames[i] || "")}" />
            `;
            host.appendChild(row);
          }
          for (let i = 0; i < appState.ui.nPlayers; i++) {
            const el = $("nm_" + i);
            el.addEventListener("input", () => {
              appState.ui.playerNames[i] = el.value;
              saveState(appState);
              validatePlayerNamesAndShowError();
            });
          }
        }

        function normalizeNameForCompare(name) {
          return String(name || "")
            .trim()
            .replace(/\s+/g, " ")
            .toLocaleLowerCase(appLang === "fa" ? "fa" : "en");
        }

        function readNamesFromInputs() {
          ensureNamesLength(appState.ui.nPlayers);
          const names = [];
          for (let i = 0; i < appState.ui.nPlayers; i++) {
            const el = $("nm_" + i);
            names.push((el ? el.value : appState.ui.playerNames[i] || "").trim());
          }
          return names;
        }

        function getDuplicateNames(names) {
          const seen = new Map(); // norm -> firstIndex
          const dups = new Set();
          for (let i = 0; i < names.length; i++) {
            const norm = normalizeNameForCompare(names[i]);
            if (!norm) continue; // ignore empty names
            if (seen.has(norm)) dups.add(norm);
            else seen.set(norm, i);
          }
          return Array.from(dups);
        }

        function getFirstRepeatedName(names) {
          const seen = new Map(); // norm -> displayName
          for (let i = 0; i < names.length; i++) {
            const display = String(names[i] || "").trim();
            const norm = normalizeNameForCompare(display);
            if (!norm) continue;
            if (seen.has(norm)) return seen.get(norm) || display;
            seen.set(norm, display);
          }
          return null;
        }

        function validatePlayerNamesAndShowError() {
          const names = readNamesFromInputs();
          const repeated = getFirstRepeatedName(names);
          if (repeated) {
            setError(t("error.duplicateName", { name: repeated }));
            return false;
          }
          // don't clear other errors if set elsewhere; only clear if this was the reason
          setError("");
          return true;
        }

        function escapeHtml(s) {
          return String(s)
            .replaceAll("&", "&amp;")
            .replaceAll("<", "&lt;")
            .replaceAll(">", "&gt;")
            .replaceAll('"', "&quot;")
            .replaceAll("'", "&#39;");
        }

        function openRoleHelpOverlay(roleId) {
          const rid = roleId || "";
          const scenario = (appState.draw && appState.draw.uiAtDraw && appState.draw.uiAtDraw.scenario)
            ? appState.draw.uiAtDraw.scenario
            : getScenario();
          const rBase = roles[rid];
          const rOv = getScenarioConfig(scenario).roleOverrides?.[rid] ?? null;
          const r = rBase ? { ...rBase, ...(rOv || {}) } : null;
          const teamFa = r ? (r.teamFa || "Ø´Ù‡Ø±") : "Ø´Ù‡Ø±";
          const teamCls =
            teamFa === "Ù…Ø§ÙÛŒØ§" ? "team-mafia" :
            teamFa === "Ø´Ù‡Ø±" ? "team-city" : "team-ind";
          const rName = roleName(rid);
          const rDesc = roleDesc(rid, scenario);

          // Make "Role help" look like the role reveal card UI.
          openToolModal(t("common.roleHelp"), `
            <div class="roleCard roleReveal ${teamCls}">
              <div class="ricon" aria-hidden="true">${roleIconSvg(rid, teamFa)}</div>
              <div class="rname">${escapeHtml(rName)}</div>
              <div class="rteam">${escapeHtml(`${t("lifeSheet.team")}: ${teamLabel(teamFa)}`)}</div>
            </div>
            <div class="note roleRevealNote ${teamCls}">${escapeHtml(rDesc)}</div>
          `, { hideBottom: true });
        }

        function applyUIFromState() {
          appState.ui.scenario = sanitizeScenarioValue(appState.ui.scenario);
          $("scenario").value = appState.ui.scenario;
          fillPlayersSelect();
          $("playersCount").value = String(appState.ui.nPlayers);
          fillMafiaSelect(appState.ui.nPlayers, computeSuggestedMafia(appState.ui.nPlayers));
          $("mafiaCount").value = String(appState.ui.mafiaCount);

          const mafiaCount = parseInt($("mafiaCount").value, 10);
          const disableMafiaBoss = mafiaCount <= 0;
          const disableSwindler = mafiaCount <= 1; // need room for specials
          // scenario may have changed since last save; normalize then apply
          appState.ui.toggles = normalizeTogglesForScenario(appState.ui.toggles, $("scenario").value);
          applyToggles(appState.ui.toggles, { disableMafiaBoss, disableSwindler });
          applyScenarioAvailability($("scenario").value);

          renderNameGrid();
          setNamesMode(appState.ui.namesMode || "default");
          const dispN = (appLang === "fa" && typeof toFarsiNum === "function") ? toFarsiNum(appState.ui.nPlayers) : appState.ui.nPlayers;
          $("playersStat").textContent = (appLang === "fa")
            ? `Ø¨Ø§Ø²ÛŒÚ©Ù†: ${dispN}`
            : `Players: ${dispN}`;
        }

        function syncUIToState() {
          const s = readUIState();
          appState.ui = {
            scenario: sanitizeScenarioValue(s.scenario),
            nPlayers: s.nPlayers,
            mafiaCount: s.mafiaCount,
            toggles: s.toggles,
            playerNames: appState.ui.playerNames || [],
            namesMode: appState.ui.namesMode || "default",
            customized: !!(appState.ui && appState.ui.customized),
          };
        }

        function regenerateFromUI() {
          syncUIToState();
          saveState(appState);
          updateQuickStat();
        }

        let applyingScenarioDefaults = false;

        function scenarioHasDefaults(scenario) {
          // We support "reset to scenario defaults" for all known scenarios.
          return !!scenario;
        }
        function countEnabledToggles(toggles) {
          let n = 0;
          for (const def of toggleDefs) if (toggles && toggles[def.key]) n++;
          return n;
        }
        function countEnabledMafiaSpecials(toggles) {
          let n = 0;
          for (const def of toggleDefs) if (def.group === "mafia" && toggles && toggles[def.key]) n++;
          return n;
        }
        function computeScenarioDefaultCounts(scenario) {
          // Use explicit overrides if known; otherwise derive a reasonable default from the scenario's default roles.
          const d = getScenarioConfig(scenario).defaults || {};
          const defaultTog = normalizeTogglesForScenario(defaultTogglesForScenario(scenario), scenario);
          const enabled = countEnabledToggles(defaultTog);
          const mafiaSpecials = countEnabledMafiaSpecials(defaultTog);

          let nPlayers = (d.nPlayers != null)
            ? parseInt(d.nPlayers, 10)
            : clamp(enabled + 7, 5, 30); // enough room for base roles + some citizens/mafia

          // ensure mafia suggestion can accommodate mafia specials
          let mafiaCount = (d.mafiaCount != null)
            ? parseInt(d.mafiaCount, 10)
            : computeSuggestedMafia(nPlayers);

          // cap by UI max (can't be >= nPlayers)
          const maxMafia = Math.max(1, Math.floor((nPlayers - 1) / 2));
          mafiaCount = clamp(mafiaCount, 1, maxMafia);
          if (mafiaSpecials > mafiaCount) mafiaCount = mafiaSpecials;

          // If this config still fails due to too many roles, increase players until it fits (up to 30).
          while (nPlayers < 30) {
            const r = buildRolePool(nPlayers, mafiaCount, defaultTog);
            if (r.ok) break;
            nPlayers++;
            const maxM = Math.max(1, Math.floor((nPlayers - 1) / 2));
            mafiaCount = clamp(mafiaCount, 1, maxM);
          }
          return { nPlayers, mafiaCount, toggles: defaultTog };
        }

        function applyScenarioDefaults(scenario) {
          applyingScenarioDefaults = true;
          try {
            // Applying scenario defaults implies starting a fresh game.
            // Clear any saved/in-progress draw so "Ø§Ø¯Ø§Ù…Ù‡ Ø¨Ø§Ø²ÛŒ" disappears.
            appState.draw = null;
            if (appState.god) {
              appState.god.status = null;
              appState.god.lastMove = null;
              appState.god.timers = null;
              appState.god.chance = null;
            }

            const def = computeScenarioDefaultCounts(scenario);
            // players
            $("playersCount").value = String(clamp(parseInt(def.nPlayers, 10), 5, 30));
            const nPlayers = parseInt($("playersCount").value, 10);
            appState.ui.nPlayers = nPlayers;
            ensureNamesLength(nPlayers);
            renderNameGrid();

            // mafia count (rebuild dropdown based on players)
            fillMafiaSelect(nPlayers, computeSuggestedMafia(nPlayers));
            const maxM = parseInt($("mafiaCount").lastChild.value, 10);
            const desiredM = parseInt(def.mafiaCount, 10);
            $("mafiaCount").value = String(clamp(desiredM, 1, maxM));
            appState.ui.mafiaCount = parseInt($("mafiaCount").value, 10);

            // roles
            appState.ui.scenario = scenario;
            appState.ui.toggles = def.toggles;
            applyScenarioAvailability(scenario);
            const mafiaCount = parseInt($("mafiaCount").value, 10);
            applyToggles(appState.ui.toggles, { disableMafiaBoss: mafiaCount <= 0, disableSwindler: mafiaCount <= 1 });

            appState.ui.customized = false;
            regenerateFromUI();
            updateResumeUI();
          } finally {
            applyingScenarioDefaults = false;
          }
        }

        // Role icons (used in cast list + role reveal modal)
        // Kept inline so this stays a single-file app.
        const ROLE_ICON_PATHS = {
          user: `
            <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
            <path d="M8 7a4 4 0 1 0 8 0a4 4 0 0 0 -8 0"/>
            <path d="M6 21v-2a4 4 0 0 1 4 -4h4a4 4 0 0 1 4 4v2"/>
          `,
          gangster: `
            <path d="M14 18a2 2 0 0 0-4 0" stroke-width="1"/>
            <path d="m19 11-2.11-6.657a2 2 0 0 0-2.752-1.148l-1.276.61A2 2 0 0 1 12 4H8.5a2 2 0 0 0-1.925 1.456L5 11"/>
            <path d="M2 11h20"/>
            <!-- sunglasses (filled lenses) -->
            <rect x="3.8" y="14.2" width="7.4" height="5" rx="1.7" fill="currentColor" stroke="none"/>
            <rect x="12.8" y="14.2" width="7.4" height="5" rx="1.7" fill="currentColor" stroke="none"/>
          `,
          mask: `
            <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
            <path d="M9 12a3 3 0 1 0 6 0a3 3 0 1 0 -6 0"/>
            <path d="M4 6a2 2 0 0 1 2 -2h12a2 2 0 0 1 2 2v12a2 2 0 0 1 -2 2h-12a2 2 0 0 1 -2 -2l0 -12"/>
          `,
          crown: `
            <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
            <path d="M12 6l4 6l5 -4l-2 10h-14l-2 -10l5 4l4 -6"/>
          `,
          cards: `
            <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
            <path d="M3.604 7.197l7.138 -3.109a.96 .96 0 0 1 1.27 .527l4.924 11.902a1 1 0 0 1 -.514 1.304l-7.137 3.109a.96 .96 0 0 1 -1.271 -.527l-4.924 -11.903a1 1 0 0 1 .514 -1.304l0 .001"/>
            <path d="M15 4h1a1 1 0 0 1 1 1v3.5"/>
            <path d="M20 6c.264 .112 .52 .217 .768 .315a1 1 0 0 1 .53 1.311l-2.298 5.374"/>
          `,
          "heart-handshake": `
            <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
            <path d="M19.5 12.572l-7.5 7.428l-7.5 -7.428a5 5 0 1 1 7.5 -6.566a5 5 0 1 1 7.5 6.572"/>
            <path d="M12 6l-3.293 3.293a1 1 0 0 0 0 1.414l.543 .543c.69 .69 1.81 .69 2.5 0l1 -1a3.182 3.182 0 0 1 4.5 0l2.25 2.25"/>
            <path d="M12.5 15.5l2 2"/>
            <path d="M15 13l2 2"/>
          `,
          "microphone-off": `
            <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
            <path d="M3 3l18 18"/>
            <path d="M9 5a3 3 0 0 1 6 0v5a3 3 0 0 1 -.13 .874m-2 2a3 3 0 0 1 -3.87 -2.872v-1"/>
            <path d="M5 10a7 7 0 0 0 10.846 5.85m2 -2a6.967 6.967 0 0 0 1.152 -3.85"/>
            <path d="M8 21l8 0"/>
            <path d="M12 17l0 4"/>
          `,
          stethoscope: `
            <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
            <path d="M6 4h-1a2 2 0 0 0 -2 2v3.5a5.5 5.5 0 0 0 11 0v-3.5a2 2 0 0 0 -2 -2h-1"/>
            <path d="M8 15a6 6 0 1 0 12 0v-3"/>
            <path d="M11 3v2"/>
            <path d="M6 3v2"/>
            <path d="M18 10a2 2 0 1 0 4 0a2 2 0 1 0 -4 0"/>
          `,
          search: `
            <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
            <path d="M10 10m-7 0a7 7 0 1 0 14 0a7 7 0 1 0 -14 0"/>
            <path d="M21 21l-6 -6"/>
          `,
          detective: `
            <!-- hat -->
            <path d="M7 10.8v-2.5a3 3 0 0 1 3 -3h4a3 3 0 0 1 3 3v2.5" />
            <path d="M4.5 10.8c2.4 2.4 12.6 2.4 15 0" />
            <path d="M9 8.0h6" />
            <!-- magnifying glass -->
            <circle cx="10.6" cy="18.6" r="3.0" />
            <path d="M12.6 20.6L15.1 23.1" />
          `,
          "clipboard-search": `
            <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
            <path d="M9 5h-2a2 2 0 0 0 -2 2v12a2 2 0 0 0 2 2h4.5m7.5 -10v-4a2 2 0 0 0 -2 -2h-2"/>
            <path d="M9 5a2 2 0 0 1 2 -2h2a2 2 0 0 1 2 2a2 2 0 0 1 -2 2h-2a2 2 0 0 1 -2 -2"/>
            <path d="M18 18m-3 0a3 3 0 1 0 6 0a3 3 0 1 0 -6 0"/>
            <path d="M20.2 20.2l1.8 1.8"/>
          `,
          microscope: `
            <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
            <path d="M5 21h14"/>
            <path d="M6 18h2"/>
            <path d="M7 18v3"/>
            <path d="M9 11l3 3l6 -6l-3 -3l-6 6"/>
            <path d="M10.5 12.5l-1.5 1.5"/>
            <path d="M17 3l3 3"/>
            <path d="M12 21a6 6 0 0 0 3.715 -10.712"/>
          `,
          shield: `
            <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
            <path d="M12 3a12 12 0 0 0 8.5 3a12 12 0 0 1 -8.5 15a12 12 0 0 1 -8.5 -15a12 12 0 0 0 8.5 -3"/>
          `,
          crosshair: `
            <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
            <path d="M4 8v-2a2 2 0 0 1 2 -2h2"/>
            <path d="M4 16v2a2 2 0 0 0 2 2h2"/>
            <path d="M16 4h2a2 2 0 0 1 2 2v2"/>
            <path d="M16 20h2a2 2 0 0 0 2 -2v-2"/>
            <path d="M9 12l6 0"/>
            <path d="M12 9l0 6"/>
          `,
          news: `
            <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
            <path d="M16 6h3a1 1 0 0 1 1 1v11a2 2 0 0 1 -4 0v-13a1 1 0 0 0 -1 -1h-10a1 1 0 0 0 -1 1v12a3 3 0 0 0 3 3h11"/>
            <path d="M8 8l4 0"/>
            <path d="M8 12l4 0"/>
            <path d="M8 16l4 0"/>
          `,
          gavel: `
            <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
            <path d="M13 10l7.383 7.418c.823 .82 .823 2.148 0 2.967a2.11 2.11 0 0 1 -2.976 0l-7.407 -7.385"/>
            <path d="M6 9l4 4"/>
            <path d="M13 10l-4 -4"/>
            <path d="M3 21h7"/>
            <path d="M6.793 15.793l-3.586 -3.586a1 1 0 0 1 0 -1.414l2.293 -2.293l.5 .5l3 -3l-.5 -.5l2.293 -2.293a1 1 0 0 1 1.414 0l3.586 3.586a1 1 0 0 1 0 1.414l-2.293 2.293l-.5 -.5l-3 3l.5 .5l-2.293 2.293a1 1 0 0 1 -1.414 0"/>
          `,
          tag: `
            <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
            <path d="M6.5 7.5a1 1 0 1 0 2 0a1 1 0 1 0 -2 0"/>
            <path d="M3 6v5.172a2 2 0 0 0 .586 1.414l7.71 7.71a2.41 2.41 0 0 0 3.408 0l5.592 -5.592a2.41 2.41 0 0 0 0 -3.408l-7.71 -7.71a2 2 0 0 0 -1.414 -.586h-5.172a3 3 0 0 0 -3 3"/>
          `,
          cross: `
            <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
            <path d="M10 21h4v-9h5v-4h-5v-5h-4v5h-5v4h5l0 9"/>
          `,
          brain: `
            <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
            <path d="M15.5 13a3.5 3.5 0 0 0 -3.5 3.5v1a3.5 3.5 0 0 0 7 0v-1.8"/>
            <path d="M8.5 13a3.5 3.5 0 0 1 3.5 3.5v1a3.5 3.5 0 0 1 -7 0v-1.8"/>
            <path d="M17.5 16a3.5 3.5 0 0 0 0 -7h-.5"/>
            <path d="M19 9.3v-2.8a3.5 3.5 0 0 0 -7 0"/>
            <path d="M6.5 16a3.5 3.5 0 0 1 0 -7h.5"/>
            <path d="M5 9.3v-2.8a3.5 3.5 0 0 1 7 0v10"/>
          `,
          wand: `
            <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
            <path d="M6 21l15 -15l-3 -3l-15 15l3 3"/>
            <path d="M15 6l3 3"/>
            <path d="M9 3a2 2 0 0 0 2 2a2 2 0 0 0 -2 2a2 2 0 0 0 -2 -2a2 2 0 0 0 2 -2"/>
            <path d="M19 13a2 2 0 0 0 2 2a2 2 0 0 0 -2 2a2 2 0 0 0 -2 -2a2 2 0 0 0 2 -2"/>
          `,
          binoculars: `
            <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
            <path d="M4 16a3 3 0 1 0 6 0a3 3 0 1 0 -6 0"/>
            <path d="M14 16a3 3 0 1 0 6 0a3 3 0 1 0 -6 0"/>
            <path d="M16.346 9.17l-.729 -1.261c-.16 -.248 -1.056 -.203 -1.117 .091l-.177 1.38"/>
            <path d="M19.761 14.813l-2.84 -5.133c-.189 -.31 -.592 -.68 -1.421 -.68c-.828 0 -1.5 .448 -1.5 1v6"/>
            <path d="M7.654 9.17l.729 -1.261c.16 -.249 1.056 -.203 1.117 .091l.177 1.38"/>
            <path d="M4.239 14.813l2.84 -5.133c.189 -.31 .592 -.68 1.421 -.68c.828 0 1.5 .448 1.5 1v6"/>
            <path d="M10 12h4v2h-4l0 -2"/>
          `,
          link: `
            <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
            <path d="M9 15l6 -6"/>
            <path d="M11 6l.463 -.536a5 5 0 0 1 7.071 7.072l-.534 .464"/>
            <path d="M13 18l-.397 .534a5.068 5.068 0 0 1 -7.127 0a4.972 4.972 0 0 1 0 -7.071l.524 -.463"/>
          `,
          leaf: `
            <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
            <path d="M5 21c.5 -4.5 2.5 -8 7 -10"/>
            <path d="M9 18c6.218 0 10.5 -3.288 11 -12v-2h-4.014c-9 0 -11.986 4 -12 9c0 1 0 3 2 5h3l.014 0"/>
          `,
          "user-question": `
            <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
            <path d="M8 7a4 4 0 1 0 8 0a4 4 0 0 0 -8 0"/>
            <path d="M6 21v-2a4 4 0 0 1 4 -4h3.5"/>
            <path d="M19 22v.01"/>
            <path d="M19 19a2.003 2.003 0 0 0 .914 -3.782a1.98 1.98 0 0 0 -2.414 .483"/>
          `,
          bomb: `
            <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
            <path d="M15.349 5.349l3.301 3.301a1.2 1.2 0 0 1 0 1.698l-.972 .972a7.5 7.5 0 1 1 -5 -5l.972 -.972a1.2 1.2 0 0 1 1.698 0l.001 .001"/>
            <path d="M17 7l1.293 -1.293a2.414 2.414 0 0 0 .707 -1.707a1 1 0 0 1 1 -1h1"/>
            <path d="M7 13a3 3 0 0 1 3 -3"/>
          `,
          "moon-stars": `
            <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
            <path d="M12 3c.132 0 .263 0 .393 0a7.5 7.5 0 0 0 7.92 12.446a9 9 0 1 1 -8.313 -12.454l0 .008"/>
            <path d="M17 4a2 2 0 0 0 2 2a2 2 0 0 0 -2 2a2 2 0 0 0 -2 -2a2 2 0 0 0 2 -2"/>
            <path d="M19 11h2m-1 -1v2"/>
          `,
          "heart-plus": `
            <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
            <path d="M12 20l-7.5 -7.428a5 5 0 1 1 7.5 -6.566a5 5 0 1 1 7.96 6.053"/>
            <path d="M16 19h6"/>
            <path d="M19 16v6"/>
          `,
          eye: `
            <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
            <path d="M10 12a2 2 0 1 0 4 0a2 2 0 0 0 -4 0"/>
            <path d="M21 12c-2.4 4 -5.4 6 -9 6c-3.6 0 -6.6 -2 -9 -6c2.4 -4 5.4 -6 9 -6c3.6 0 6.6 2 9 6"/>
          `,
          "crystal-ball": `
            <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
            <path d="M6.73 17.018a8 8 0 1 1 10.54 0"/>
            <path d="M5 19a2 2 0 0 0 2 2h10a2 2 0 1 0 0 -4h-10a2 2 0 0 0 -2 2"/>
            <path d="M11 7a3 3 0 0 0 -3 3"/>
          `,
          target: `
            <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
            <path d="M11 12a1 1 0 1 0 2 0a1 1 0 1 0 -2 0"/>
            <path d="M7 12a5 5 0 1 0 10 0a5 5 0 1 0 -10 0"/>
            <path d="M3 12a9 9 0 1 0 18 0a9 9 0 1 0 -18 0"/>
          `,
          ban: `
            <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
            <path d="M3 12a9 9 0 1 0 18 0a9 9 0 1 0 -18 0"/>
            <path d="M5.7 5.7l12.6 12.6"/>
          `,
          skull: `
            <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
            <path d="M12 4c4.418 0 8 3.358 8 7.5c0 1.901 -.755 3.637 -2 4.96l0 2.54a1 1 0 0 1 -1 1h-10a1 1 0 0 1 -1 -1v-2.54c-1.245 -1.322 -2 -3.058 -2 -4.96c0 -4.142 3.582 -7.5 8 -7.5"/>
            <path d="M10 17v3"/>
            <path d="M14 17v3"/>
            <path d="M8 11a1 1 0 1 0 2 0a1 1 0 1 0 -2 0"/>
            <path d="M14 11a1 1 0 1 0 2 0a1 1 0 1 0 -2 0"/>
          `,
          sword: `
            <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
            <path d="M20 4v5l-9 7l-4 4l-3 -3l4 -4l7 -9l5 0"/>
            <path d="M6.5 11.5l6 6"/>
          `,
          "masks-theater": `
            <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
            <path d="M13.192 9h6.616a2 2 0 0 1 1.992 2.183l-.567 6.182a4 4 0 0 1 -3.983 3.635h-1.5a4 4 0 0 1 -3.983 -3.635l-.567 -6.182a2 2 0 0 1 1.992 -2.183"/>
            <path d="M15 13h.01"/>
            <path d="M18 13h.01"/>
            <path d="M15 16.5c1 .667 2 .667 3 0"/>
            <path d="M8.632 15.982a4.037 4.037 0 0 1 -.382 .018h-1.5a4 4 0 0 1 -3.983 -3.635l-.567 -6.182a2 2 0 0 1 1.992 -2.183h6.616a2 2 0 0 1 2 2"/>
            <path d="M6 8h.01"/>
            <path d="M9 8h.01"/>
            <path d="M6 12c.764 -.51 1.528 -.63 2.291 -.36"/>
          `,
          briefcase: `
            <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
            <path d="M3 9a2 2 0 0 1 2 -2h14a2 2 0 0 1 2 2v9a2 2 0 0 1 -2 2h-14a2 2 0 0 1 -2 -2l0 -9"/>
            <path d="M8 7v-2a2 2 0 0 1 2 -2h4a2 2 0 0 1 2 2v2"/>
            <path d="M12 12l0 .01"/>
            <path d="M3 13a20 20 0 0 0 18 0"/>
          `,
          building: `
            <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
            <path d="M3 21l18 0"/>
            <path d="M9 8l1 0"/>
            <path d="M9 12l1 0"/>
            <path d="M9 16l1 0"/>
            <path d="M14 8l1 0"/>
            <path d="M14 12l1 0"/>
            <path d="M14 16l1 0"/>
            <path d="M5 21v-16a2 2 0 0 1 2 -2h10a2 2 0 0 1 2 2v16"/>
          `,
        };

        function roleIconKey(roleId, teamFa) {
          const rid = (roleId || "").toString();
          const map = {
            // base
            citizen: "user",
            mafia: "gangster",

            // classic / general (mafia)
            mafiaBoss: "crown",
            godfather: "crown",
            swindler: "masks-theater",
            nato: "target",
            negotiator: "heart-handshake",
            natasha: "microphone-off",
            doctorLecter: "stethoscope",
            jokerMafia: "cards",
            matador: "ban",
            saulGoodman: "briefcase",

            // classic / general (city)
            detective: "detective",
            investigator: "clipboard-search",
            doctor: "stethoscope",
            watson: "stethoscope",
            researcher: "microscope",
            invulnerable: "shield",
            armored: "shield",
            sniper: "crosshair",
            professional: "crosshair",
            reporter: "news",
            representative: "building",
            hardJohn: "shield",
            psychologist: "brain",
            mayor: "building",
            seller: "tag",
            priest: "cross",
            judge: "gavel",
            commander: "building",

            // Capo (Ú©Ø§Ù¾Ùˆ/Ø¯Ù†)
            danMafia: "crown",
            witch: "wand",
            executioner: "sword",
            informant: "binoculars",
            kadkhoda: "link",
            heir: "crown",
            herbalist: "leaf",
            armorsmith: "shield",
            suspect: "user-question",

            // Zodiac
            alcapone: "crown",
            zodiac: "skull",
            magician: "masks-theater",
            bomber: "bomb",
            guard: "shield",
            ocean: "moon-stars",
            gunslinger: "crosshair",

            // Godfather (game)
            leon: "crosshair",
            constantine: "heart-plus",
            citizenKane: "eye",
            nostradamus: "crystal-ball",

            // Representative (Ù†Ù…Ø§ÛŒÙ†Ø¯Ù‡)
            don: "crown",
            rebel: "sword",
            hacker: "ban",
            guide: "search",
            minemaker: "bomb",
            lawyer: "briefcase",
            bodyguard: "shield",
          };

          if (map[rid]) return map[rid];
          if (teamFa === "Ù…Ø§ÙÛŒØ§") return "mask";
          if (teamFa === "Ø´Ù‡Ø±") return "user";
          return "skull";
        }

        function roleIconSvg(roleId, teamFa) {
          const key = roleIconKey(roleId, teamFa);
          const inner = ROLE_ICON_PATHS[key] || ROLE_ICON_PATHS.user;
          return `
            <svg viewBox="0 0 24 24" aria-hidden="true" focusable="false"
                 fill="none" stroke="currentColor" stroke-width="2"
                 stroke-linecap="round" stroke-linejoin="round">
              ${inner}
            </svg>
          `.trim();
        }

        function openRoleModal({ who, roleId, onConfirm }) {
          const scenario = (appState.draw && appState.draw.uiAtDraw && appState.draw.uiAtDraw.scenario)
            ? appState.draw.uiAtDraw.scenario
            : getScenario();
          const rBase = roles[roleId];
          const rOv = getScenarioConfig(scenario).roleOverrides?.[roleId] ?? null;
          const r = rBase ? { ...rBase, ...(rOv || {}) } : null;
          const teamFa = r ? (r.teamFa || "Ø´Ù‡Ø±") : "Ø´Ù‡Ø±";
          const teamCls =
            teamFa === "Ù…Ø§ÙÛŒØ§" ? "team-mafia" :
            teamFa === "Ø´Ù‡Ø±" ? "team-city" : "team-ind";
          $("modalWho").textContent = who;
          $("roleName").textContent = roleName(roleId);
          $("roleTeam").textContent = r ? `${t("lifeSheet.team")}: ${teamLabel(teamFa)}` : "â€”";

          // apply team tint classes
          const rc = $("roleCard");
          const noteEl = $("modalNote");
          rc.classList.remove("team-mafia", "team-city", "team-ind");
          noteEl.classList.remove("team-mafia", "team-city", "team-ind");
          rc.classList.add(teamCls);
          noteEl.classList.add(teamCls);

          // role icon
          const iconEl = $("roleIcon");
          if (iconEl) iconEl.innerHTML = roleIconSvg(roleId, teamFa);

          // show role description in the note area (per request)
          noteEl.textContent = roleDesc(roleId, scenario);
          noteEl.classList.remove("collapsed");

          // keep the help button; it toggles showing/hiding the description
          const helpBtn = $("roleHelpBtn");
          helpBtn.onclick = (e) => {
            if (e && e.stopPropagation) e.stopPropagation();
            openRoleHelpOverlay(roleId);
          };

          // keep roleDesc hidden (legacy element)
          const descEl = $("roleDesc");
          descEl.textContent = "";
          descEl.classList.add("collapsed");

          $("markRevealedBtn").onclick = () => {
            if (typeof onConfirm === "function") onConfirm();
            closeModal();
          };
          openModal();
        }

        function startDeal() {
          const s = readUIState();
          const res = buildRolePool(s.nPlayers, s.mafiaCount, s.toggles);
          if (!res.ok) {
            setError(res.error);
            return false;
          }
          const names = readNamesFromInputs();
          const repeated = getFirstRepeatedName(names);
          if (repeated) {
            setError(t("error.duplicateName", { name: repeated }));
            return false;
          }
          appState.ui.playerNames = names;
          saveLastNames(names);
          setError("");
          syncUIToState();
          ensureNamesLength(appState.ui.nPlayers);

          const deck = res.pool.slice(); // already shuffled
          const n = deck.length;
          appState.draw = {
            deck,
            usedCards: Array(n).fill(false),
            players: Array(n).fill(0).map(() => ({ roleId: null, revealed: false, cardIdx: null, alive: true, deathReason: null })),
            currentIdx: 0,
            createdAt: Date.now(),
            uiAtDraw: { ...appState.ui, mode: "cards" },
          };
          saveState(appState);
          renderCards();
          showCards();
          return true;
        }

        function onPickCard(cardIdx) {
          const draw = appState.draw;
          if (!draw || !draw.deck || !draw.players) return;
          const n = draw.players.length;
          const cur = draw.currentIdx || 0;
          if (cur >= n) return;
          if (draw.usedCards && draw.usedCards[cardIdx]) return;

          const who = (appState.ui.playerNames && appState.ui.playerNames[cur]) ? appState.ui.playerNames[cur] : `Ø¨Ø§Ø²ÛŒÚ©Ù† ${cur + 1}`;
          const roleId = draw.deck[cardIdx];

          // Record the pick immediately (no need to click "Seen").
          draw.usedCards[cardIdx] = true;
          const prev = draw.players[cur] || {};
          draw.players[cur] = { ...prev, roleId, revealed: true, cardIdx, alive: prev.alive !== false, deathReason: prev.deathReason || null };
          draw.currentIdx = cur + 1;
          saveState(appState);
          renderCards();

          openRoleModal({
            who,
            roleId,
            onConfirm: null,
          });
        }

        function autoAssignAllRemaining() {
          const draw = appState.draw;
          if (!draw || !draw.deck || !draw.players || !draw.usedCards) return;
          const n = draw.players.length;
          let cur = draw.currentIdx || 0;
          if (cur >= n) {
            renderCards();
            return;
          }

          const remainingCardIdxs = [];
          for (let i = 0; i < n; i++) {
            if (!draw.usedCards[i]) remainingCardIdxs.push(i);
          }
          shuffle(remainingCardIdxs);

          while (cur < n && remainingCardIdxs.length) {
            const cardIdx = remainingCardIdxs.shift();
            const roleId = draw.deck[cardIdx];
            draw.usedCards[cardIdx] = true;
            const prev = draw.players[cur] || {};
            draw.players[cur] = {
              ...prev,
              roleId,
              revealed: true,
              cardIdx,
              alive: prev.alive !== false,
              deathReason: prev.deathReason || null,
            };
            cur++;
          }

          draw.currentIdx = n;
          saveState(appState);
          renderCards();
        }

        function setPlayerLife(idx, { alive, reason }) {
          const draw = appState.draw;
          if (!draw || !draw.players || !draw.players[idx]) return;
          draw.players[idx].alive = !!alive;
          draw.players[idx].deathReason = alive ? null : (reason || "vote");
          // Track when a player died so Night UI can distinguish:
          // - dead before tonight (should not act)
          // - killed this night (pending until dawn; can still act tonight)
          try {
            if (appState.god && appState.god.flow) {
              const f = ensureFlow();
              const d = f.draft || {};
              if (!d.deadAtByIdx || typeof d.deadAtByIdx !== "object") d.deadAtByIdx = {};
              if (alive) {
                delete d.deadAtByIdx[String(idx)];
              } else {
                d.deadAtByIdx[String(idx)] = {
                  day: Number(f.day || 1),
                  phase: String(f.phase || "day"),
                  reason: String(reason || "vote"),
                  at: Date.now(),
                };
              }
              f.draft = d;
            }
          } catch {}
          syncGodStatusFromPlayers();
          saveState(appState);
        }

        function openPlayerLifeSheet(idx) {
          const draw = appState.draw;
          if (!draw || !draw.players || !draw.players[idx]) return;
          const p = draw.players[idx];
          const name = (appState.ui.playerNames && appState.ui.playerNames[idx]) ? appState.ui.playerNames[idx] : t("common.playerN", { n: idx + 1 });
          const rid = p.roleId || "citizen";
          const scenario = (appState.draw && appState.draw.uiAtDraw && appState.draw.uiAtDraw.scenario)
            ? appState.draw.uiAtDraw.scenario
            : getScenario();
          const rBase = roles[rid];
          const rOv = getScenarioConfig(scenario).roleOverrides?.[rid] ?? null;
          const r = rBase ? { ...rBase, ...(rOv || {}) } : null;
          const teamFa = r ? (r.teamFa || "Ø´Ù‡Ø±") : "Ø´Ù‡Ø±";
          const alive = p.alive !== false;
          const reason = p.deathReason || null;

          const statusText = alive
            ? t("lifeSheet.alive")
            : t("lifeSheet.dead");
          const teamCls =
            teamFa === "Ù…Ø§ÙÛŒØ§" ? "team-mafia" :
            teamFa === "Ø´Ù‡Ø±" ? "team-city" : "team-ind";
          const desc = roleDesc(rid, scenario);

          openToolModal(t("lifeSheet.title"), `
            <div class="toolBox lifeSheet ${teamCls}">
              <div class="lifeIcon" aria-hidden="true">${roleIconSvg(rid, teamFa)}</div>
              <div class="lifeName">${escapeHtml(name)}</div>
              <div class="lifeMeta">
                <span class="k">${escapeHtml(t("lifeSheet.role"))}:</span> ${escapeHtml(roleName(rid))}
                &nbsp;â€¢&nbsp;
                <span class="k">${escapeHtml(t("lifeSheet.team"))}:</span> ${escapeHtml(teamLabel(teamFa))}
                &nbsp;â€¢&nbsp;
                <span class="k">${escapeHtml(t("lifeSheet.status"))}:</span> <b>${escapeHtml(statusText)}</b>
              </div>
              <div style="height:10px"></div>
              <div class="note roleRevealNote ${teamCls}">${escapeHtml(desc)}</div>
              <div style="height:10px"></div>
              <div class="lifeActions">
                <button class="btn lifeActionBtn is-danger" id="life_shot" type="button">${escapeHtml(t("lifeSheet.actionShot"))}</button>
                <button class="btn lifeActionBtn is-ok" id="life_revive" type="button">${escapeHtml(t("lifeSheet.actionRevive"))}</button>
              </div>
            </div>
          `, { hideBottom: true });

          $("life_shot").onclick = () => { setPlayerLife(idx, { alive: false, reason: "shot" }); renderCast(); closeToolModal(); };
          $("life_revive").onclick = () => { setPlayerLife(idx, { alive: true }); renderCast(); closeToolModal(); };
        }

        function renderCast() {
          const draw = appState.draw;
          if (!draw) return;
          const pending = (() => {
            try {
              const f = (appState.god && appState.god.flow) ? ensureFlow() : null;
              if (!f || f.phase !== "night") return {};
              const ev = (f.events || []).slice().reverse().find((e) => e && e.kind === "night_actions" && e.phase === "night" && e.day === f.day && e.data);
              const payload0 = ev && ev.data ? { ...ev.data } : null;
              if (!payload0) return {};
              const idxFrom = (v) => {
                const n = parseInt(String(v ?? "").trim(), 10);
                if (!Number.isFinite(n)) return null;
                if (!draw.players) return n;
                if (n < 0 || n >= draw.players.length) return null;
                return n;
              };
              const findIdxByRole = (roleIds) => {
                const ids = Array.isArray(roleIds) ? roleIds : [roleIds];
                for (let i = 0; i < (draw.players || []).length; i++) {
                  const p = draw.players[i];
                  if (!p) continue;
                  if (ids.includes(p.roleId)) return i;
                }
                return null;
              };
              // Apply disable tonight (Magician) for pending computation
              const disabledIdx = idxFrom(payload0.magicianDisable);
              const doctorIdx = findIdxByRole(["doctor", "watson", "doctorLecter"]);
              const detIdx = findIdxByRole(["detective"]);
              const proIdx = findIdxByRole(["professional", "leon"]);
              const bomberIdx = findIdxByRole(["bomber"]);
              const oceanIdx = findIdxByRole(["ocean"]);
              const zodiacIdx = findIdxByRole(["zodiac"]);
              if (disabledIdx !== null) {
                if (doctorIdx !== null && disabledIdx === doctorIdx) payload0.doctorSave = null;
                if (detIdx !== null && disabledIdx === detIdx) payload0.detectiveQuery = null;
                if (proIdx !== null && disabledIdx === proIdx) payload0.professionalShot = null;
                if (bomberIdx !== null && disabledIdx === bomberIdx) { payload0.bombTarget = null; payload0.bombCode = null; }
                if (oceanIdx !== null && disabledIdx === oceanIdx) payload0.oceanWake = null;
                if (zodiacIdx !== null && disabledIdx === zodiacIdx) payload0.zodiacShot = null;
              }

              const out = {};
              // Mafia pending kill (if not saved by doctor or Dr. Lecter, and not immune)
              const mafiaShot = idxFrom(payload0.mafiaShot);
              const doctorSave = idxFrom(payload0.doctorSave);
              const lecterSave = idxFrom(payload0.lecterSave);
              if (mafiaShot !== null) {
                const mafiaTargetRole = (draw.players[mafiaShot] && draw.players[mafiaShot].roleId) ? draw.players[mafiaShot].roleId : "citizen";
                const mafiaTargetImmune = (mafiaTargetRole === "zodiac" || mafiaTargetRole === "invulnerable" || mafiaTargetRole === "armored");
                const mafiaTargetSaved = (doctorSave !== null && doctorSave === mafiaShot) || (lecterSave !== null && lecterSave === mafiaShot);
                if (!mafiaTargetImmune && !mafiaTargetSaved) {
                  out[mafiaShot] = "mafia";
                }
              }
              // Professional pending kill
              const proShot = idxFrom(payload0.professionalShot);
              if (proIdx !== null && proShot !== null) {
                const tr = (draw.players[proShot] && draw.players[proShot].roleId) ? draw.players[proShot].roleId : "citizen";
                const teamFa = (roles[tr] && roles[tr].teamFa) ? roles[tr].teamFa : "Ø´Ù‡Ø±";
                if (tr === "zodiac") {
                  // no effect
                } else if (teamFa === "Ù…Ø§ÙÛŒØ§") {
                  out[proShot] = "pro";
                } else {
                  out[proIdx] = "pro_self";
                }
              }
              // Ocean pending self-death
              try {
                const oceanWake = (() => {
                  const v = payload0.oceanWake;
                  const arr = Array.isArray(v) ? v : (v === null || v === undefined ? [] : [v]);
                  return arr.map((x) => idxFrom(x)).filter((x) => x !== null);
                })();
                if (oceanIdx !== null && oceanWake.length) {
                  const bad = oceanWake.some((i) => {
                    const rid = (draw.players[i] && draw.players[i].roleId) ? draw.players[i].roleId : "citizen";
                    const teamFa = (roles[rid] && roles[rid].teamFa) ? roles[rid].teamFa : "Ø´Ù‡Ø±";
                    return teamFa === "Ù…Ø§ÙÛŒØ§" || rid === "zodiac";
                  });
                  if (bad) out[oceanIdx] = "ocean";
                }
              } catch {}
              // Sniper pending kill
              try {
                const sniperIdx = findIdxByRole(["sniper"]);
                if (disabledIdx !== null && sniperIdx !== null && disabledIdx === sniperIdx) payload0.sniperShot = null;
                const sniperShot = idxFrom(payload0.sniperShot);
                if (sniperIdx !== null && sniperShot !== null) {
                  const tr = (draw.players[sniperShot] && draw.players[sniperShot].roleId) ? draw.players[sniperShot].roleId : "citizen";
                  const teamFa = (roles[tr] && roles[tr].teamFa) ? roles[tr].teamFa : "Ø´Ù‡Ø±";
                  if (tr === "zodiac") {
                    // no effect
                  } else if (teamFa === "Ù…Ø§ÙÛŒØ§") {
                    out[sniperShot] = "sniper";
                  } else {
                    out[sniperIdx] = "sniper_self";
                  }
                }
              } catch {}
              // Zodiac pending kill
              try {
                if (zodiacIdx !== null) {
                  const zodiacShot = idxFrom(payload0.zodiacShot);
                  if (zodiacShot !== null) {
                    const tr = (draw.players[zodiacShot] && draw.players[zodiacShot].roleId) ? draw.players[zodiacShot].roleId : "citizen";
                    if (tr === "guard") {
                      out[zodiacIdx] = "zodiac_self";
                    } else {
                      out[zodiacShot] = "zodiac";
                    }
                  }
                }
              } catch {}
              // Herbalist pending kill (poison from previous night, no antidote given yet)
              try {
                const d = f.draft;
                const prevNightKey = String((f.day || 1) - 1);
                const prevActions = (d && d.nightActionsByNight && d.nightActionsByNight[prevNightKey]) ? d.nightActionsByNight[prevNightKey] : null;
                const prevPoisonRaw = prevActions ? prevActions.herbalistPoison : null;
                const prevPoison = (prevPoisonRaw !== null && prevPoisonRaw !== undefined && Number.isFinite(parseInt(prevPoisonRaw, 10)))
                  ? parseInt(prevPoisonRaw, 10) : null;
                if (prevPoison !== null) {
                  const haRaw = payload0.herbalistAntidote;
                  const antidoteGiven = (haRaw !== null && haRaw !== undefined &&
                    Number.isFinite(parseInt(haRaw, 10)) && parseInt(haRaw, 10) === prevPoison);
                  if (!antidoteGiven) {
                    out[prevPoison] = "herbalist";
                  }
                }
              } catch {}
              return out;
            } catch {
              return {};
            }
          })();
          const mafiaHost = $("castMafia");
          const cityHost = $("castCity");
          const indHost = $("castInd");
          mafiaHost.innerHTML = "";
          cityHost.innerHTML = "";
          if (indHost) indHost.innerHTML = "";

          const statusMods = (() => {
            try {
              const f = (appState.god && appState.god.flow) ? ensureFlow() : null;
              if (!f || !f.draft) return { handcuffed: new Set(), silenced: new Set(), bewitched: new Set() };
              const d = f.draft;
              const dayKey = String(f.day || 1);
              const handcuffed = new Set();
              const silenced = new Set();
              const bewitched = new Set();
              if (f.phase === "night" && d.handcuffedByDay && d.handcuffedByDay[dayKey] != null) {
                const h = parseInt(d.handcuffedByDay[dayKey], 10);
                if (Number.isFinite(h)) handcuffed.add(h);
              }
              if (f.phase === "day" && d.silencedByDay && Array.isArray(d.silencedByDay[dayKey])) {
                for (const i of d.silencedByDay[dayKey]) {
                  const n = parseInt(i, 10);
                  if (Number.isFinite(n)) silenced.add(n);
                }
              }
              if (f.phase === "night" && typeof getDrawScenarioForFlow === "function" && getDrawScenarioForFlow() === "kabo") {
                const na = (d.nightActionsByNight && d.nightActionsByNight[dayKey]) ? d.nightActionsByNight[dayKey] : null;
                const wt = (na && na.witchTarget != null && Number.isFinite(parseInt(na.witchTarget, 10))) ? parseInt(na.witchTarget, 10) : null;
                if (wt !== null && draw.players && draw.players[wt]) bewitched.add(wt);
              }
              return { handcuffed, silenced, bewitched };
            } catch { return { handcuffed: new Set(), silenced: new Set(), bewitched: new Set() }; }
          })();

          const entries = draw.players.map((p, idx) => {
            const rid = p.roleId || "citizen";
            const r = roles[rid];
            const name = (appState.ui.playerNames && appState.ui.playerNames[idx]) ? appState.ui.playerNames[idx] : t("common.playerN", { n: idx + 1 });
            const alive = p.alive !== false;
            const deathReason = p.deathReason || null;
            const isHandcuffed = statusMods.handcuffed.has(idx);
            const isSilenced = statusMods.silenced.has(idx);
            const isBewitched = statusMods.bewitched && statusMods.bewitched.has(idx);
            return { idx, name, roleId: rid, team: r ? r.teamFa : "Ø´Ù‡Ø±", alive, deathReason, isHandcuffed, isSilenced, isBewitched };
          });
          const mafia = entries.filter((e) => e.team === "Ù…Ø§ÙÛŒØ§");
          const city = entries.filter((e) => e.team === "Ø´Ù‡Ø±");
          const indep = entries.filter((e) => e.team !== "Ù…Ø§ÙÛŒØ§" && e.team !== "Ø´Ù‡Ø±");

          // Sort within each team by role importance (lower = higher priority).
          // Ties are resolved by original seat/order (idx).
          const byRankThenIdx = (a, b) => (roleRank(a.roleId) - roleRank(b.roleId)) || (a.idx - b.idx);
          mafia.sort(byRankThenIdx);
          city.sort(byRankThenIdx);
          indep.sort(byRankThenIdx);


          function rowHtml(e) {
            const stText = e.alive
              ? t("lifeSheet.alive")
              : t("lifeSheet.dead");
            const stCls = e.alive ? "alive" : "dead";
            const pendingTxt = (appLang === "fa") ? "Ø¯Ø± Ø§Ù†ØªØ¸Ø§Ø± ØµØ¨Ø­" : "pending";
            const isPending = !!(e.alive && pending && pending[e.idx]);
            const teamCls =
              e.team === "Ù…Ø§ÙÛŒØ§" ? "team-mafia" :
              e.team === "Ø´Ù‡Ø±" ? "team-city" : "team-ind";
            const modPills = [];
            if (e.isHandcuffed) modPills.push(`<div class="statusPill handcuffed">${escapeHtml(t("lifeSheet.handcuffed"))}</div>`);
            if (e.isSilenced) modPills.push(`<div class="statusPill silent">${escapeHtml(t("lifeSheet.silent"))}</div>`);
            if (e.isBewitched) modPills.push(`<div class="statusPill bewitched">${escapeHtml(t("lifeSheet.bewitched"))}</div>`);
            return `
              <div class="castRow ${e.alive ? "" : "dead"} ${teamCls}" data-idx="${e.idx}">
                <div class="leftMeta">
                  <div class="castName">${escapeHtml(e.name)}</div>
                  <div style="display:flex; gap:6px; align-items:center; justify-content:flex-end; flex-wrap:wrap">
                    ${!isPending ? `<div class="statusPill ${stCls}">${escapeHtml(stText)}</div>` : ``}
                    ${isPending ? `<div class="statusPill pending">${escapeHtml(pendingTxt)}</div>` : ``}
                    ${modPills.join("")}
                  </div>
                </div>
                <div class="who">
                  <div class="avatar">${roleIconSvg(e.roleId, e.team)}</div>
                  <div class="role">${escapeHtml(roleName(e.roleId))}</div>
                </div>
              </div>
            `;
          }

          if (!mafia.length) mafiaHost.innerHTML = `<div class="castRow team-mafia"><div>â€”</div><div class="who"><div class="avatar">${roleIconSvg("none_mafia", "Ù…Ø§ÙÛŒØ§")}</div><div class="role">${escapeHtml(t("cast.noneMafia"))}</div></div></div>`;
          else mafiaHost.innerHTML = mafia.map(rowHtml).join("");

          if (!city.length) cityHost.innerHTML = `<div class="castRow team-city"><div>â€”</div><div class="who"><div class="avatar">${roleIconSvg("none_city", "Ø´Ù‡Ø±")}</div><div class="role">${escapeHtml(t("cast.noneCity"))}</div></div></div>`;
          else cityHost.innerHTML = city.map(rowHtml).join("");

          if (indHost) {
            indHost.style.display = indep.length ? "block" : "none";
            if (indep.length) indHost.innerHTML = indep.map(rowHtml).join("");
          }


          // click-to-set life status
          document.querySelectorAll("#castCard .castRow[data-idx]").forEach((el) => {
            el.addEventListener("click", () => {
              const idx = parseInt(el.getAttribute("data-idx"), 10);
              openPlayerLifeSheet(idx);
            });
          });

          // keep GOD status in sync
          syncGodStatusFromPlayers();
        }

        function resetAll() {
          // stop any running timers / close overlays
          try { stopTimerInterval(); } catch {}
          try { closeModal(); } catch {}
          try { closeToolModal(); } catch {}

          appState = {
            ui: {
              scenario: "classic",
              nPlayers: 10,
              mafiaCount: 3,
              toggles: defaultTogglesForScenario("classic"),
              playerNames: [],
              customized: false,
              namesMode: (function () {
                const last = loadLastNames();
                return (last && last.some((x) => String(x || "").trim())) ? "last" : "default";
              })(),
            },
            draw: null,
            god: {
              status: null,
              lastMove: null,
              timers: null,
              chance: null,
            },
          };
          clearState();
          applyUIFromState();
          updateQuickStat();
          showSetup();
          setError("");
          updateResumeUI();
        }

        function showHelp() {
          showScenarioGuide(getScenario());
        }

        function hasSavedGame() {
          return !!(appState.draw && appState.draw.players && appState.draw.players.length);
        }

        function clearSavedGameOnly() {
          appState.draw = null;
          if (appState.god) {
            appState.god.status = null;
            appState.god.lastMove = null;
            appState.god.timers = null;
            appState.god.chance = null;
          }
          saveState(appState);
          updateResumeUI();
        }

        function updateResumeUI() {
          const btn = $("resumeBtn");
          if (btn) btn.style.display = "none"; // legacy/hidden

          const row = $("savedGameBarRow");
          const has = hasSavedGame();
          if (row) row.style.display = has ? "grid" : "none";
        }

        function resumeGame() {
          if (!appState.draw || !appState.draw.players || !appState.draw.players.length) return;
          const mode = (appState.draw.uiAtDraw && appState.draw.uiAtDraw.mode) ? appState.draw.uiAtDraw.mode : null;
          if (mode === "cards") {
            const draw = appState.draw;
            const n = draw.players.length;
            const cur = draw.currentIdx || 0;
            const done = cur >= n;
            if (!done) {
              renderCards();
              showCards();
              return;
            }
            // If dealing is finished, resume to the final cast list (names + roles).
            renderCast();
            showCast();
            return;
          }
          // fallback
          renderCast();
          showCast();
        }

        // --- wire up ---
        renderToggles();
        fillPlayersSelect();

        // load saved
        const saved = loadState();
        if (saved && typeof saved === "object") {
          // merge lightly (avoid breaking on partial state)
          appState.ui = { ...appState.ui, ...(saved.ui || {}) };
          appState.draw = saved.draw || null;
          // IMPORTANT: restore GOD recorded state too (flow, timers, etc.)
          // Without this, clicking "Ø§Ø¯Ø§Ù…Ù‡ Ø¨Ø§Ø²ÛŒ" appears to wipe recorded flow.
          if (saved.god && typeof saved.god === "object") {
            appState.god = { ...appState.god, ...saved.god };
          }
          // drop incompatible older saved games
          if (
            appState.draw &&
            (!Array.isArray(appState.draw.deck) ||
              !Array.isArray(appState.draw.players) ||
              !Array.isArray(appState.draw.usedCards))
          ) {
            appState.draw = null;
          }
          setSaveState(true);
        } else {
          setSaveState(false);
        }

        // language init (persisted)
        try {
          const savedLang = (shouldPersist() ? (localStorage.getItem(LANG_KEY) || "fa") : "fa");
          setLanguage(savedLang === "en" ? "en" : "fa");
        } catch {
          try { setLanguage("fa"); } catch {}
        }

        // initial UI
        applyUIFromState();
        updateQuickStat();
        showSetup();
        updateResumeUI();

        $("langChip").addEventListener("click", toggleLanguage);
        $("langChip").addEventListener("keydown", (e) => {
          if (e.key === "Enter" || e.key === " ") toggleLanguage();
        });
        $("langBtn").addEventListener("click", (e) => {
          e.stopPropagation();
          toggleLanguage();
        });

        $("helpChip").addEventListener("click", showHelp);
        $("helpChip").addEventListener("keydown", (e) => {
          if (e.key === "Enter" || e.key === " ") showHelp();
        });
        $("scenarioDefaultsBtn").addEventListener("click", () => {
          const scenario = $("scenario").value;
          applyScenarioDefaults(scenario);
        });
        $("savedGameResumeBtn").addEventListener("click", () => resumeGame());
        $("savedGameClearBtn").addEventListener("click", () => clearSavedGameOnly());
        $("resumeBtn").addEventListener("click", resumeGame);
        $("startGameBtn").addEventListener("click", () => {
          // Validate selected scenario/roles/counts before leaving setup.
          const s = readUIState();
          const res = buildRolePool(s.nPlayers, s.mafiaCount, s.toggles);
          if (!res.ok) {
            setError(res.error || t("error.config"));
            showSetup();
            return;
          }

          // Reset all recorded game data, keep only player names.
          try {
            const keepNames = (appState.ui && Array.isArray(appState.ui.playerNames)) ? appState.ui.playerNames.slice() : [];
            // stop any running timers
            try { stopTimerInterval(); } catch {}
            // clear draw + GOD recorded state
            appState.draw = null;
            appState.god = null;
            // restore names (and length will be enforced below)
            if (!appState.ui) appState.ui = {};
            appState.ui.playerNames = keepNames;
            saveState(appState);
          } catch {}

          setError("");
          regenerateFromUI();
          ensureNamesLength(appState.ui.nPlayers);
          // if user has namesMode=last, load them now
          if (appState.ui.namesMode === "last") setNamesMode("last");
          const dispN = (appLang === "fa" && typeof toFarsiNum === "function") ? toFarsiNum(appState.ui.nPlayers) : appState.ui.nPlayers;
          $("playersStat").textContent = (appLang === "fa")
            ? `Ø¨Ø§Ø²ÛŒÚ©Ù†: ${dispN}`
            : `Players: ${dispN}`;
          showPlayers();
        });

        $("playersBackBtn").addEventListener("click", showSetup);
        $("dealBtn").addEventListener("click", () => startDeal());

        $("cardsBackBtn").addEventListener("click", () => showPlayers());
        $("autoAssignBtn").addEventListener("click", autoAssignAllRemaining);
        $("cardsNextBtn").addEventListener("click", () => {
          renderCast();
          showCast();
        });
        $("castBackBtn").addEventListener("click", showSetup);
        $("castFlowBtn").addEventListener("click", showFlowTool);
        $("castPrivacyBtn").addEventListener("click", () => {
          $("castCard").classList.toggle("cast-blurred");
          updateCastPrivacyBtn();
        });

        $("modalCloseBtn").addEventListener("click", closeModal);
        $("modal").addEventListener("click", (e) => {
          if (e.target === $("modal")) closeModal();
        });

        $("toolCloseBtn").addEventListener("click", closeToolModal);
        $("toolOkBtn").addEventListener("click", closeToolModal);
        $("toolModal").addEventListener("click", (e) => {
          if (e.target === $("toolModal")) closeToolModal();
        });

        // GOD tools
        // Wake order tool removed (replaced by Flow Runner night page).
        $("toolStatus").addEventListener("click", showStatusTool);
        // Last move tool removed from toolbar (shown only after a vote-out).
        $("toolRoleChange").addEventListener("click", showRoleChangeTool);
        $("toolTimer").addEventListener("click", showTimerTool);
        $("toolDraw").addEventListener("click", showDrawTool);

        $("namesDefaultBtn").addEventListener("click", () => setNamesMode("default"));
        $("namesLastBtn").addEventListener("click", () => setNamesMode("last"));
        // update mafia select based on players
        $("playersCount").addEventListener("change", () => {
          if (!applyingScenarioDefaults) appState.ui.customized = true;
          const n = parseInt($("playersCount").value, 10);
          fillMafiaSelect(n, computeSuggestedMafia(n));
          $("mafiaCount").value = String(clamp(computeSuggestedMafia(n), 1, parseInt($("mafiaCount").lastChild.value, 10)));
          appState.ui.nPlayers = n;
          ensureNamesLength(n);
          renderNameGrid();
          regenerateFromUI();
          // enforce constraints on mafia specials
          const mafiaCount = parseInt($("mafiaCount").value, 10);
          if (mafiaCount <= 1 && appState && appState.ui && appState.ui.toggles) {
            appState.ui.toggles.swindler = false;
            applyToggles(appState.ui.toggles, { disableSwindler: true, disableMafiaBoss: mafiaCount <= 0 });
          }
          updateQuickStat();
        });

        $("mafiaCount").addEventListener("change", () => {
          if (!applyingScenarioDefaults) appState.ui.customized = true;
          const mafiaCount = parseInt($("mafiaCount").value, 10);
          if (mafiaCount <= 1 && appState && appState.ui && appState.ui.toggles) {
            appState.ui.toggles.swindler = false;
            applyToggles(appState.ui.toggles, { disableSwindler: true, disableMafiaBoss: mafiaCount <= 0 });
          }
          regenerateFromUI();
        });

        $("scenario").addEventListener("change", () => {
          const scenario = $("scenario").value;
          // IMPORTANT: update state first (avoid snapping back to previous scenario)
          appState.ui.scenario = scenario;
          // capture current selections as "customized" baseline
          syncUIToState();

          // Changing scenario should NOT change player/mafia counts.
          // Only update role selections (and enforce scenario allow-list).
          if (appState.ui.customized) {
            // Keep user's current role selections, but turn off roles that aren't allowed in this scenario.
            appState.ui.toggles = normalizeTogglesForScenario(appState.ui.toggles, scenario);
          } else {
            // Not customized: switch role selections to scenario's default role-set.
            appState.ui.toggles = normalizeTogglesForScenario(defaultTogglesForScenario(scenario), scenario);
          }
          applyScenarioAvailability(scenario);
          const mafiaCount = parseInt($("mafiaCount").value, 10);
          applyToggles(appState.ui.toggles, { disableMafiaBoss: mafiaCount <= 0, disableSwindler: mafiaCount <= 1 });
          saveState(appState);
          updateQuickStat();
        });

        // Toggle cards: click anywhere toggles; only "?" opens role help.
        $("toggles").addEventListener("click", (e) => {
          const helpBtn = e && e.target && e.target.closest ? e.target.closest('button[data-rolehelp]') : null;
          if (helpBtn) {
            try { e.preventDefault(); } catch {}
            try { e.stopPropagation(); } catch {}
            const rid = helpBtn.getAttribute("data-rolehelp") || "";
            openRoleHelpOverlay(rid);
            return;
          }

          const wrap = e && e.target && e.target.closest ? e.target.closest(".toggle") : null;
          if (!wrap || wrap.classList.contains("base")) return;
          if (wrap.classList.contains("disabled")) return;
          const key = wrap.dataset.key || "";
          if (!key) return;

          wrap.classList.toggle("on");
          wrap.setAttribute("aria-pressed", wrap.classList.contains("on") ? "true" : "false");
          if (!applyingScenarioDefaults) appState.ui.customized = true;
          regenerateFromUI();
        });

        $("toggles").addEventListener("keydown", (e) => {
          const k = e && e.key ? e.key : "";
          if (k !== "Enter" && k !== " ") return;
          const wrap = e && e.target && e.target.closest ? e.target.closest(".toggle") : null;
          if (!wrap || wrap.classList.contains("base")) return;
          if (wrap.classList.contains("disabled")) return;
          const key = wrap.dataset.key || "";
          if (!key) return;
          try { e.preventDefault(); } catch {}
          wrap.classList.toggle("on");
          wrap.setAttribute("aria-pressed", wrap.classList.contains("on") ? "true" : "false");
          if (!applyingScenarioDefaults) appState.ui.customized = true;
          regenerateFromUI();
        });

        // initial scenario availability
        applyScenarioAvailability($("scenario").value);

        // final persist ui
        syncUIToState();
        if (shouldPersist()) saveState(appState);
    </script>
  </body>
</html>
