        /* Taurus Model 85 revolver silhouette — OpenClipart, public domain (JollyRager) */
        const gunSvg = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 431.81 290.32" fill="currentColor" style="width:1.3em;height:.87em;vertical-align:-.15em;display:inline-block"><g transform="translate(-126.29 -141.21)"><path d="m496.24 431.17c-28.264-0.59012-31.429-1.0232-36.868-5.0448-3.9076-2.889-5.1287-6.5306-5.1434-15.338-0.0205-12.279-2.5004-18.993-10.887-29.478l-5.1011-6.3775v-9.335c0-10.527-1.9694-17.307-7.0736-24.353-8.8995-12.285-25.369-14.375-39.165-4.9696-6.4443 4.3935-6.9945 4.5413-8.8016 2.364-1.1291-1.3605-1.7814-1.0632-5.3724 2.4492-10.813 10.577-29.218 13.407-56.033 8.6184-17.755-3.1708-39.107-12.214-47.603-20.162-6.9586-6.5089-9.8298-12.502-11.024-23.008-1.5705-13.822-4.992-19.505-14.427-23.966-4.1875-1.9796-6.5884-2.3653-14.775-2.3735-9.5686-0.01-9.7953-0.0639-10.75-2.5749-0.53639-1.4108-0.98625-9.6233-0.9997-18.25-0.0278-17.832-0.73699-21.996-4.9677-29.172-1.6543-2.8057-3.0078-6.2013-3.0078-7.5458v-2.4445l-39.632-0.26148-39.632-0.26147-4.3119-15c-4.2426-14.759-4.3128-15.253-4.3675-30.719-0.0502-14.189 0.19018-16.472 2.4702-23.457 1.3892-4.2558 3.0768-8.0879 3.75-8.5156 3.2566-2.069 14.912 0.16633 21.989 4.2168 2.6717 1.5293 60.735 2.6145 60.735 1.1351 0-0.7663 2.3028-1.1603 6.7821-1.1603 3.7301 0 9.2426-0.66053 12.25-1.4678 4.7321-1.2703 14.013-1.3283 68.968-0.43078 34.925 0.57039 69.8 1.3434 77.5 1.7178l14 0.68078 3.6809 7c2.0245 3.85 4.4995 8.5643 5.5 10.476 3.1167 5.9562 8.7861 5.8298 14.637-0.32618 5.4104-5.6922 19.646-9.7913 21.075-6.0683 1.047 2.7285 0.68371 4.6616-0.77115 4.1033-0.75798-0.29086-1.7705-0.16837-2.25 0.27221-0.47953 0.44058-2.5973 1.3528-4.7062 2.0272-4.0727 1.3024-15.558 12.188-18.293 17.337-1.6793 3.1621-1.5631 3.4169 4.526 9.9282 1.9288 2.0625 4.1055 3.75 4.8372 3.75 2.3071 0 11.184 4.9356 15.05 8.3676 4.1932 3.7228 11.781 6.1006 22.714 7.1183 12.92 1.2026 22.13 4.4103 23.575 8.2109 0.76679 2.0168 1.5558 2.3032 6.3447 2.3032 8.2402 0 9.9775 1.9911 13.524 15.5 5.8254 22.19 11.076 33.579 27.017 58.602 18.011 28.272 25.706 51.864 26.712 81.898 0.43459 12.973 0.17009 17.518-1.6225 27.88-2.34 13.526-4.3446 18.507-9.0357 22.455-4.8248 4.0598-10.821 4.4888-51.014 3.6496zm-132.95-89.62c10.081-4.598 16.459-13.384 17.594-24.237 0.81487-7.7963-0.90345-14.501-5.8543-22.842-5.4752-9.2248-6.1634-9.6735-9.7287-6.343-1.7592 1.6433-5.8827 3.5688-10.542 4.9226l-7.6524 2.2235 0.67368 5.392c0.52239 4.181 0.18361 6.909-1.5084 12.146-3.5633 11.03-9.5383 17.787-19.327 21.859-4.2451 1.7657-14.813 1.7044-15.408-0.0894-0.20133-0.60689 2.4468-2.129 5.8847-3.3826 8.5442-3.1154 12.018-5.5894 15.958-11.366 3.2329-4.7395 3.3567-5.2715 3.2668-14.037-0.0778-7.5856-0.66372-10.785-3.5-19.111l-3.4066-10-12.5 0.26185c-23.441 0.49104-33.518 3.3521-40.489 11.496-8.4816 9.9089-7.7733 26.219 1.5442 35.556 4.4307 4.44 10.101 7.653 19.671 11.145 17.895 6.531 31.615 9.0052 48.273 8.7053 10.196-0.18353 13.339-0.60762 17.051-2.3006zm-2.0508-109.69c0-7.7064-0.24244-13.769-0.53876-13.473-0.29632 0.29631-0.94251 6.5594-1.436 13.918-0.49348 7.3586-1.2273 14.279-1.6308 15.378-0.72354 1.9713-0.7039 1.9725 1.436 0.0936 2.0322-1.7844 2.1696-2.792 2.1696-15.917zm-103.8 0.57165-0.30011-15.25h-2.4499c-2.4131 0-2.4531 0.14271-2.6614 9.5-0.47361 21.27-0.65288 19.911 2.7115 20.553 1.65 0.31512 3 0.54454 3 0.50982 0-0.0347-0.13505-6.9256-0.30011-15.313zm104.71-58.5c0.18262-12.249 0.0231-13.75-1.4618-13.75-1.1091 0-1.4637 0.52929-1.0598 1.5818 0.33385 0.86998 0.63862 7.9575 0.67728 15.75 0.0886 17.862 1.5675 14.99 1.8443-3.5818z"/></g></svg>`;

        function fmtNum(n) {
          return (typeof appLang !== "undefined" && appLang === "fa" && typeof toFarsiNum === "function") ? toFarsiNum(n) : String(n);
        }
        /** Step renderer registry — scenario modules register custom step UI via registerStepRenderer(stepId, renderFn).
         * Render function receives ctx: { cur, f, draw, names, aliveIdxs, steps, NIGHT_CARD_BASE, NIGHT_CARD_IDLE, NIGHT_CARD_SEL, mkNightTargetCards, mkNightMultiPickCards, escapeHtml, appLang, t, roles, ROLE_RANK, ROLE_I18N } and returns body HTML string. */
        window.STEP_RENDERERS = window.STEP_RENDERERS || {};
        window.registerStepRenderer = function (stepId, renderFn) {
          window.STEP_RENDERERS[stepId] = renderFn;
        };

        function detectiveInquiryIsMafia(roleId) {
          const rid = String(roleId || "citizen");
          // citizen-but-positive roles
          if (rid === "suspect") return true;
          // mafia-leader-but-negative roles (appear as citizen to detective)
          if (rid === "godfather" || rid === "mafiaBoss" || rid === "danMafia" || rid === "alcapone" || rid === "informant") return false;
          const teamFa = (roles[rid] && roles[rid].teamFa) ? roles[rid].teamFa : "شهر";
          return teamFa === "مافیا";
        }

        function getDefenseThreshold(eligibleVoters) {
          const scenario = typeof getDrawScenarioForFlow === "function" ? getDrawScenarioForFlow() : (typeof getScenario === "function" ? getScenario() : "");
          const cfg = typeof getScenarioConfig === "function" ? getScenarioConfig(scenario) : {};
          if (cfg.voteThreshold === "half_minus_one") {
            return Math.max(1, Math.floor(eligibleVoters / 2) - 1);
          }
          return Math.floor(eligibleVoters / 2) + 1;
        }

        function normWake(s) {
          const x = String(s || "").toLowerCase();
          // Specific compound roles must be checked before generic team labels.
          // "جوکر مافیا" contains "مافیا", so joker check must come first.
          if (x.includes("joker") || x.includes("جوکر")) return "jokermaf";
          if (x.includes("mafia") || x.includes("مافیا")) return "mafia";
          if (x.includes("professional") || x.includes("حرفه")) return "professional";
          if (x.includes("detective") || x.includes("کارآگاه")) return "detective";
          // "لکتر"/"lecter" must come before generic "doctor"/"دکتر" check
          if (x.includes("لکتر") || x.includes("lecter")) return "lecter";
          if (x.includes("doctor") || x.includes("پزشک") || x.includes("دکتر")) return "doctor";
          if (x.includes("watson")) return "doctor";
          if (x.includes("bomber") || x.includes("بمب")) return "bomber";
          if (x.includes("magician") || x.includes("شعبده") || x.includes("شوومن") || x.includes("شومن")) return "magician";
          if (x.includes("zodiac") || x.includes("زودیاک")) return "zodiac";
          if (x.includes("gunslinger") || x.includes("gunner") || x.includes("تفنگدار")) return "gunslinger";
          if (x.includes("ocean") || x.includes("اوشن")) return "ocean";
          if (x.includes("leon") || x.includes("لئون")) return "professional";
          if (x.includes("citizen kane") || x.includes("kane") || x.includes("کین")) return "kane";
          if (x.includes("constantine") || x.includes("کنستانتین")) return "constantine";
          if (x.includes("nostradamus") || x.includes("نوستراداموس")) return "nostradamus";
          if (x.includes("heir") || x.includes("وارث")) return "heir";
          if (x.includes("herbalist") || x.includes("attar") || x.includes("عطار")) return "herbalist";
          if (x.includes("armorsmith") || x.includes("زره")) return "armorsmith";
          if (x.includes("swindler") || x.includes("charlatan") || x.includes("شیاد")) return "swindler";
          if (x.includes("investigator") || x.includes("inspector") || x.includes("بازپرس")) return "investigator";
          if (x.includes("researcher") || x.includes("hunter") || x.includes("محقق")) return "researcher";
          if (x.includes("natasha") || x.includes("ناتاشا")) return "natasha";
          if (x.includes("sniper") || x.includes("تک‌تیرانداز") || x.includes("تک تیرانداز")) return "sniper";
          if (x.includes("negotiat") || x.includes("مذاکره")) return "negotiator";
          if (x.includes("kadkhoda") || x.includes("کدخدا")) return "kadkhoda";
          if (x.includes("reporter") || x.includes("خبرنگار")) return "reporter";
          if (x.includes("representative") || x.includes("نماینده")) return "representative";
          if (x.includes("nato") || x.includes("ناتو")) return "nato";
          if (x.includes("hacker") || x.includes("هکر")) return "hacker";
          if (x.includes("guide") || x.includes("راهنما")) return "guide";
          if (x.includes("bodyguard") || x.includes("محافظ")) return "bodyguard";
          if (x.includes("minemaker") || x.includes("مین")) return "minemaker";
          if (x.includes("lawyer") || x.includes("وکیل")) return "lawyer";
          if (x.includes("soldier") || x.includes("سرباز")) return "soldier";
          return "other";
        }

        function showFlowTool() {
          const draw = appState.draw;
          if (!draw || !draw.players || !draw.players.length) {
            openToolModal(t("tool.flow.title"), `<div class="toolBox">${escapeHtml(t("tool.flow.needDeal"))}</div>`);
            return;
          }
          const f = ensureFlow();
          let steps = getFlowSteps(f);
          // Clamp intro_night step to valid range (prevents skipped Nostradamus when step was corrupted)
          if (f.phase === "intro_night" && steps.length > 0) {
            const maxStep = Math.max(0, steps.length - 1);
            if ((f.step || 0) > maxStep || (f.step || 0) < 0) {
              f.step = 0;
              saveState(appState);
            }
          }
          const cur = steps[Math.min(steps.length - 1, Math.max(0, f.step || 0))];

          const scenario = getDrawScenarioForFlow();
          const names = getPlayerNamesForFlow();
          const aliveIdxs = (draw.players || []).map((p, idx) => (p && p.alive === false) ? null : idx).filter((x) => x !== null);
          const opts = [`<option value="">—</option>`].concat(
            names.map((nm, idx) => `<option value="${idx}">${escapeHtml(nm)}</option>`)
          ).join("");
          const optsAlive = [`<option value="">—</option>`].concat(
            aliveIdxs.map((idx) => `<option value="${idx}">${escapeHtml(names[idx] || t("common.playerN", { n: idx + 1 }))}</option>`)
          ).join("");

          // Shared player card styles and helpers (used for intro night, night steps, etc.)
          const NIGHT_CARD_BASE = "border-radius:14px;cursor:pointer;display:flex;align-items:center;justify-content:center;text-align:center;padding:10px;font-size:13px;line-height:1.3;transition:background .12s,border-color .12s;box-shadow:0 2px 8px rgba(0,0,0,.2);min-height:48px;touch-action:manipulation;user-select:none;";
          const NIGHT_CARD_IDLE = "background:rgba(255,255,255,.06);border:2px solid rgba(255,255,255,.12);color:rgba(255,255,255,.85);font-weight:950;";
          const NIGHT_CARD_SEL = "background:rgba(99,179,237,.25);border:2px solid #63b3ed;color:#fff;font-weight:1100;";
          const mkNightTargetCards = (fieldId, savedVal, labelText, optionalIndexes, optionalDisabledSet) => {
            const indexList = Array.isArray(optionalIndexes) && optionalIndexes.length ? optionalIndexes : aliveIdxs;
            const disabledSet = optionalDisabledSet instanceof Set ? optionalDisabledSet : (Array.isArray(optionalDisabledSet) ? new Set(optionalDisabledSet) : new Set());
            const s = (savedVal === null || savedVal === undefined || savedVal === "") ? "" : String(Number(savedVal));
            const noneLabel = "—";
            const noneSel = s === "";
            const cards = [
              `<button class="nightPlayerCard" type="button" data-field="${escapeHtml(fieldId)}" data-idx="" style="${NIGHT_CARD_BASE}${noneSel ? NIGHT_CARD_SEL : NIGHT_CARD_IDLE}">${escapeHtml(noneLabel)}</button>`,
            ];
            for (const idx of indexList) {
              const v = String(idx);
              const sel = v === s;
              const dis = disabledSet.has(idx);
              const nm = escapeHtml(names[idx] || t("common.playerN", { n: idx + 1 }));
              const disAttr = dis ? ' data-disabled="true"' : "";
              const disStyle = dis ? "opacity:.55;pointer-events:none;" : "";
              cards.push(`<button class="nightPlayerCard" type="button" data-field="${escapeHtml(fieldId)}" data-idx="${escapeHtml(v)}"${disAttr} style="${NIGHT_CARD_BASE}${sel ? NIGHT_CARD_SEL : NIGHT_CARD_IDLE}${disStyle}">${nm}</button>`);
            }
            return `
              <input type="hidden" id="${escapeHtml(fieldId)}" value="${escapeHtml(s)}">
              <div class="nightTargetGroup" data-field="${escapeHtml(fieldId)}" style="margin-top:6px">
                <div style="font-weight:1100; margin-bottom:6px">${escapeHtml(labelText)}</div>
                <div class="nightCardGrid fl-scrollable" style="display:grid; grid-template-columns:repeat(3,1fr); gap:8px; max-height:42vh; overflow:auto; -webkit-overflow-scrolling:touch; touch-action:manipulation; overscroll-behavior:contain;">${cards.join("")}</div>
              </div>`;
          };
          const mkNightMultiPickCards = (fieldId, savedArr, maxCount, labelText, indexList, opts) => {
            const arr = Array.isArray(savedArr) ? savedArr.map((x) => parseInt(x, 10)).filter((x) => Number.isFinite(x)) : [];
            const selSet = new Set(arr.slice(0, maxCount));
            const cards = indexList.map((idx) => {
              const v = String(idx);
              const sel = selSet.has(idx);
              const nm = escapeHtml(names[idx] || t("common.playerN", { n: idx + 1 }));
              return `<button class="nightPlayerCard nightMultiPickCard" type="button" data-field="${escapeHtml(fieldId)}" data-idx="${escapeHtml(v)}" style="${NIGHT_CARD_BASE}${sel ? NIGHT_CARD_SEL : NIGHT_CARD_IDLE}">${nm}</button>`;
            });
            const hidVal = arr.slice(0, maxCount).join(",");
            const dataIntro = (opts && opts.intro) ? ' data-intro="true"' : "";
            return `
              <input type="hidden" id="${escapeHtml(fieldId)}" value="${escapeHtml(hidVal)}">
              <div class="nightTargetGroup nightMultiPickGroup" data-field="${escapeHtml(fieldId)}" data-multipick="true" data-max="${escapeHtml(String(maxCount))}"${dataIntro} style="margin-top:6px">
                <div style="font-weight:1100; margin-bottom:6px">${escapeHtml(labelText)}</div>
                <div class="nightCardGrid fl-scrollable" style="display:grid; grid-template-columns:repeat(3,1fr); gap:8px; max-height:42vh; overflow:auto; -webkit-overflow-scrolling:touch; touch-action:manipulation; overscroll-behavior:contain;">${cards.join("")}</div>
              </div>`;
          };

          // wake order list
          const _wakeOrder = getScenarioConfig(scenario).wakeOrder || {};
          const wake = appLang === "en" ? (_wakeOrder.en || _wakeOrder.fa || []) : (_wakeOrder.fa || []);

          const stepCount = steps.length;
          const stepLine = t("tool.flow.step", { i: (Math.min(stepCount, (f.step || 0) + 1)), n: stepCount });
          // Only show bomb status when it is ACTIVE (hide "inactive" noise).
          const bombLine = (() => {
            if (!f.bombActive) return "";
            try {
              const d = f.draft || {};
              const rec = (d.bombByDay && d.bombByDay[String(f.day)]) ? d.bombByDay[String(f.day)] : null;
              if (!rec || rec.target === null || rec.target === undefined) return t("tool.flow.bomb.active");
              const nm = names[rec.target] || t("common.playerN", { n: rec.target + 1 });
              const code = (rec.code != null && String(rec.code).trim()) ? String(rec.code).trim() : "—";
              if (appLang === "fa") return `بمب جلوی «${nm}» کاشته شده است (کد: ${fmtNum(code)}).`;
              return `Bomb is planted in front of “${nm}” (code: ${code}).`;
            } catch {
              return t("tool.flow.bomb.active");
            }
          })();

          // step-specific body — check registry first (scenario modules), then fallback to built-in renderers
          let body = "";
          const stepCtx = {
            cur, f, draw, names, aliveIdxs, steps, opts, optsAlive,
            NIGHT_CARD_BASE, NIGHT_CARD_IDLE, NIGHT_CARD_SEL,
            mkNightTargetCards, mkNightMultiPickCards,
            escapeHtml, appLang, t, roles,
            ROLE_RANK: typeof ROLE_RANK !== "undefined" ? ROLE_RANK : {},
            ROLE_I18N: typeof ROLE_I18N !== "undefined" ? ROLE_I18N : {},
            setPlayerLife, saveState, appState,
          };
          if (window.STEP_RENDERERS && typeof window.STEP_RENDERERS[cur.id] === "function") {
            body = window.STEP_RENDERERS[cur.id](stepCtx);
          } else if (cur.id === "intro_day_run") {
            body = `
              <div class="note" style="margin-top:8px">
                ${escapeHtml(appLang === "fa"
                  ? "فاز معارفه روز: بازیکنان خود را معرفی می‌کنند و مظنونان خود را مطرح می‌کنند. در این فاز رأی‌گیری انجام نمی‌شود."
                  : "Intro Day: Players introduce themselves and point out their suspects. No voting takes place.")}
              </div>
            `;
          } else if (cur.id === "intro_night_run") {
            const d = f.draft || {};
            if (!d.nightActionsByNight) d.nightActionsByNight = {};
            // Merge from night_actions event when draft is empty so selections persist when navigating back.
            const intro0 = d.nightActionsByNight["0"];
            const hasIntroData = intro0 && typeof intro0 === "object" && ((Array.isArray(intro0.nostPick3) && intro0.nostPick3.length) || (intro0.heirPick != null && intro0.heirPick !== undefined));
            if (!hasIntroData) {
              try {
                const ev = (f.events || []).slice().reverse().find((e) => e && e.kind === "night_actions" && e.phase === "intro_night" && e.data);
                if (ev && ev.data && typeof ev.data === "object" && ((Array.isArray(ev.data.nostPick3) && ev.data.nostPick3.length) || ev.data.heirPick != null)) {
                  const merged = { ...(d.nightActionsByNight["0"] || {}), ...ev.data };
                  d.nightActionsByNight["0"] = merged;
                  f.draft = d;
                  try { saveState(appState); } catch {}
                }
              } catch {}
            }
            const introNight = d.nightActionsByNight["0"] || {};
            const savedHeirPick = introNight.heirPick;
            const savedNostPick3 = Array.isArray(introNight.nostPick3) ? introNight.nostPick3.slice(0, 3) : [];
            const hasNostradamus = (draw.players || []).some((p) => p && p.roleId === "nostradamus");

            // Mafia team list (boss first by role importance)
            const mafiaPlayers = (draw.players || []).map((p, idx) => ({ p, idx })).filter(({ p }) => {
              if (!p) return false;
              const role = roles[p.roleId];
              return role && role.teamFa === "مافیا";
            });
            const roleRankMafia = (rid) => (typeof ROLE_RANK !== "undefined" && ROLE_RANK[rid] != null) ? ROLE_RANK[rid] : 500;
            mafiaPlayers.sort((a, b) => (roleRankMafia(a.p.roleId) - roleRankMafia(b.p.roleId)) || (a.idx - b.idx));
            const mafiaListHtml = mafiaPlayers.length
              ? mafiaPlayers.map(({ p, idx }) => {
                  const nm = names[idx] || t("common.playerN", { n: idx + 1 });
                  const r = roles[p.roleId];
                  const roleLabel = r ? ((appLang === "fa" && r.faName) ? r.faName : (ROLE_I18N && ROLE_I18N[p.roleId] && ROLE_I18N[p.roleId].name) ? ROLE_I18N[p.roleId].name : p.roleId) : p.roleId;
                  return `<div style="padding:4px 0">${escapeHtml(nm)} — ${escapeHtml(roleLabel)}</div>`;
                }).join("")
              : `<div class="note">${escapeHtml(appLang === "fa" ? "مافیایی در بازی نیست." : "No mafia players.")}</div>`;

            // Nostradamus (intro night only): pick 3 players; host announces how many are mafia (Godfather doesn't count)
            const nostSection = !hasNostradamus ? "" : (() => {
              const cleanArr = savedNostPick3.map((x) => parseInt(x, 10)).filter((x) => Number.isFinite(x));
              const allIdxs = (draw.players || []).map((_, i) => i);
              const nostRes = (d.nostResultByNight && d.nostResultByNight["0"]) ? d.nostResultByNight["0"] : null;
              const mafiaCount = (nostRes && nostRes.mafiaCount !== undefined && nostRes.mafiaCount !== null) ? nostRes.mafiaCount : 0;
              const n = cleanArr.length;
              const nostResultLine = n > 0
                ? (appLang === "fa" ? `نتیجه: ${fmtNum(mafiaCount)} نفر از این ${fmtNum(n)} نفر مافیا هستند.` : `Result: ${mafiaCount} of these ${n} are Mafia.`)
                : (appLang === "fa" ? "نتیجه: —" : "Result: —");
              const cardsHtml = mkNightMultiPickCards("fl_intro_nost_pick3", cleanArr, 3, appLang === "fa" ? "۱. نوستراداموس — انتخاب ۳ نفر (کارت‌ها را لمس کنید)" : "1. Nostradamus — Pick 3 players (tap cards)", allIdxs, { intro: true });
              return `
                <div style="margin-top:14px; border-top:1px solid rgba(255,255,255,.1); padding-top:12px">
                  <div class="note" style="margin-bottom:6px">${escapeHtml(appLang === "fa" ? "۳ نفر را انتخاب کنید. گرداننده تعداد مافیاهای بین آن‌ها را اعلام می‌کند (پدرخوانده مافیا حساب نمی‌شود)." : "Pick 3 players. Host announces how many of them are Mafia (Godfather doesn't count).")}</div>
                  ${cardsHtml}
                  <div id="fl_intro_nost_result" class="note result" style="margin-top:8px">${escapeHtml(nostResultLine)}</div>
                </div>
              `;
            })();

            // Heir pick (only if a Heir role exists in the game) — player cards, single select
            const heirIdx = (draw.players || []).findIndex((p) => p && p.roleId === "heir");
            const heirSection = heirIdx === -1 ? "" : (() => {
              const heirName = names[heirIdx] || t("common.playerN", { n: heirIdx + 1 });
              const allIdxs = (draw.players || []).map((_, i) => i);
              const cardsHtml = mkNightTargetCards("fl_intro_heir_pick", savedHeirPick, appLang === "fa" ? `وارث (${heirName}) — انتخاب جانشین` : `Heir (${heirName}) — pick successor`, allIdxs);
              return `
                <div style="margin-top:14px; border-top:1px solid rgba(255,255,255,.1); padding-top:12px">
                  ${cardsHtml}
                </div>
              `;
            })();

            body = `
              ${nostSection}
              <div style="margin-top:14px; border-top:1px solid rgba(255,255,255,.1); padding-top:12px">
                <div style="font-weight:950; margin-bottom:8px">${escapeHtml(appLang === "fa" ? "۲. تیم مافیا — گرداننده بیدار می‌کند؛ هر کدام ژست «لایک» نشان می‌دهند (بدون اکشن)" : "2. Mafia team — God wakes them; each shows \"Like\" gesture (no actions)")}</div>
                ${mafiaListHtml}
              </div>
              ${heirSection}
            `;
          } else if (cur.id === "day_bomb") {
            const d = f.draft || {};
            if (!d.bombByDay || typeof d.bombByDay !== "object") d.bombByDay = {};
            if (!d.bombResolveByDay || typeof d.bombResolveByDay !== "object") d.bombResolveByDay = {};
            // If we are BACK on the Bomb step, revert so editing is intuitive. Skip if we just applied from change handler.
            if (!bombApplyJustHappened) {
              try {
                const key = String(f.day || 1);
                if (!d.bombAppliedByDay || typeof d.bombAppliedByDay !== "object") d.bombAppliedByDay = {};
                const prev = (d.bombAppliedByDay[key] && typeof d.bombAppliedByDay[key] === "object") ? d.bombAppliedByDay[key] : null;
                if (prev && prev.killed !== null && prev.killed !== undefined && Number.isFinite(Number(prev.killed))) {
                  const pi = parseInt(prev.killed, 10);
                  if (prev.prevAlive === true) {
                    try { setPlayerLife(pi, { alive: true }); } catch {}
                  }
                  prev.killed = null;
                  prev.prevAlive = null;
                  d.bombAppliedByDay[key] = prev;
                }
                if (d.bombResolveByDay[key] && typeof d.bombResolveByDay[key] === "object") {
                  d.bombResolveByDay[key].resolved = false;
                  d.bombResolveByDay[key].outcome = null;
                }
                f.draft = d;
                saveState(appState);
              } catch {}
            }
            const rec = d.bombByDay[String(f.day)] || null;
            const targetIdx = (rec && rec.target !== null && rec.target !== undefined && Number.isFinite(Number(rec.target))) ? parseInt(rec.target, 10) : null;
            const targetName = (targetIdx !== null) ? (names[targetIdx] || t("common.playerN", { n: targetIdx + 1 })) : (appLang === "fa" ? "—" : "—");
            const plantedCode = (rec && rec.code != null && String(rec.code).trim()) ? String(rec.code).trim() : "";
            const guardIdx = (() => {
              try {
                for (let i = 0; i < (draw.players || []).length; i++) {
                  const p = draw.players[i];
                  if (!p) continue;
                  const rid = p.roleId || "citizen";
                  if (roles[rid] && roles[rid].canSacrificeForBomb) return i;
                }
              } catch {}
              return null;
            })();
            const hasGuard = guardIdx !== null;
            const guardAlive = (guardIdx !== null && draw.players && draw.players[guardIdx]) ? (draw.players[guardIdx].alive !== false) : false;
            const guardDisabledPrevNight = (guardIdx !== null && d.disabledByNight && d.disabledByNight[String(f.day)] != null)
              ? (parseInt(d.disabledByNight[String(f.day)], 10) === guardIdx) : false;
            const guardCanSacrifice = hasGuard && guardAlive && !guardDisabledPrevNight;
            const guardName = (guardIdx !== null)
              ? (names[guardIdx] || t("common.playerN", { n: guardIdx + 1 }))
              : (appLang === "fa" ? "—" : "—");

            const r0 = (d.bombResolveByDay[String(f.day)] && typeof d.bombResolveByDay[String(f.day)] === "object")
              ? d.bombResolveByDay[String(f.day)]
              : { guardSacrifice: false, guardGuess: "", targetGuess: "", resolved: false, outcome: null };
            const mkCodeOpts = (sel) => {
              const s = String(sel ?? "").trim();
              const opts = [`<option value="" ${s === "" ? "selected" : ""}>—</option>`];
              for (let i = 1; i <= 4; i++) {
                const v = String(i);
                opts.push(`<option value="${v}" ${s === v ? "selected" : ""}>${v}</option>`);
              }
              return opts.join("");
            };
            const headline = (appLang === "fa")
              ? `بمب جلوی «${targetName}» کاشته شده است${plantedCode ? ` (کد: ${fmtNum(plantedCode)})` : ""}.`
              : `Bomb is planted in front of “${targetName}”${plantedCode ? ` (code: ${plantedCode})` : ""}.`;
            // Keep bomb UI concise; detailed rules belong in Help.
            const guardLine = hasGuard
              ? (guardAlive
                ? (guardDisabledPrevNight ? (appLang === "fa" ? `محافظ (${guardName}) شب گذشته غیرفعال شده و نمی‌تواند فدا شود.` : `Guard (${guardName}) was disabled last night and cannot sacrifice.`) : "")
                : (appLang === "fa" ? `محافظ (${guardName}) مرده است.` : `Guard (${guardName}) is dead.`))
              : (appLang === "fa" ? "محافظ در این بازی وجود ندارد." : "No Guard in this game.");

            const outcomeLine = (() => {
              // Live preview: updates as options change. If already applied, mark it as applied.
              if (!plantedCode) return "";
              const applied = !!(r0 && r0.resolved);
              const sac = !!(guardCanSacrifice && r0 && r0.guardSacrifice);
              const guardGuess = String((r0 && r0.guardGuess) || "").trim();
              const targetGuess = String((r0 && r0.targetGuess) || "").trim();
              const guess = sac ? guardGuess : targetGuess;
              const prefix = (appLang === "fa")
                ? (applied ? "نتیجه (اعمال‌شده): " : "نتیجه: ")
                : (applied ? "Result (applied): " : "Result: ");
              if (!guess) {
                return prefix + (appLang === "fa"
                  ? (sac ? "کدِ محافظ را انتخاب کنید." : "حدسِ هدف را انتخاب کنید.")
                  : (sac ? "Pick Guard guess." : "Pick target guess."));
              }
              const ok = String(guess) === String(plantedCode);
              const o =
                sac
                  ? (ok ? "neutralized_guard" : "guard_died")
                  : (ok ? "neutralized_target" : "target_died");
              if (o === "neutralized_guard") return prefix + (appLang === "fa" ? "محافظ بمب را خنثی کرد." : "Guard neutralized the bomb.");
              if (o === "guard_died") return prefix + (appLang === "fa" ? "محافظ اشتباه حدس زد و مرد." : "Guard guessed wrong and died.");
              if (o === "neutralized_target") return prefix + (appLang === "fa" ? "هدف درست حدس زد و بمب خنثی شد." : "Target guessed right; bomb neutralized.");
              if (o === "target_died") return prefix + (appLang === "fa" ? "هدف اشتباه حدس زد و مرد." : "Target guessed wrong and died.");
              return "";
            })();

            body = `
              <div class="note" style="margin-top:6px">${escapeHtml(headline)}</div>
              <div style="height:10px"></div>
              ${guardLine ? `<div class="note">${escapeHtml(guardLine)}</div><div style="height:10px"></div>` : ``}
              <div style="height:14px"></div>
              ${hasGuard ? `
                <label for="fl_bomb_guard" style="display:flex; flex-direction:row; align-items:center; justify-content:space-between; gap:14px; font-weight:950; cursor:pointer; user-select:none; -webkit-user-select:none">
                  <span>${escapeHtml(appLang === "fa" ? "محافظ فدا می‌شود؟" : "Does Guard sacrifice?")}</span>
                  <input id="fl_bomb_guard" type="checkbox" ${r0.guardSacrifice ? "checked" : ""} ${guardCanSacrifice ? "" : "disabled"} style="width:24px; height:24px; margin:0; accent-color: var(--primary)" />
                </label>
                <div style="height:10px"></div>
              ` : ``}
              ${hasGuard && r0.guardSacrifice ? `
                <label>${escapeHtml(appLang === "fa" ? `حدسِ محافظ (${guardName})` : `Guard (${guardName}) guess`)}
                  <select id="fl_bomb_guard_guess">${mkCodeOpts(r0.guardGuess)}</select>
                </label>
              ` : `
                <label>${escapeHtml(appLang === "fa" ? `حدسِ ${targetName}` : `${targetName} guess`)}
                  <select id="fl_bomb_target_guess">${mkCodeOpts(r0.targetGuess)}</select>
                </label>
              `}
              ${outcomeLine ? `<div class="note warn" style="margin-top:10px">${escapeHtml(outcomeLine)}</div>` : ``}
              <div class="note" style="margin-top:10px">${escapeHtml(appLang === "fa" ? "با انتخاب حدس، نتیجه بلافاصله اعمال می‌شود؛ «بعدی» برای ادامه." : "Your choice applies immediately. Press \"Next\" to continue.")}</div>
            `;
          } else if (cur.id === "bazras_interrogation") {
            const d = f.draft || {};
            const prevNightKey = String(Math.max(0, (f.day || 1) - 1));
            const invTargets = d.investigatorTargetsByNight && d.investigatorTargetsByNight[prevNightKey];
            const t1Idx = (invTargets && invTargets.t1 != null) ? invTargets.t1 : null;
            const t2Idx = (invTargets && invTargets.t2 != null) ? invTargets.t2 : null;
            const t1Name = t1Idx !== null ? escapeHtml(names[t1Idx] || t("common.playerN", { n: t1Idx + 1 })) : "?";
            const t2Name = t2Idx !== null ? escapeHtml(names[t2Idx] || t("common.playerN", { n: t2Idx + 1 })) : "?";
            const invIdx = draw.players.findIndex((p) => p && p.roleId === "investigator");
            const invAlive = invIdx >= 0 && draw.players[invIdx].alive !== false;
            const invName = invIdx >= 0 ? escapeHtml(names[invIdx] || t("common.playerN", { n: invIdx + 1 })) : "؟";
            ensureTimers();
            const _tmrV = appState.god.timers;
            body = `
              <div class="note" style="margin-bottom:8px; font-size:15px; font-weight:1100">${escapeHtml(appLang === "fa"
                ? `بازپرسی: ${t1Name} و ${t2Name}`
                : `Interrogation: ${t1Name} and ${t2Name}`)}</div>
              <div class="note" style="margin-bottom:10px">${escapeHtml(appLang === "fa"
                ? "هر کدام دو نوبت صحبت می‌کنند. در حین بازپرسی لایک/دیسلایک ممنوع است."
                : "Each speaks twice. No liking/disliking during interrogation.")}</div>
              ${!invAlive ? `<div class="note warn" style="margin-bottom:10px">${escapeHtml(appLang === "fa"
                ? `بازپرس (${invName}) از بازی خارج شده — روند بدون حضور او ادامه دارد.`
                : `Inspector (${invName}) is eliminated — process continues without them.`)}</div>` : ""}
              <div class="timerRow" style="margin-top:10px">
                <div class="timerCard">
                  <div class="tname">${escapeHtml(t("tool.timer.turn"))}</div>
                  <div class="tval clickable" id="tm_talk">${formatMMSS(_tmrV.remaining.talk ?? _tmrV.talk)}</div>
                  <div style="display:flex; gap:6px; justify-content:center; align-items:center">
                    <button class="tbtn" id="tm_btn_talk" type="button" aria-label="Play/Pause"></button>
                    <button class="tbtn reset" id="tm_rst_talk" type="button" aria-label="Reset"><svg viewBox="0 0 24 24" fill="currentColor" aria-hidden="true"><path d="M12 5V1L7 6l5 5V7c3.31 0 6 2.69 6 6s-2.69 6-6 6-6-2.69-6-6H4c0 4.42 3.58 8 8 8s8-3.58 8-8-3.58-8-8-8z"/></svg></button>
                  </div>
                </div>
              </div>
            `;

          } else if (cur.id === "bazras_midday") {
            const d = f.draft || {};
            const dayKey = String(f.day || 1);
            const rec = (d.bazrasInterrogationByDay && d.bazrasInterrogationByDay[dayKey]) || {};
            const decision = rec.decision || null;
            const cancelSel  = decision === "cancel";
            const continueSel = decision === "continue";
            const cancelStyle   = cancelSel
              ? "background:rgba(239,68,68,.22);  border:2px solid rgba(239,68,68,.85);  color:#fff;"
              : "background:rgba(255,255,255,.06); border:2px solid rgba(255,255,255,.18); color:rgba(255,255,255,.6);";
            const continueStyle = continueSel
              ? "background:rgba(99,179,237,.22);  border:2px solid #63b3ed;              color:#fff;"
              : "background:rgba(255,255,255,.06); border:2px solid rgba(255,255,255,.18); color:rgba(255,255,255,.6);";
            body = `
              <div class="note" style="margin-bottom:14px">${escapeHtml(appLang === "fa"
                ? "همه می‌خوابند. بازپرس باید تصمیم بگیرد."
                : "Everyone sleeps. The Inspector must decide.")}</div>
              <div style="display:grid; grid-template-columns:1fr 1fr; gap:10px">
                <button id="fl_bazras_cancel" type="button"
                  style="padding:22px 10px; border-radius:14px; cursor:pointer; font-size:14px; font-weight:1100; line-height:1.35; ${cancelStyle}">
                  ${escapeHtml(appLang === "fa" ? "لغو بازپرسی" : "Cancel")}
                </button>
                <button id="fl_bazras_continue" type="button"
                  style="padding:22px 10px; border-radius:14px; cursor:pointer; font-size:14px; font-weight:1100; line-height:1.35; ${continueStyle}">
                  ${escapeHtml(appLang === "fa" ? "ادامه — رأی اجباری" : "Continue")}
                </button>
              </div>
            `;

          } else if (cur.id === "bazras_forced_vote") {
            const d = f.draft || {};
            const dayKey = String(f.day || 1);
            const prevNightKey = String(Math.max(0, (f.day || 1) - 1));
            const invTargets = d.investigatorTargetsByNight && d.investigatorTargetsByNight[prevNightKey];
            const t1Idx = (invTargets && invTargets.t1 != null) ? invTargets.t1 : null;
            const t2Idx = (invTargets && invTargets.t2 != null) ? invTargets.t2 : null;
            const t1Name = t1Idx !== null ? escapeHtml(names[t1Idx] || t("common.playerN", { n: t1Idx + 1 })) : "?";
            const t2Name = t2Idx !== null ? escapeHtml(names[t2Idx] || t("common.playerN", { n: t2Idx + 1 })) : "?";
            const rec = (d.bazrasInterrogationByDay && d.bazrasInterrogationByDay[dayKey]) || {};
            const decision = rec.decision || null;
            if (decision === "cancel") {
              body = `
                <div class="note" style="margin-bottom:10px">${escapeHtml(appLang === "fa"
                  ? "بازپرسی لغو شد — رأی‌گیری اجباری انجام نمی‌شود."
                  : "Interrogation cancelled — no forced vote.")}</div>
                <div class="note" style="color:var(--muted)">${escapeHtml(appLang === "fa"
                  ? "برای رفتن به رأی‌گیری روزانه، «بعدی» را بزنید."
                  : "Press Next to proceed to the regular day vote.")}</div>
              `;
            } else {
              const fvVotes = (rec.votes && typeof rec.votes === "object") ? rec.votes : {};
              const v1 = Math.max(0, parseInt(fvVotes[t1Idx] || 0, 10));
              const v2 = Math.max(0, parseInt(fvVotes[t2Idx] || 0, 10));
              const hasVotes = v1 > 0 || v2 > 0;
              const winner = !hasVotes ? null : (v1 > v2 ? t1Idx : v2 > v1 ? t2Idx : "tie");
              const _minusSvg = `<svg viewBox="0 0 20 20" width="14" height="14" fill="currentColor"><rect x="3" y="9" width="14" height="2" rx="1"/></svg>`;
              const _plusSvg  = `<svg viewBox="0 0 20 20" width="14" height="14" fill="currentColor"><rect x="3" y="9" width="14" height="2" rx="1"/><rect x="9" y="3" width="2" height="14" rx="1"/></svg>`;
              const mkFVCard = (idx, nm, v) => {
                const isWinner = winner !== null && winner !== "tie" && winner === idx;
                const cs = isWinner
                  ? "background:rgba(239,68,68,.22); border:2px solid rgba(239,68,68,.85);"
                  : "background:rgba(255,255,255,.05); border:2px solid rgba(255,255,255,.10);";
                return `
                  <div style="border-radius:14px; padding:8px 6px; ${cs} display:flex; flex-direction:column; align-items:center; justify-content:center; gap:6px; box-shadow:0 2px 8px rgba(0,0,0,.2); aspect-ratio:1/1; overflow:hidden">
                    <div style="font-weight:1100; font-size:12px; text-align:center; line-height:1.2; word-break:break-word">${nm}</div>
                    <div style="display:flex; align-items:center; gap:8px">
                      <button class="bazras_fv_minus" data-idx="${idx}" type="button" style="width:32px;height:32px;border-radius:9px;background:rgba(255,255,255,.1);border:1px solid rgba(255,255,255,.18);color:rgba(255,255,255,.85);cursor:pointer;display:flex;align-items:center;justify-content:center;flex-shrink:0">${_minusSvg}</button>
                      <span style="min-width:24px;text-align:center;font-size:18px;font-weight:1200">${fmtNum(v)}</span>
                      <button class="bazras_fv_plus" data-idx="${idx}" type="button" style="width:32px;height:32px;border-radius:9px;background:rgba(255,255,255,.1);border:1px solid rgba(255,255,255,.18);color:rgba(255,255,255,.85);cursor:pointer;display:flex;align-items:center;justify-content:center;flex-shrink:0">${_plusSvg}</button>
                    </div>
                  </div>`;
              };
              const resultNote = (() => {
                if (winner === null) return "";
                if (winner === "tie") return `<div class="note result" style="margin-top:10px">${escapeHtml(appLang === "fa" ? "تساوی — کسی از بازی خارج نمی‌شود." : "Tie — no one is eliminated.")}</div>`;
                const winIdx = winner === t1Idx ? t1Idx : t2Idx;
                const winName = winner === t1Idx ? t1Name : t2Name;
                const winPlayer = draw.players[winIdx];
                const winTeamFa = (winPlayer && roles[winPlayer.roleId] && roles[winPlayer.roleId].teamFa) ? roles[winPlayer.roleId].teamFa : "شهر";
                const winSide = appLang === "fa"
                  ? (winTeamFa === "مافیا" ? "مافیا" : "شهروند")
                  : (winTeamFa === "مافیا" ? "Mafia" : "Citizen");
                const sideStyle = winTeamFa === "مافیا" ? "color:rgba(239,68,68,.9); font-weight:1100" : "color:rgba(99,179,237,.9); font-weight:1100";
                return `<div class="note result" style="margin-top:10px">${winName} ${escapeHtml(appLang === "fa" ? "از بازی خارج می‌شود" : "is eliminated")} — <span style="${sideStyle}">${escapeHtml(winSide)}</span></div>`;
              })();
              body = `
                <div class="note" style="margin-bottom:12px">${escapeHtml(appLang === "fa"
                  ? "بازیکن با بیشترین رأی، آخرین سخنانش را می‌گوید و از بازی خارج می‌شود."
                  : "The player with most votes says their last words and exits.")}</div>
                <div style="display:grid; grid-template-columns:1fr 1fr; gap:16px; max-width:300px; margin:0 auto">
                  ${t1Idx !== null ? mkFVCard(t1Idx, t1Name, v1) : ""}
                  ${t2Idx !== null ? mkFVCard(t2Idx, t2Name, v2) : ""}
                </div>
                ${resultNote}
              `;
            }

          } else if (cur.id === "day_poison_status") {
            body = `
              <div class="note" style="margin-top:12px; padding:16px; font-size:18px; font-weight:1100; text-align:center; background:rgba(255,75,75,.12); border-radius:12px; border:1px solid rgba(255,75,75,.3)">
                ${escapeHtml(t("tool.flow.poisonStatus.message"))}
              </div>
            `;
          } else if (cur.id === "night_poisoned_player") {
            const prevNightKey = String(Math.max(0, (f.day || 1) - 1));
            const prevNa = (f.draft && f.draft.nightActionsByNight && f.draft.nightActionsByNight[prevNightKey]) || null;
            const poisonIdx = (prevNa && prevNa.herbalistPoison != null && Number.isFinite(parseInt(prevNa.herbalistPoison, 10))) ? parseInt(prevNa.herbalistPoison, 10) : null;
            const victimName = (poisonIdx != null && names[poisonIdx]) ? names[poisonIdx] : t("common.playerN", { n: (poisonIdx || 0) + 1 });
            const nightKey = String(f.day || 1);
            const vote = (f.draft && f.draft.poisonAntidoteVoteByDay && f.draft.poisonAntidoteVoteByDay[nightKey]) || { agree: 0, disagree: 0 };
            const agree = Math.max(0, Number(vote.agree) || 0);
            const disagree = Math.max(0, Number(vote.disagree) || 0);
            const total = agree + disagree;
            const moreThanHalfAgree = total > 0 && agree > total / 2;
            const voteResult = total > 0 ? (moreThanHalfAgree ? t("tool.flow.poisonedPlayer.voteResultAgree") : t("tool.flow.poisonedPlayer.voteResultDisagree")) : "";
            const _pmSvg = `<svg viewBox="0 0 20 20" width="14" height="14" fill="currentColor"><rect x="3" y="9" width="14" height="2" rx="1"/></svg>`;
            const _plSvg = `<svg viewBox="0 0 20 20" width="14" height="14" fill="currentColor"><rect x="3" y="9" width="14" height="2" rx="1"/><rect x="9" y="3" width="2" height="14" rx="1"/></svg>`;
            const cardStyle = "border-radius:14px; padding:14px; display:flex; flex-direction:column; align-items:center; justify-content:center; gap:8px; box-shadow:0 2px 8px rgba(0,0,0,.2); background:rgba(255,255,255,.05); border:2px solid rgba(255,255,255,.12);";
            body = `
              <div class="note" style="margin-top:12px; padding:16px; font-size:18px; font-weight:1100; text-align:center; background:rgba(255,75,75,.12); border-radius:12px; border:1px solid rgba(255,75,75,.3)">
                ${escapeHtml(t("tool.flow.poisonedPlayer.victim", { name: victimName }))}
              </div>
              <div class="note" style="margin-top:12px">${escapeHtml(t("tool.flow.poisonedPlayer.voteHint"))}</div>
              <div style="margin-top:14px; display:grid; grid-template-columns:1fr 1fr; gap:12px">
                <div class="poison_antidote_card" data-vote="agree" style="${cardStyle} border-color:rgba(74,222,128,.35); background:rgba(74,222,128,.08)">
                  <div style="font-weight:1100; font-size:14px">${escapeHtml(t("tool.flow.poisonedPlayer.agree"))}</div>
                  <div style="display:flex; align-items:center; gap:8px">
                    <button class="poison_antidote_minus" data-vote="agree" type="button" style="width:36px;height:36px;border-radius:10px;background:rgba(255,255,255,.1);border:1px solid rgba(255,255,255,.18);color:rgba(255,255,255,.85);cursor:pointer;display:flex;align-items:center;justify-content:center">${_pmSvg}</button>
                    <span class="poison_antidote_count" data-vote="agree" style="min-width:28px;text-align:center;font-size:22px;font-weight:1200">${agree}</span>
                    <button class="poison_antidote_plus" data-vote="agree" type="button" style="width:36px;height:36px;border-radius:10px;background:rgba(255,255,255,.1);border:1px solid rgba(255,255,255,.18);color:rgba(255,255,255,.85);cursor:pointer;display:flex;align-items:center;justify-content:center">${_plSvg}</button>
                  </div>
                </div>
                <div class="poison_antidote_card" data-vote="disagree" style="${cardStyle} border-color:rgba(255,75,75,.35); background:rgba(255,75,75,.08)">
                  <div style="font-weight:1100; font-size:14px">${escapeHtml(t("tool.flow.poisonedPlayer.disagree"))}</div>
                  <div style="display:flex; align-items:center; gap:8px">
                    <button class="poison_antidote_minus" data-vote="disagree" type="button" style="width:36px;height:36px;border-radius:10px;background:rgba(255,255,255,.1);border:1px solid rgba(255,255,255,.18);color:rgba(255,255,255,.85);cursor:pointer;display:flex;align-items:center;justify-content:center">${_pmSvg}</button>
                    <span class="poison_antidote_count" data-vote="disagree" style="min-width:28px;text-align:center;font-size:22px;font-weight:1200">${disagree}</span>
                    <button class="poison_antidote_plus" data-vote="disagree" type="button" style="width:36px;height:36px;border-radius:10px;background:rgba(255,255,255,.1);border:1px solid rgba(255,255,255,.18);color:rgba(255,255,255,.85);cursor:pointer;display:flex;align-items:center;justify-content:center">${_plSvg}</button>
                  </div>
                </div>
              </div>
              ${voteResult ? `<div class="note result" id="fl_poison_vote_result" style="margin-top:14px; padding:12px; font-weight:1100">${escapeHtml(voteResult)}</div>` : `<div id="fl_poison_vote_result" style="margin-top:14px; min-height:24px"></div>`}
            `;
          } else if (cur.id === "night_herbalist_antidote") {
            const prevNightKey = String(Math.max(0, (f.day || 1) - 1));
            const prevNa = (f.draft && f.draft.nightActionsByNight && f.draft.nightActionsByNight[prevNightKey]) || null;
            const poisonIdx = (prevNa && prevNa.herbalistPoison != null && Number.isFinite(parseInt(prevNa.herbalistPoison, 10))) ? parseInt(prevNa.herbalistPoison, 10) : null;
            const victimName = (poisonIdx != null && names[poisonIdx]) ? names[poisonIdx] : t("common.playerN", { n: (poisonIdx || 0) + 1 });
            const nightKey = String(f.day || 1);
            const savedNight = (f.draft && f.draft.nightActionsByNight && f.draft.nightActionsByNight[nightKey]) || {};
            const savedAntidote = (savedNight.herbalistAntidote === null || savedNight.herbalistAntidote === undefined) ? null : parseInt(savedNight.herbalistAntidote, 10);
            const giveAntidote = savedAntidote === poisonIdx;
            const herbCardStyle = "border-radius:14px; padding:16px; display:flex; align-items:center; justify-content:center; text-align:center; font-weight:1100; font-size:15px; box-shadow:0 2px 8px rgba(0,0,0,.2); min-height:56px; cursor:pointer; transition:background .12s,border-color .12s; touch-action:manipulation; user-select:none; border:2px solid;";
            const giveSel = giveAntidote ? "background:rgba(74,222,128,.2); border-color:#4ade80;" : "background:rgba(255,255,255,.05); border-color:rgba(255,255,255,.15); color:rgba(255,255,255,.85);";
            const withholdSel = !giveAntidote ? "background:rgba(255,75,75,.15); border-color:rgba(255,75,75,.5);" : "background:rgba(255,255,255,.05); border-color:rgba(255,255,255,.15); color:rgba(255,255,255,.85);";
            body = `
              <div class="note" style="margin-top:12px">${escapeHtml(t("tool.flow.herbalistAntidote.hint"))}</div>
              <div class="note" style="margin-top:8px">${escapeHtml(appLang === "fa" ? `مسموم شده: ${victimName}` : `Poisoned: ${victimName}`)}</div>
              <div style="margin-top:14px; display:grid; grid-template-columns:1fr 1fr; gap:12px">
                <button class="herbalist_antidote_card" type="button" data-value="give" style="${herbCardStyle}${giveSel}">${escapeHtml(t("tool.flow.herbalistAntidote.give"))}</button>
                <button class="herbalist_antidote_card" type="button" data-value="withhold" style="${herbCardStyle}${withholdSel}">${escapeHtml(t("tool.flow.herbalistAntidote.withhold"))}</button>
              </div>
            `;
          } else if (cur.id === "night_poison_result") {
            const prevNightKey = String(Math.max(0, (f.day || 1) - 1));
            const prevNa = (f.draft && f.draft.nightActionsByNight && f.draft.nightActionsByNight[prevNightKey]) || null;
            const poisonIdx = (prevNa && prevNa.herbalistPoison != null && Number.isFinite(parseInt(prevNa.herbalistPoison, 10))) ? parseInt(prevNa.herbalistPoison, 10) : null;
            const victimName = (poisonIdx != null && names[poisonIdx]) ? names[poisonIdx] : t("common.playerN", { n: (poisonIdx || 0) + 1 });
            const nightKey = String(f.day || 1);
            const d = f.draft || {};
            const savedNight = (d.nightActionsByNight && d.nightActionsByNight[nightKey]) || {};
            const savedAntidote = (savedNight.herbalistAntidote === null || savedNight.herbalistAntidote === undefined) ? null : parseInt(savedNight.herbalistAntidote, 10);
            let antidoteGiven = (savedAntidote !== null && savedAntidote !== undefined && savedAntidote === poisonIdx);
            const victimRole = (poisonIdx != null && draw.players && draw.players[poisonIdx]) ? (draw.players[poisonIdx].roleId || "citizen") : "citizen";
            if (!antidoteGiven && victimRole === "danMafia" && !d.danMafiaAntidoteUsed) antidoteGiven = true;
            if (!antidoteGiven && victimRole === "witch" && d.witchHasAntidoteFromDon) antidoteGiven = true;
            const msg = antidoteGiven ? t("tool.flow.poisonResult.fixed") : t("tool.flow.poisonResult.worked", { name: victimName });
            body = `
              <div class="note" style="margin-top:12px; padding:16px; font-size:18px; font-weight:1100; text-align:center; background:${antidoteGiven ? "rgba(74,222,128,.15)" : "rgba(255,75,75,.12)"}; border-radius:12px; border:1px solid ${antidoteGiven ? "rgba(74,222,128,.4)" : "rgba(255,75,75,.3)"}">
                ${escapeHtml(msg)}
              </div>
            `;
          } else if (cur.id === "day_vote") {
            const d = f.draft || {};
            if (!d.voteCandidatesByDay || typeof d.voteCandidatesByDay !== "object") d.voteCandidatesByDay = {};
            const selected = Array.isArray(d.voteCandidatesByDay[f.day]) ? d.voteCandidatesByDay[f.day] : [];

            if (!d.challengeUsedByDay || typeof d.challengeUsedByDay !== "object") d.challengeUsedByDay = {};
            const challengeUsed = Array.isArray(d.challengeUsedByDay[f.day]) ? d.challengeUsedByDay[f.day].map(Number) : [];
            const cells = aliveIdxs.map((idx) => {
              const isSel = selected.includes(idx) || selected.map(Number).includes(idx);
              const isChallenged = challengeUsed.includes(idx);
              const name = escapeHtml(names[idx] || t("common.playerN", { n: idx + 1 }));
              const selStyle = isSel
                ? `background:rgba(99,179,237,.22); border:2px solid #63b3ed; color:#fff; font-weight:1100;`
                : `background:rgba(255,255,255,.05); border:2px solid rgba(255,255,255,.10); color:var(--muted); font-weight:950;`;
              const badgeStyle = isChallenged
                ? `background:rgba(255,75,75,.9); border:1px solid rgba(255,75,75,.6); color:#fff;`
                : `background:transparent; border:1px solid rgba(255,255,255,.18); color:rgba(255,255,255,.2);`;
              return `
                <button class="fl_vote_btn" data-idx="${idx}" type="button"
                  style="position:relative; width:100%; aspect-ratio:1/1; border-radius:14px; cursor:pointer;
                         display:flex; align-items:center; justify-content:center; text-align:center;
                         padding:8px; font-size:13px; line-height:1.3;
                         transition:background .12s,border-color .12s;
                         box-shadow:0 4px 12px rgba(0,0,0,.25); ${selStyle}">
                  ${name}
                  <span data-challenge data-idx="${idx}"
                    style="position:absolute; top:2px; right:2px; width:40px; height:40px; border-radius:50%;
                           overflow:hidden; cursor:pointer; ${badgeStyle}">
                    <svg width="40" height="40" viewBox="100 10 580 570" style="pointer-events:none" fill="none" stroke="currentColor" stroke-width="22" stroke-linecap="round" stroke-linejoin="round">
                      <path transform="rotate(-6 340.204 272.672)" d="m226.22263,379.11109c-1.34911,-1.34174 35.07686,-28.17648 33.72775,-28.17648c-1.34911,0 1.34911,-41.59385 29.68042,-67.08685c28.33131,-25.493 64.75728,-44.27732 79.59749,-56.35296c14.84021,-12.07563 44.52063,-52.32775 55.31351,-57.69469c10.79288,-5.36695 29.68042,-6.70869 29.68042,10.7339c0,17.44258 -8.09466,42.93559 -18.88754,52.32775"/>
                      <path d="m315.55554,460.44443c0,0 33.33333,-20 54.66667,-25.33333c21.33333,-5.33333 48,-9.33333 64,-20c16,-10.66667 30.66667,-64 40,-74.66666c9.33333,-10.66667 41.33333,-48 41.33333,-62.66666c0,-14.66667 -74.66666,-58.66666 -98.66666,-52c-24,6.66667 -54.66667,13.33333 -57.33333,33.33333"/>
                      <path d="m448.88887,361.77776c0,0 29.33333,-61.33333 18.66667,-76c-10.66667,-14.66667 -61.33333,-38.66667 -74.66666,-37.33333c-13.33333,1.33333 -48,21.33333 -53.33333,22.66667c-5.33333,1.33333 -4,18.66667 10.66667,21.33333"/>
                      <path d="m419.55554,380.44443c0,0 17.33333,-58.66666 10.66667,-73.33333c-6.66667,-14.66667 -42.66667,-30.66667 -58.66666,-25.33333c-16,5.33333 -41.33333,30.66667 -42.66667,41.33333c-1.33333,10.66667 10.66667,16 18.66667,17.33333c8,1.33333 25.33333,-6.66667 30.66667,-12c5.33333,-5.33333 -2.66667,6.66667 -4,14.66667c-1.33333,8 -8,-2.66667 -18.66667,24"/>
                      <path d="m500.88887,308.44443c0,0 40,-22.66667 46.66667,-37.33333c6.66667,-14.66667 16,-62.66666 10.66667,-82.66666c-5.33333,-20 -24,-50.66667 -21.33333,-57.33333c2.66667,-6.66667 -38.66667,-5.33333 -32,40c6.66667,45.33333 10.66667,36 10.66667,34.66667c0,-1.33333 -16,13.33333 -16,36c0,22.66667 -10.66667,8 -11.55554,7.55557"/>
                    </svg>
                  </span>
                </button>
              `;
            }).join("");

            const showBombWarn = !!(f.day >= 2 && f.bombActive && !(f.draft && f.draft.bombTriggeredOnce));
            ensureTimers();
            const _tmrV = appState.god.timers;
            body = `
              <div class="note" style="margin-top:6px">${escapeHtml(appLang === "fa" ? "برای دفاع، بازیکنان نامزدشده را انتخاب کنید." : "Tap the players who have been nominated to defend themselves.")}</div>
              <div class="note" style="margin-top:4px">${escapeHtml(appLang === "fa" ? "اگر چالش خود را استفاده کرده‌اند، آیکون «چالش» را بزنید." : "Tap the \"Challenge\" icon if they've already used their challenge.")}</div>
              ${showBombWarn ? `<div class="note warn" style="margin-top:10px">${escapeHtml(t("tool.flow.bomb.active"))}</div>` : ``}
              <div class="timerRow" style="margin-top:10px; padding-bottom:10px; border-bottom:1px solid rgba(255,255,255,.08)">
                <div class="timerCard">
                  <div class="tname">${escapeHtml(t("tool.timer.turn"))}</div>
                  <div class="tval clickable" id="tm_talk">${formatMMSS(_tmrV.remaining.talk ?? _tmrV.talk)}</div>
                  <div style="display:flex; gap:6px; justify-content:center; align-items:center">
                    <button class="tbtn" id="tm_btn_talk" type="button" aria-label="Play/Pause"></button>
                    <button class="tbtn reset" id="tm_rst_talk" type="button" aria-label="Reset"><svg viewBox="0 0 24 24" fill="currentColor" aria-hidden="true"><path d="M12 5V1L7 6l5 5V7c3.31 0 6 2.69 6 6s-2.69 6-6 6-6-2.69-6-6H4c0 4.42 3.58 8 8 8s8-3.58 8-8-3.58-8-8-8z"/></svg></button>
                  </div>
                </div>
                <div class="timerCard">
                  <div class="tname">${escapeHtml(t("tool.timer.challenge"))}</div>
                  <div class="tval clickable" id="tm_challenge">${formatMMSS(_tmrV.remaining.challenge ?? _tmrV.challenge)}</div>
                  <div style="display:flex; gap:6px; justify-content:center; align-items:center">
                    <button class="tbtn" id="tm_btn_challenge" type="button" aria-label="Play/Pause"></button>
                    <button class="tbtn reset" id="tm_rst_challenge" type="button" aria-label="Reset"><svg viewBox="0 0 24 24" fill="currentColor" aria-hidden="true"><path d="M12 5V1L7 6l5 5V7c3.31 0 6 2.69 6 6s-2.69 6-6 6-6-2.69-6-6H4c0 4.42 3.58 8 8 8s8-3.58 8-8-3.58-8-8-8z"/></svg></button>
                  </div>
                </div>
              </div>
              <div style="height:10px"></div>
              <div class="fl-scrollable" style="display:grid; grid-template-columns:repeat(3,1fr); gap:8px; max-height:50vh; overflow:auto; -webkit-overflow-scrolling:touch;">
                ${cells || `<div style="color:var(--muted); font-weight:900; grid-column:1/-1">${escapeHtml(appLang === "fa" ? "بازیکن زنده‌ای وجود ندارد." : "No alive players.")}</div>`}
              </div>
            `;
          } else if (cur.id === "day_elim") {
            ensureTimers();
            const _tmrE = appState.god.timers;
            const d = f.draft || {};
            const votersAtVote = (d.voteVotersByDay && typeof d.voteVotersByDay[f.day] === "number")
              ? Math.max(0, Math.floor(Number(d.voteVotersByDay[f.day] || 0)))
              : aliveIdxs.length;
            const eligibleVoters = Math.max(0, votersAtVote - 1); // candidate cannot vote for self
            const defThreshold = getDefenseThreshold(eligibleVoters);
            // Load votes: prefer latest day_vote event (source of truth), fallback to draft.
            // When draft is empty (e.g. after back-navigation), merge from day_elim event so selections persist.
            let dayCounts = null;
            try {
              const evVote = (f.events || []).slice().reverse().find((e) => e && e.kind === "day_vote" && e.phase === "day" && e.day === f.day && e.data && e.data.counts);
              if (evVote && evVote.data && evVote.data.counts && typeof evVote.data.counts === "object") dayCounts = evVote.data.counts;
            } catch {}
            if (!dayCounts) {
              dayCounts = (d.voteCountsByDay && d.voteCountsByDay[f.day] && typeof d.voteCountsByDay[f.day] === "object")
                ? d.voteCountsByDay[f.day]
                : null;
            }
            // Merge from day_elim event when draft has no elim data — selections persist when navigating back.
            const hasElimDraft = (d.elimVotesByDay && d.elimVotesByDay[f.day] && Object.keys(d.elimVotesByDay[f.day] || {}).length) ||
              (d.voteCandidatesByDay && Array.isArray(d.voteCandidatesByDay[f.day]) && d.voteCandidatesByDay[f.day].length);
            if (!hasElimDraft) {
              try {
                const evElim = (f.events || []).slice().reverse().find((e) => e && e.kind === "day_elim" && e.phase === "day" && e.day === f.day && e.data && e.data.counts);
                if (evElim && evElim.data && evElim.data.counts && typeof evElim.data.counts === "object") {
                  const counts = evElim.data.counts;
                  const cands = Object.keys(counts).map((k) => parseInt(k, 10)).filter((x) => Number.isFinite(x));
                  if (cands.length) {
                    if (!d.elimVotesByDay || typeof d.elimVotesByDay !== "object") d.elimVotesByDay = {};
                    d.elimVotesByDay[f.day] = { ...counts };
                    if (!d.voteCandidatesByDay || typeof d.voteCandidatesByDay !== "object") d.voteCandidatesByDay = {};
                    d.voteCandidatesByDay[f.day] = cands.slice();
                    if (!d.elimCandidatesByDay || typeof d.elimCandidatesByDay !== "object") d.elimCandidatesByDay = {};
                    d.elimCandidatesByDay[f.day] = cands.slice();
                    if (evElim.data.leaders && Array.isArray(evElim.data.leaders)) {
                      if (!d.elimLeadersByDay || typeof d.elimLeadersByDay !== "object") d.elimLeadersByDay = {};
                      d.elimLeadersByDay[f.day] = evElim.data.leaders.slice();
                    }
                    f.draft = d;
                    try { saveState(appState); } catch {}
                  }
                }
              } catch {}
            }
            // Keep draft in sync so the UI stays consistent even if we came from older saves.
            if (dayCounts && typeof dayCounts === "object") {
              try {
                if (!d.voteCountsByDay || typeof d.voteCountsByDay !== "object") d.voteCountsByDay = {};
                d.voteCountsByDay[f.day] = dayCounts;
                f.draft = d;
                saveState(appState);
              } catch {}
            }
            const roster = (() => {
              try {
                const r = (d.voteRosterByDay && Array.isArray(d.voteRosterByDay[f.day])) ? d.voteRosterByDay[f.day] : null;
                if (r && r.length) return r.slice();
              } catch {}
              // fallback: consider keys in dayCounts
              try {
                if (dayCounts && typeof dayCounts === "object") {
                  return Object.keys(dayCounts).map((k) => parseInt(k, 10)).filter((x) => Number.isFinite(x));
                }
              } catch {}
              return aliveIdxs.slice();
            })();
            // Prefer direct button-selection (new flow) over old threshold-based computation.
            const candidatesBase = Array.isArray(d.voteCandidatesByDay && d.voteCandidatesByDay[f.day])
              ? d.voteCandidatesByDay[f.day].map((i) => ({ idx: parseInt(i, 10), v: 1 })).filter((x) => Number.isFinite(x.idx))
              : (dayCounts
                  ? roster
                      .map((idx) => {
                        const v = (typeof dayCounts[idx] === "number") ? dayCounts[idx] : (typeof dayCounts[String(idx)] === "number" ? dayCounts[String(idx)] : 0);
                        return { idx, v: Math.max(0, Math.floor(Number(v || 0))) };
                      })
                      .filter((x) => x.v >= defThreshold)
                      .sort((a, b) => (b.v - a.v) || (a.idx - b.idx))
                  : []);
            if (!d.elimCandidatesByDay || typeof d.elimCandidatesByDay !== "object") d.elimCandidatesByDay = {};
            // Keep defense list LIVE (derived from latest voting).
            // Silenced players remain in the list but cannot defend (status shown in cast).
            const defenseList = candidatesBase.map((x) => x.idx);
            const prevList = Array.isArray(d.elimCandidatesByDay[f.day]) ? d.elimCandidatesByDay[f.day] : [];
            const changed = JSON.stringify(prevList || []) !== JSON.stringify(defenseList || []);
            d.elimCandidatesByDay[f.day] = defenseList;

            // If the defense list changed (due to editing Voting), reset elimination votes/picks and clear any previous out.
            if (changed) {
              if (!d.elimVotesByDay || typeof d.elimVotesByDay !== "object") d.elimVotesByDay = {};
              d.elimVotesByDay[f.day] = {};
              d.elimLeadersByDay = (d.elimLeadersByDay && typeof d.elimLeadersByDay === "object") ? d.elimLeadersByDay : {};
              d.elimLeadersByDay[f.day] = [];
              d.elimPickedByDay = (d.elimPickedByDay && typeof d.elimPickedByDay === "object") ? d.elimPickedByDay : {};
              d.elimPickedByDay[f.day] = null;
              try { addFlowEvent("day_elim_out", { out: null, reset: true }); } catch {}
              try { applyDayElimFromPayload(f, { out: null }); } catch {}
              try { renderCast(); } catch {}
              try { if (typeof renderNameGrid === "function") renderNameGrid(); } catch {}
            }
            f.draft = d;
            try { saveState(appState); } catch {}

            const candIdxs = Array.isArray(d.elimCandidatesByDay[f.day]) ? d.elimCandidatesByDay[f.day] : defenseList;
            const elimThreshold = defThreshold; // single-defendant: need majority to be out
            const isSingleDef = candIdxs.length === 1;

            if (!d.elimVotesByDay || typeof d.elimVotesByDay !== "object") d.elimVotesByDay = {};
            const saved = (d.elimVotesByDay && d.elimVotesByDay[f.day]) ? d.elimVotesByDay[f.day] : null;
            const maxVotes = Math.max(0, aliveIdxs.length - 1);
            const mkVoteOpts = (sel) => {
              const s = Math.max(0, Math.min(maxVotes, Math.floor(Number(sel || 0))));
              const out = [];
              for (let i = 0; i <= maxVotes; i++) out.push(`<option value="${i}" ${i === s ? "selected" : ""}>${fmtNum(i)}</option>`);
              return out.join("");
            };

            const silencedForElim = new Set();
            try {
              const dayKey = String(f.day || 1);
              const sil = (d.silencedByDay && Array.isArray(d.silencedByDay[dayKey])) ? d.silencedByDay[dayKey] : [];
              for (const i of sil) { const n = parseInt(i, 10); if (Number.isFinite(n)) silencedForElim.add(n); }
            } catch {}
            const rows = candIdxs.map((idx) => {
              const val = saved && typeof saved[idx] === "number" ? saved[idx] : (saved && typeof saved[String(idx)] === "number" ? saved[String(idx)] : 0);
              const alive = (draw.players && draw.players[idx]) ? (draw.players[idx].alive !== false) : true;
              const st = alive ? "" : "opacity:.55; filter:saturate(.2);";
              const outTxt = alive ? "" : ` <span style="color:var(--muted); font-weight:900">(${escapeHtml(appLang === "fa" ? "خارج شد" : "out")})</span>`;
              const silentBadge = silencedForElim.has(idx) ? ` <span style="color:var(--muted); font-size:11px; font-weight:900">(${escapeHtml(t("lifeSheet.silent"))})</span>` : "";
              return `
                <div style="display:grid; grid-template-columns: 1fr 120px; gap:10px; align-items:center; padding:6px 0; border-bottom:1px solid rgba(255,255,255,.06); ${st}">
                  <div style="font-weight:1100">${escapeHtml(names[idx] || t("common.playerN", { n: idx + 1 }))}${silentBadge}${outTxt}</div>
                  <select id="fl_elim_${idx}">${mkVoteOpts(val)}</select>
                </div>
              `;
            }).join("");

            // compute current result from saved elimination votes (if any)
            const savedCounts = (saved && typeof saved === "object") ? saved : null;
            const leaders = savedCounts
              ? Object.keys(savedCounts)
                  .map((k) => ({ idx: parseInt(k, 10), v: Math.max(0, Math.floor(Number(savedCounts[k] || 0))) }))
                  .filter((x) => Number.isFinite(x.idx))
                  .sort((a, b) => (b.v - a.v) || (a.idx - b.idx))
              : [];
            const best = leaders.length ? leaders[0].v : 0;
            const top = (best > 0) ? leaders.filter((x) => x.v === best) : [];
            const picked = (d.elimPickedByDay && d.elimPickedByDay[f.day] !== undefined) ? d.elimPickedByDay[f.day] : null;
            const pickedIdx = (() => {
              const n = parseInt(String(picked ?? ""), 10);
              return Number.isFinite(n) ? n : null;
            })();
            // Fallback: if we have a saved draw event for today, use it (prevents losing the picked tie-winner).
            const pickedIdxFromEvent = (() => {
              try {
                const ev = (f.events || []).slice().reverse().find((e) => e && e.kind === "day_elim_draw" && Number(e.day) === Number(f.day));
                const p = ev && ev.data ? ev.data.picked : null;
                const n = parseInt(String(p ?? ""), 10);
                return Number.isFinite(n) ? n : null;
              } catch {
                return null;
              }
            })();
            const pickedIdxFinal = (pickedIdx !== null && Number.isFinite(pickedIdx))
              ? pickedIdx
              : (pickedIdxFromEvent !== null && top.some((x) => x.idx === pickedIdxFromEvent))
                ? pickedIdxFromEvent
                : null;
            // If we recovered from events, persist it.
            if ((pickedIdxFinal !== null) && (pickedIdx === null || !Number.isFinite(pickedIdx))) {
              try {
                d.elimPickedByDay = (d.elimPickedByDay && typeof d.elimPickedByDay === "object") ? d.elimPickedByDay : {};
                d.elimPickedByDay[f.day] = pickedIdxFinal;
                f.draft = d;
                saveState(appState);
              } catch {}
            }
            const showActions = !!(top.length && best > 0);
            const showDraw = top.length > 1;
            const canOut = (top.length === 1) || (pickedIdxFinal !== null && Number.isFinite(pickedIdxFinal));

            // Inline "who was voted out" + Last Move (shown only when a single person is picked).
            const pickedOutIdx = (() => {
              try {
                if (isSingleDef) {
                  const only = candIdxs[0];
                  const v = savedCounts && (typeof savedCounts[only] === "number" || typeof savedCounts[String(only)] === "number")
                    ? (typeof savedCounts[only] === "number" ? savedCounts[only] : savedCounts[String(only)])
                    : 0;
                  const vv = Math.max(0, Math.floor(Number(v || 0)));
                  return (vv >= elimThreshold) ? only : null;
                }
                if (!showActions) return null;
                if (top.length === 1) return top[0].idx;
                if (pickedIdxFinal !== null && Number.isFinite(pickedIdxFinal)) return pickedIdxFinal;
                return null;
              } catch {
                return null;
              }
            })();
            const _scenarioCfg = getScenarioConfig(typeof getDrawScenarioForFlow === "function" ? getDrawScenarioForFlow() : getScenario());
            const supportsLastMove = !!_scenarioCfg.features?.lastMove;
            const showLastMove = !!(pickedOutIdx !== null && supportsLastMove);
            const supportsEndCards = !!_scenarioCfg.features?.endCards;
            const endCardLine = (() => {
              try {
                if (!supportsEndCards) return "";
                if (pickedOutIdx === null || !Number.isFinite(Number(pickedOutIdx))) return "";

                const endCards = _scenarioCfg.eliminationCards || [];
                const labelFor = (id) => {
                  const c = endCards.find((x) => x.id === id);
                  if (!c) return String(id || "");
                  return appLang === "fa" ? c.fa : c.en;
                };
                if (!appState.god) appState.god = {};
                if (!appState.god.endCards || typeof appState.god.endCards !== "object") {
                  appState.god.endCards = { byDay: {}, used: [] };
                }
                if (!appState.god.endCards.byDay || typeof appState.god.endCards.byDay !== "object") appState.god.endCards.byDay = {};
                if (!Array.isArray(appState.god.endCards.used)) {
                  appState.god.endCards.used = [];
                  // Migrate: populate used from existing byDay (old saves without used tracking).
                  for (const rec of Object.values(appState.god.endCards.byDay || {})) {
                    if (rec && rec.cardId && !appState.god.endCards.used.includes(rec.cardId)) {
                      appState.god.endCards.used.push(rec.cardId);
                    }
                  }
                }
                const byDay = appState.god.endCards.byDay;
                const usedSet = new Set(appState.god.endCards.used || []);
                const dayKey = String(f.day || 1);
                const existing = byDay[dayKey] && typeof byDay[dayKey] === "object" ? byDay[dayKey] : null;
                // If day assignment exists but for a different player, reset it and return card to pool.
                if (existing && Number.isFinite(Number(existing.out)) && parseInt(existing.out, 10) !== parseInt(pickedOutIdx, 10)) {
                  if (existing.cardId) {
                    usedSet.delete(existing.cardId);
                    const u = appState.god.endCards.used || [];
                    const idx = u.indexOf(existing.cardId);
                    if (idx >= 0) u.splice(idx, 1);
                    appState.god.endCards.used = u;
                  }
                  delete byDay[dayKey];
                }
                let rec = byDay[dayKey] && typeof byDay[dayKey] === "object" ? byDay[dayKey] : null;
                const isValidCard = rec && rec.cardId && endCards.some((c) => c.id === rec.cardId);
                if (!rec || !rec.cardId || !isValidCard) {
                  const remaining = endCards.filter((c) => !usedSet.has(c.id));
                  const picked = remaining.length ? remaining[Math.floor(Math.random() * remaining.length)] : null;
                  rec = picked ? { out: parseInt(pickedOutIdx, 10), cardId: picked.id, at: Date.now() } : null;
                  byDay[dayKey] = rec;
                  if (picked) {
                    (appState.god.endCards.used || []).push(picked.id);
                    appState.god.endCards.used = appState.god.endCards.used || [];
                  }
                  saveState(appState);
                  if (!picked && remaining.length === 0) {
                    return `<div class="note result" style="margin-top:10px">${escapeHtml(appLang === "fa" ? "همه کارت‌ها استفاده شده‌اند." : "All end cards have been used.")}</div>`;
                  }
                }
                if (!rec || !rec.cardId) return "";
                const nm = names[pickedOutIdx] || t("common.playerN", { n: pickedOutIdx + 1 });
                const cardLabel = labelFor(rec.cardId);
                return `<div class="note result" style="margin-top:10px">${escapeHtml(t("tool.flow.endCards.for", { name: nm, card: cardLabel }))}</div>`;
              } catch {
                return "";
              }
            })();
            const tieLine = (() => {
              try {
                if (!showActions) return "";
                if (top.length <= 1) return "";
                if (pickedOutIdx !== null) return "";
                const tieNames = top.map((x) => `${names[x.idx] || t("common.playerN", { n: x.idx + 1 })} (${x.v})`);
                return `${t("tool.flow.elim.tie")}: ${t("tool.flow.elim.notChosenYet")} • ${tieNames.join(appLang === "fa" ? "، " : ", ")}`;
              } catch {
                return "";
              }
            })();

            const singleLine = (() => {
              try {
                if (!isSingleDef) return "";
                const only = candIdxs[0];
                const v = savedCounts && (typeof savedCounts[only] === "number" || typeof savedCounts[String(only)] === "number")
                  ? (typeof savedCounts[only] === "number" ? savedCounts[only] : savedCounts[String(only)])
                  : 0;
                const vv = Math.max(0, Math.floor(Number(v || 0)));
                if (vv >= elimThreshold) return "";
                return t("tool.flow.elim.single.notEnough", { c: vv, n: elimThreshold });
              } catch {
                return "";
              }
            })();
            const lastMoveUi = (() => {
              if (!showLastMove) return "";
              try {
                const lastMoveCards = _scenarioCfg.eliminationCards || [];
                const labelFor = (id) => {
                  const c = lastMoveCards.find((x) => x.id === id);
                  if (!c) return String(id || "");
                  return appLang === "fa" ? c.fa : c.en;
                };
                if (!appState.god.lastMove || typeof appState.god.lastMove !== "object") {
                  appState.god.lastMove = { last: null, at: null, used: [] };
                } else {
                  if (!Array.isArray(appState.god.lastMove.used)) appState.god.lastMove.used = [];
                }
                const used = new Set(appState.god.lastMove.used || []);
                const remaining = lastMoveCards.filter((c) => !used.has(c.id));
                const lastId = appState.god.lastMove && appState.god.lastMove.last ? appState.god.lastMove.last : null;
                const last = lastId ? labelFor(lastId) : null;
                const listHtml = lastMoveCards.map((c) => {
                  const isUsed = used.has(c.id);
                  const txt = labelFor(c.id);
                  const st = isUsed ? 'opacity:.45; filter:saturate(.2); text-decoration:line-through;' : '';
                  return `<div style="padding:6px 0;font-weight:950;${st}">${escapeHtml(txt)}</div>`;
                }).join("");
                return `
                  <div style="height:12px"></div>
                  <div style="font-weight:1100">${escapeHtml(t("tool.flow.outcome.lastMove"))}</div>
                  <div style="height:8px"></div>
                  <div class="fl-scrollable" style="border:1px solid rgba(255,255,255,.08); border-radius:14px; padding:10px; background: rgba(17,24,36,.25); max-height: 34vh; overflow:auto; -webkit-overflow-scrolling: touch;">
                    <div style="font-weight:1100;margin-bottom:8px">${escapeHtml(t("tool.lastMove.header"))}</div>
                    ${listHtml}
                  </div>
                  <div style="height:10px"></div>
                  <button class="btn primary" id="lm_draw_elim" type="button" ${remaining.length ? "" : "disabled"}>${escapeHtml(t("tool.lastMove.draw"))}</button>
                  <div class="note" id="lm_note_elim" style="${remaining.length ? "display:none" : "display:block"}; margin-top:10px">${escapeHtml(remaining.length ? "" : t("tool.lastMove.allUsed"))}</div>
                  <div style="height:10px"></div>
                  <div style="font-weight:1100">${escapeHtml(t("tool.lastMove.result"))} <span id="lm_res_elim">${last ? escapeHtml(last) : "—"}</span></div>
                `;
              } catch {
                return "";
              }
            })();

            const researcherChainLine = (() => {
              try {
                if (pickedOutIdx === null || !Number.isFinite(pickedOutIdx)) return "";
                const votedOutPlayer = draw.players[pickedOutIdx];
                if (!votedOutPlayer || votedOutPlayer.roleId !== "researcher") return "";
                const prevNightKey = String((f.day || 1) - 1);
                const prevNightActions = (d.nightActionsByNight && d.nightActionsByNight[prevNightKey]) ? d.nightActionsByNight[prevNightKey] : null;
                if (!prevNightActions) return "";
                const linkedIdxRaw = prevNightActions.researcherLink;
                const linkedIdx = (linkedIdxRaw !== null && linkedIdxRaw !== undefined && Number.isFinite(parseInt(linkedIdxRaw, 10))) ? parseInt(linkedIdxRaw, 10) : null;
                if (linkedIdx === null || !draw.players[linkedIdx]) return "";
                const linkedPlayer = draw.players[linkedIdx];
                const linkedRoleId = linkedPlayer.roleId || "citizen";
                if (linkedRoleId === "mafiaBoss") return "";
                if (scenario === "bazras" && linkedRoleId !== "nato" && linkedRoleId !== "swindler") return "";
                const linkedName = names[linkedIdx] || t("common.playerN", { n: linkedIdx + 1 });
                const msg = appLang === "fa"
                  ? `⚠ ${linkedName} (که محقق با او لینک داشت) نیز از بازی خارج می‌شود.`
                  : `⚠ ${linkedName} (linked to Researcher) is also eliminated.`;
                return `<div class="note result" style="margin-top:8px">${escapeHtml(msg)}</div>`;
              } catch {
                return "";
              }
            })();

            body = `
              <div class="note" style="margin-top:6px">${escapeHtml(t("tool.flow.elim.hint"))}</div>
              <div style="height:8px"></div>
              <div class="note">${escapeHtml(t((getScenarioConfig(scenario).voteThreshold === "half_minus_one" ? "tool.flow.defense.threshold.halfMinusOne" : "tool.flow.defense.threshold"), { n: defThreshold, v: eligibleVoters }))}</div>
              ${isSingleDef ? `<div class="note" style="margin-top:6px">${escapeHtml(t((getScenarioConfig(scenario).voteThreshold === "half_minus_one" ? "tool.flow.elim.single.need.halfMinusOne" : "tool.flow.elim.single.need"), { n: elimThreshold, v: eligibleVoters }))}</div>` : ``}
              <div style="margin-top:10px; padding-bottom:10px; border-bottom:1px solid rgba(255,255,255,.08)">
                <div class="timerCard" style="max-width:none">
                  <div class="tname">${escapeHtml(t("tool.timer.defense"))}</div>
                  <div class="tval clickable" id="tm_defense">${formatMMSS(_tmrE.remaining.defense ?? _tmrE.defense)}</div>
                  <div style="display:flex; gap:6px; justify-content:center; align-items:center">
                    <button class="tbtn" id="tm_btn_defense" type="button" aria-label="Play/Pause"></button>
                    <button class="tbtn reset" id="tm_rst_defense" type="button" aria-label="Reset"><svg viewBox="0 0 24 24" fill="currentColor" aria-hidden="true"><path d="M12 5V1L7 6l5 5V7c3.31 0 6 2.69 6 6s-2.69 6-6 6-6-2.69-6-6H4c0 4.42 3.58 8 8 8s8-3.58 8-8-3.58-8-8-8z"/></svg></button>
                  </div>
                </div>
              </div>
              <div style="height:10px"></div>
              <div style="display:flex; align-items:baseline; justify-content:flex-end; gap:10px">
                <div style="color:var(--muted); font-weight:900; font-size:12px">${escapeHtml(t("tool.flow.elim.votes"))}</div>
              </div>
              <div style="height:6px"></div>
              <div class="fl-scrollable" style="border:1px solid rgba(255,255,255,.08); border-radius:14px; padding:10px; background: rgba(17,24,36,.25); max-height: 46vh; overflow:auto; -webkit-overflow-scrolling: touch;">
                ${(dayCounts || Array.isArray(d.voteCandidatesByDay && d.voteCandidatesByDay[f.day]))
                  ? (rows || `<div style="color:var(--muted); font-weight:900">${escapeHtml(t("tool.flow.elim.noCandidates"))}</div>`)
                  : `<div style="color:var(--muted); font-weight:900">${escapeHtml(t("tool.flow.defense.needVotes"))}</div>`}
              </div>
              <div style="height:10px"></div>

              <div class="actions" id="fl_elim_actions" style="margin-top:10px; ${showActions ? "display:flex" : "display:none"}; justify-content:flex-start; gap:10px">
                <button class="btn" id="fl_elim_draw" type="button" style="${showDraw ? "" : "display:none"}">${escapeHtml(t("tool.flow.elim.draw"))}</button>
              </div>
              <div style="margin-top:14px; padding-top:12px; border-top:1px solid rgba(255,255,255,.08)">
                ${pickedOutIdx !== null
                  ? `<div id="fl_elim_result_line" class="note result">${escapeHtml(t("tool.flow.outcome.votedOut"))} <b>${escapeHtml(names[pickedOutIdx] || t("common.playerN", { n: pickedOutIdx + 1 }))}</b></div>`
                  : (tieLine
                      ? `<div id="fl_elim_result_line" class="note result">${escapeHtml(tieLine)}</div>`
                      : (singleLine
                          ? `<div id="fl_elim_result_line" class="note result">${escapeHtml(singleLine)}</div>`
                          : `<div id="fl_elim_result_line" class="note result">${escapeHtml(t("tool.flow.outcome.none"))}</div>`))}
                ${endCardLine}
                ${researcherChainLine}
                ${lastMoveUi}
              </div>
            `;
          } else if (cur.id && String(cur.id).startsWith("day_end_card_")) {
            const d = f.draft || {};
            const cardId = cur.id.replace("day_end_card_", "");
            const dayKey = String(f.day || 1);
            const ev = (f.events || []).slice().reverse().find((e) => e && e.kind === "day_elim_out" && e.phase === "day" && e.day === f.day && e.data);
            const outIdx = ev && ev.data && ev.data.out !== null && ev.data.out !== undefined && Number.isFinite(Number(ev.data.out)) ? parseInt(ev.data.out, 10) : null;
            const byDay = appState.god && appState.god.endCards && appState.god.endCards.byDay ? appState.god.endCards.byDay : {};
            const rec = byDay[dayKey] && typeof byDay[dayKey] === "object" ? byDay[dayKey] : null;
            const votedOutName = outIdx !== null ? (names[outIdx] || t("common.playerN", { n: outIdx + 1 })) : "";
            const _scenarioCfg = getScenarioConfig(typeof getDrawScenarioForFlow === "function" ? getDrawScenarioForFlow() : getScenario());
            const endCards = _scenarioCfg.eliminationCards || [];
            const cardInfo = endCards.find((x) => x.id === cardId);
            const cardLabel = cardInfo ? (appLang === "fa" ? cardInfo.fa : cardInfo.en) : cardId;
            if (!d.endCardActionByDay || typeof d.endCardActionByDay !== "object") d.endCardActionByDay = {};
            const targetIdxs = (draw.players || []).map((_, i) => i).filter((i) => i !== outIdx && draw.players[i] && draw.players[i].alive !== false);
            const nPlayers = (draw.players || []).length;
            const aliveCount = targetIdxs.length; // voted-out is already dead when we're on end card step
            const isSecondHalf = aliveCount <= nPlayers / 2;
            const hintText = cardId === "face_change"
              ? (appLang === "fa" ? `${votedOutName} می‌تواند نقش خود را با یک بازیکن دیگر عوض کند (ابتدای شب، مخفیانه).` : `${votedOutName} can swap their role with another player (secretly at night start).`)
              : cardId === "handcuffs"
                ? (appLang === "fa" ? `${votedOutName} یک نفر را دستبند می‌زند؛ آن بازیکن برای یک روز قابلیت‌اش را از دست می‌دهد.` : `${votedOutName} handcuffs one player; they lose their ability for one day.`)
                : cardId === "beautiful_mind"
                  ? (appLang === "fa" ? `${votedOutName} یک شانس دارد نوستراداموس را حدس بزند. اگر درست بود، جای او می‌نشیند و نوستراداموس خارج می‌شود.` : `${votedOutName} gets one chance to guess who Nostradamus is. If correct, they replace Nostradamus (who is eliminated).`)
                  : cardId === "silence_lambs"
                    ? (appLang === "fa"
                      ? `${votedOutName} می‌تواند ${isSecondHalf ? "۱ نفر" : "۲ نفر"} را ساکت کند (حق دفاع ندارند).`
                      : `${votedOutName} can silence ${isSecondHalf ? "1" : "2"} player(s) (no defense right).`)
                    : (appLang === "fa" ? `${cardLabel} — انتخاب هدف` : `${cardLabel} — pick target`);
            let cardsHtml;
            if (cardId === "silence_lambs") {
              const maxSilence = isSecondHalf ? 1 : 2;
              const savedTargets = (d.endCardActionByDay[dayKey] && Array.isArray(d.endCardActionByDay[dayKey].targets)) ? d.endCardActionByDay[dayKey].targets : [];
              cardsHtml = mkNightMultiPickCards("fl_end_card_silence_targets", savedTargets, maxSilence, cardLabel, targetIdxs);
            } else {
              const savedTarget = (d.endCardActionByDay[dayKey] && d.endCardActionByDay[dayKey].target != null) ? parseInt(d.endCardActionByDay[dayKey].target, 10) : null;
              cardsHtml = mkNightTargetCards("fl_end_card_target", savedTarget !== null && Number.isFinite(savedTarget) ? savedTarget : null, cardLabel, targetIdxs);
            }
            body = `
              <div class="note" style="margin-bottom:10px">${escapeHtml(hintText)}</div>
              <div class="note result" style="margin-bottom:8px">${escapeHtml(t("tool.flow.outcome.votedOut"))} <b>${escapeHtml(votedOutName)}</b> — ${escapeHtml(cardLabel)}</div>
              ${cardsHtml}
            `;
          } else if (cur.id === "kabo_trust_vote") {
            const d = f.draft || {};
            const dayKey = String(f.day || 1);
            if (!d.kaboTrustVotesByDay || typeof d.kaboTrustVotesByDay !== "object") d.kaboTrustVotesByDay = {};
            const votes = (typeof d.kaboTrustVotesByDay[dayKey] === "object" && d.kaboTrustVotesByDay[dayKey]) ? d.kaboTrustVotesByDay[dayKey] : {};
            // Auto-derive trusted person from max votes
            let maxVotes = 0; let trustedIdxAuto = null; let tieCount = 0;
            for (const idx of aliveIdxs) {
              const v = Math.max(0, parseInt(votes[idx] || 0, 10));
              if (v > maxVotes) { maxVotes = v; trustedIdxAuto = idx; tieCount = 1; }
              else if (v === maxVotes && maxVotes > 0) tieCount++;
            }
            const isTie = tieCount > 1;
            if (!d.kaboTrustedByDay || typeof d.kaboTrustedByDay !== "object") d.kaboTrustedByDay = {};
            if (isTie) {
              // Clear any stale trusted person — tie means no trusted person today.
              if (d.kaboTrustedByDay[dayKey] != null) {
                d.kaboTrustedByDay[dayKey] = null;
                f.draft = d; try { saveState(appState); } catch {}
              }
            } else if (maxVotes > 0 && trustedIdxAuto !== null) {
              d.kaboTrustedByDay[dayKey] = trustedIdxAuto;
              f.draft = d; try { saveState(appState); } catch {}
            }
            const trustedIdx = (!isTie && maxVotes > 0) ? trustedIdxAuto : null;
            const _minusSvg = `<svg viewBox="0 0 20 20" width="14" height="14" fill="currentColor"><rect x="3" y="9" width="14" height="2" rx="1"/></svg>`;
            const _plusSvg  = `<svg viewBox="0 0 20 20" width="14" height="14" fill="currentColor"><rect x="3" y="9" width="14" height="2" rx="1"/><rect x="9" y="3" width="2" height="14" rx="1"/></svg>`;
            const mkTrustCard = (idx) => {
              const nm = escapeHtml(names[idx] || t("common.playerN", { n: idx + 1 }));
              const v = Math.max(0, parseInt(votes[idx] || 0, 10));
              const isTrusted = trustedIdx === idx;
              const cs = isTrusted
                ? "background:rgba(255,200,0,.18); border:2px solid rgba(255,200,0,.7);"
                : "background:rgba(255,255,255,.05); border:2px solid rgba(255,255,255,.10);";
              return `
                <div class="kabo_trust_card" data-idx="${idx}"
                  style="border-radius:14px; padding:8px 6px; ${cs} display:flex; flex-direction:column; align-items:center; justify-content:center; gap:6px; box-shadow:0 2px 8px rgba(0,0,0,.2); aspect-ratio:1/1; overflow:hidden">
                  <div style="font-weight:1100; font-size:12px; text-align:center; line-height:1.2; word-break:break-word">${nm}</div>
                  <div style="font-size:10px; font-weight:1100; visibility:${isTrusted ? "visible" : "hidden"}; color:rgba(255,200,0,.9)">${escapeHtml(appLang === "fa" ? "معتمد" : "Trusted")}</div>
                  <div style="display:flex; align-items:center; gap:8px">
                    <button class="kabo_trust_minus" data-idx="${idx}" type="button" style="width:32px;height:32px;border-radius:9px;background:rgba(255,255,255,.1);border:1px solid rgba(255,255,255,.18);color:rgba(255,255,255,.85);cursor:pointer;display:flex;align-items:center;justify-content:center;flex-shrink:0">${_minusSvg}</button>
                    <span class="kabo_trust_count" data-idx="${idx}" style="min-width:24px;text-align:center;font-size:18px;font-weight:1200">${v}</span>
                    <button class="kabo_trust_plus" data-idx="${idx}" type="button" style="width:32px;height:32px;border-radius:9px;background:rgba(255,255,255,.1);border:1px solid rgba(255,255,255,.18);color:rgba(255,255,255,.85);cursor:pointer;display:flex;align-items:center;justify-content:center;flex-shrink:0">${_plusSvg}</button>
                  </div>
                </div>`;
            };
            body = `<div class="toolBox">
              <div class="note" style="margin-bottom:10px">${escapeHtml(appLang === "fa"
                ? "هر بازیکن رأی اعتماد می‌دهد. بیشترین رأی = معتمد. معتمد ۲ مظنون انتخاب خواهد کرد."
                : "Each player votes. Most votes = Trusted person. The Trusted person will pick 2 suspects.")}</div>
              <div style="display:grid; grid-template-columns:repeat(3,1fr); gap:8px; margin-bottom:10px">
                ${aliveIdxs.map(mkTrustCard).join("")}
              </div>
              <div style="font-weight:1100">${escapeHtml(appLang === "fa" ? "معتمد: " : "Trusted: ")}${
                trustedIdx !== null
                  ? escapeHtml(names[trustedIdx] || t("common.playerN", { n: trustedIdx + 1 }))
                  : isTie && maxVotes > 0
                    ? `<span style="color:rgba(255,200,0,.9)">${escapeHtml(appLang === "fa" ? "⚠ تساوی" : "⚠ Tie")}</span>`
                    : "__"
              }</div>
            </div>`;
          } else if (cur.id === "kabo_suspect_select") {
            const d = f.draft || {};
            const dayKey = String(f.day || 1);
            const trustedIdx = (d.kaboTrustedByDay && d.kaboTrustedByDay[dayKey] != null) ? d.kaboTrustedByDay[dayKey] : null;
            const trustedName = trustedIdx !== null ? (names[trustedIdx] || t("common.playerN", { n: trustedIdx + 1 })) : null;
            const savedSuspects = (d.kaboSuspectsByDay && Array.isArray(d.kaboSuspectsByDay[dayKey])) ? d.kaboSuspectsByDay[dayKey].map(Number) : [];
            const suspectSet = new Set(savedSuspects);
            const mkSuspectCard = (idx) => {
              const nm = escapeHtml(names[idx] || t("common.playerN", { n: idx + 1 }));
              const isSel = suspectSet.has(idx);
              const isTrusted = trustedIdx === idx;
              const cs = isTrusted
                ? "background:rgba(255,200,0,.08); border:2px solid rgba(255,200,0,.3); opacity:.55;"
                : isSel
                  ? "background:rgba(239,68,68,.18); border:2px solid rgba(239,68,68,.7);"
                  : "background:rgba(255,255,255,.05); border:2px solid rgba(255,255,255,.10);";
              return `
                <button class="kabo_suspect_btn" data-idx="${idx}" type="button" ${isTrusted ? "disabled" : ""}
                  style="border-radius:14px; padding:8px 6px; font-size:12px; font-weight:${isSel ? "1100" : "950"};
                         display:flex; flex-direction:column; align-items:center; justify-content:center; text-align:center;
                         cursor:${isTrusted ? "default" : "pointer"}; ${cs}; color:#fff; width:100%;
                         box-shadow:0 2px 8px rgba(0,0,0,.2); line-height:1.2; gap:4px;
                         aspect-ratio:1/1; overflow:hidden; word-break:break-word">
                  ${nm}
                  ${isSel ? `<span style="font-size:11px; color:rgba(239,68,68,.9)">${escapeHtml(appLang === "fa" ? "مظنون" : "Suspect")}</span>` : ""}
                  ${isTrusted ? `<span style="font-size:11px; color:rgba(255,200,0,.7)">${escapeHtml(appLang === "fa" ? "معتمد" : "Trusted")}</span>` : ""}
                </button>`;
            };
            body = `<div class="toolBox">
              <div class="note" style="margin-bottom:10px">${escapeHtml(appLang === "fa"
                ? "معتمد ۲ نفر را به عنوان مظنون انتخاب می‌کند."
                : "The Trusted person picks 2 suspects.")}</div>
              ${trustedName ? `<div style="margin-bottom:10px"><span style="font-weight:1100">${escapeHtml(appLang === "fa" ? "معتمد: " : "Trusted: ")}</span>${escapeHtml(trustedName)}</div>` : `<div class="note warn" style="margin-bottom:10px">${escapeHtml(appLang === "fa" ? "⚠ ابتدا معتمد را در مرحله رأی اعتماد مشخص کنید." : "⚠ Set the Trusted person in the Trust Vote step first.")}</div>`}
              ${savedSuspects.length >= 2
                ? `<div class="note pass" style="margin-bottom:10px">${escapeHtml(appLang === "fa" ? "✓ ۲ مظنون انتخاب شدند." : "✓ 2 suspects selected.")}</div>`
                : `<div class="note warn" style="margin-bottom:10px">${escapeHtml(appLang === "fa" ? `${fmtNum(savedSuspects.length)}/۲ مظنون انتخاب شده.` : `${savedSuspects.length}/2 suspects selected.`)}</div>`}
              <div style="display:grid; grid-template-columns:repeat(3,1fr); gap:8px">
                ${aliveIdxs.map(mkSuspectCard).join("")}
              </div>
            </div>`;
          } else if (cur.id === "kabo_midday") {
            const d = f.draft || {};
            const dayKey = String(f.day || 1);
            if (!d.kaboGunByDay || typeof d.kaboGunByDay !== "object") d.kaboGunByDay = {};
            const saved = d.kaboGunByDay[dayKey] || "";
            const gun1Real = saved === "gun1";
            const gun2Real = saved === "gun2";
            const gStyle = (real) => real
              ? "background:rgba(239,68,68,.22); border:2px solid rgba(239,68,68,.85); color:#fff;"
              : "background:rgba(255,255,255,.06); border:2px solid rgba(255,255,255,.18); color:rgba(255,255,255,.6);";
            body = `<div class="toolBox">
              <div class="note" style="margin-bottom:14px">${escapeHtml(appLang === "fa"
                ? "همه خوابیده‌اند. تیم مافیا بیدار می‌شود. کاپو مشخص می‌کند کدام گلوله واقعی است."
                : "Everyone is asleep. Mafia team wakes up. Capo picks which bullet is real.")}</div>
              <div style="display:grid; grid-template-columns:1fr 1fr; gap:10px">
                <button id="kabo_midday_gun1" type="button"
                  style="padding:20px 8px; border-radius:14px; cursor:pointer; font-size:14px; font-weight:1100; ${gStyle(gun1Real)}">
                  ${gunSvg} ${escapeHtml(appLang === "fa" ? "گلوله ۱" : "Gun 1")}
                </button>
                <button id="kabo_midday_gun2" type="button"
                  style="padding:20px 8px; border-radius:14px; cursor:pointer; font-size:14px; font-weight:1100; ${gStyle(gun2Real)}">
                  ${gunSvg} ${escapeHtml(appLang === "fa" ? "گلوله ۲" : "Gun 2")}
                </button>
              </div>
              <div style="margin-top:12px; font-weight:1100">${escapeHtml(appLang === "fa" ? "گلوله واقعی: " : "Real bullet: ")}${
                saved ? escapeHtml(saved === "gun1" ? (appLang === "fa" ? "گلوله ۱" : "Gun 1") : (appLang === "fa" ? "گلوله ۲" : "Gun 2")) : "__"
              }</div>
            </div>`;
          } else if (cur.id === "kabo_shoot") {
            const d = f.draft || {};
            const dayKey = String(f.day || 1);
            const realGun = (d.kaboGunByDay && d.kaboGunByDay[dayKey]) ? d.kaboGunByDay[dayKey] : null; // "gun1" | "gun2"
            const suspects = (d.kaboSuspectsByDay && Array.isArray(d.kaboSuspectsByDay[dayKey]) && d.kaboSuspectsByDay[dayKey].length) ? d.kaboSuspectsByDay[dayKey].slice(0, 2) : null;
            const s0 = suspects ? suspects[0] : null;
            const s1 = suspects ? suspects[1] : null;
            const s0Name = s0 != null ? (names[s0] || t("common.playerN", { n: s0 + 1 })) : null;
            const s1Name = s1 != null ? (names[s1] || t("common.playerN", { n: s1 + 1 })) : null;
            ensureTimers();
            const _tmrD = appState.god.timers;
            const rstSvg = `<svg viewBox="0 0 24 24" fill="currentColor" aria-hidden="true"><path d="M12 5V1L7 6l5 5V7c3.31 0 6 2.69 6 6s-2.69 6-6 6-6-2.69-6-6H4c0 4.42 3.58 8 8 8s8-3.58 8-8-3.58-8-8-8z"/></svg>`;
            const savedShoot = (d.kaboShootByDay && d.kaboShootByDay[String(f.day)]) ? d.kaboShootByDay[String(f.day)] : {};
            const gun1Target = (savedShoot.gun1 !== undefined && savedShoot.gun1 !== null) ? savedShoot.gun1 : null;
            const gun2Target = (savedShoot.gun2 !== undefined && savedShoot.gun2 !== null) ? savedShoot.gun2 : null;
            const dayKey2 = String(f.day || 1);
            const trustedIdx2 = (d.kaboTrustedByDay && d.kaboTrustedByDay[dayKey2] != null) ? d.kaboTrustedByDay[dayKey2] : null;
            const trustedName2 = trustedIdx2 !== null ? (names[trustedIdx2] || t("common.playerN", { n: trustedIdx2 + 1 })) : null;
            const mkGunOpts = (savedT) => {
              const s = savedT !== null ? String(savedT) : "";
              const opts = [`<option value="" ${s === "" ? "selected" : ""}>${escapeHtml(appLang === "fa" ? "↑ شلیک به هوا" : "↑ Shoot into air")}</option>`];
              const pool = suspects || aliveIdxs;
              for (const si of pool) {
                const v = String(si);
                const nm = names[si] || t("common.playerN", { n: si + 1 });
                const isAlive = (draw.players[si] || {}).alive !== false;
                opts.push(`<option value="${v}" ${v === s ? "selected" : ""} ${!isAlive ? "disabled" : ""}>${escapeHtml(nm + (!isAlive ? (appLang === "fa" ? " (خارج شد)" : " (out)") : ""))}</option>`);
              }
              return opts.join("");
            };
            const resultLine = (() => {
              if (!realGun) return "";
              const realTarget = realGun === "gun1" ? gun1Target : gun2Target;
              if (realTarget === null || realTarget === undefined) return "";
              const nm = names[realTarget] || t("common.playerN", { n: realTarget + 1 });
              return appLang === "fa" ? `${escapeHtml(nm)} از بازی خارج می‌شود.` : `${escapeHtml(nm)} is eliminated.`;
            })();
            const gun1CardStyle = realGun === "gun1" ? "border:2px solid rgba(239,68,68,.6); background:rgba(239,68,68,.06);" : "border:2px solid rgba(255,255,255,.15); background:rgba(255,255,255,.04);";
            const gun2CardStyle = realGun === "gun2" ? "border:2px solid rgba(239,68,68,.6); background:rgba(239,68,68,.06);" : "border:2px solid rgba(255,255,255,.15); background:rgba(255,255,255,.04);";
            body = `<div class="toolBox">
              <div class="note" style="margin-bottom:10px">${escapeHtml(appLang === "fa" ? "هر مظنون از خود دفاع می‌کند." : "Each suspect defends themselves.")}</div>
              <div style="margin-bottom:12px; line-height:2">
                <div><span style="color:var(--muted)">${escapeHtml(appLang === "fa" ? "مظنون ۱: " : "Suspect 1: ")}</span>${escapeHtml(s0Name || "—")}</div>
                <div><span style="color:var(--muted)">${escapeHtml(appLang === "fa" ? "مظنون ۲: " : "Suspect 2: ")}</span>${escapeHtml(s1Name || "—")}</div>
              </div>
              <div class="timerRow" style="grid-template-columns:1fr; margin-bottom:14px; padding-bottom:14px; border-bottom:1px solid rgba(255,255,255,.08)">
                <div class="timerCard">
                  <div class="tname">${escapeHtml(appLang === "fa" ? "زمان دفاع" : "Defense")}</div>
                  <div class="tval clickable" id="tm_defense">${formatMMSS(_tmrD.remaining.defense ?? _tmrD.defense)}</div>
                  <div style="display:flex; gap:6px; justify-content:center; align-items:center">
                    <button class="tbtn" id="tm_btn_defense" type="button" aria-label="Play/Pause"></button>
                    <button class="tbtn reset" id="tm_rst_defense" type="button" aria-label="Reset">${rstSvg}</button>
                  </div>
                </div>
              </div>
              <div class="note" style="margin-bottom:10px">${escapeHtml(appLang === "fa"
                ? "معتمد باید هر دو تفنگ را شلیک کند. نمی‌داند کدام گلوله واقعی است."
                : "Trusted person fires both guns — they don't know which has the real bullet.")}</div>
              ${trustedName2 ? `<div style="margin-bottom:10px"><span style="font-weight:1100">${escapeHtml(appLang === "fa" ? "معتمد: " : "Trusted: ")}</span>${escapeHtml(trustedName2)}</div>` : ""}
              ${!realGun ? `<div class="note warn" style="margin-bottom:10px">${escapeHtml(appLang === "fa" ? "⚠ گلوله واقعی توسط کاپو انتخاب نشده." : "⚠ Capo has not set the real bullet.")}</div>` : ""}
              ${realGun && gun1Target === null && gun2Target === null ? `<div class="note alert" style="margin-bottom:10px">${escapeHtml(t("tool.flow.kabo.bothAir"))}</div>` : ""}
              ${realGun && gun1Target !== null && gun2Target !== null && gun1Target === gun2Target ? `<div class="note alert" style="margin-bottom:10px">${escapeHtml(t("tool.flow.kabo.bothSame"))}</div>` : ""}
              <div style="border-radius:14px; padding:12px; margin-bottom:10px; ${gun1CardStyle}">
                <div style="font-weight:1100; margin-bottom:8px">${gunSvg} ${escapeHtml(appLang === "fa" ? "گلوله ۱" : "Gun 1")}</div>
                <label>${escapeHtml(appLang === "fa" ? "هدف" : "Target")}
                  <select id="fl_kabo_gun1_target">${mkGunOpts(gun1Target)}</select>
                </label>
              </div>
              <div style="border-radius:14px; padding:12px; ${gun2CardStyle}">
                <div style="font-weight:1100; margin-bottom:8px">${gunSvg} ${escapeHtml(appLang === "fa" ? "گلوله ۲" : "Gun 2")}</div>
                <label>${escapeHtml(appLang === "fa" ? "هدف" : "Target")}
                  <select id="fl_kabo_gun2_target">${mkGunOpts(gun2Target)}</select>
                </label>
              </div>
              ${resultLine ? `<div class="note result" style="margin-top:10px">${resultLine}</div>` : ""}
            </div>`;
          } else if (cur.id === "chaos_run") {
            const d = f.draft || {};
            if (!d.chaosPicks || typeof d.chaosPicks !== "object") d.chaosPicks = {};
            const chaosPicks = d.chaosPicks;
            const rstSvg = `<svg viewBox="0 0 24 24" fill="currentColor" aria-hidden="true"><path d="M12 5V1L7 6l5 5V7c3.31 0 6 2.69 6 6s-2.69 6-6 6-6-2.69-6-6H4c0 4.42 3.58 8 8 8s8-3.58 8-8-3.58-8-8-8z"/></svg>`;
            ensureTimers();
            const _tmrCh = appState.god.timers;
            if (!_tmrCh.chaos) _tmrCh.chaos = 120;
            if (_tmrCh.remaining.chaos == null) _tmrCh.remaining.chaos = _tmrCh.chaos;
            const aliveIdxs = (draw.players || []).map((p, i) => ({ p, i })).filter(({ p }) => p && p.alive !== false);
            const getTeam = (p) => { const r = roles[p.roleId]; return r ? r.teamFa : "شهر"; };
            const aliveMafia = aliveIdxs.filter(({ p }) => getTeam(p) === "مافیا");
            const aliveCitizens = aliveIdxs.filter(({ p }) => getTeam(p) === "شهر");
            const aliveIndep = aliveIdxs.filter(({ p }) => getTeam(p) === "مستقل");
            const parts = [];
            if (aliveMafia.length) parts.push(`${aliveMafia.length} ${appLang === "fa" ? "مافیا" : "Mafia"}`);
            if (aliveCitizens.length) parts.push(`${aliveCitizens.length} ${appLang === "fa" ? "شهروند" : "Citizen"}`);
            if (aliveIndep.length) parts.push(`${aliveIndep.length} ${appLang === "fa" ? "مستقل" : "Independent"}`);
            const computedWinner = (() => {
              const allPicked = aliveIdxs.every(({ i }) => chaosPicks[String(i)] !== undefined && chaosPicks[String(i)] !== null && chaosPicks[String(i)] !== "");
              if (!allPicked) return null;
              if (aliveMafia.length === 1 && aliveCitizens.length === 2 && aliveIndep.length === 0) {
                const mafI = String(aliveMafia[0].i);
                return aliveCitizens.some(({ i }) => String(chaosPicks[String(i)]) === mafI) ? "mafia" : "citizens";
              }
              if (aliveMafia.length === 1 && aliveCitizens.length === 1 && aliveIndep.length === 1) {
                const mafI = String(aliveMafia[0].i);
                return String(chaosPicks[String(aliveCitizens[0].i)]) === mafI ? "mafia" : "independent";
              }
              return null;
            })();
            const winnerLabel = computedWinner === "mafia" ? (appLang === "fa" ? "مافیا برنده است" : "Mafia wins")
              : computedWinner === "citizens" ? (appLang === "fa" ? "شهروندان برنده‌اند" : "Citizens win")
              : computedWinner === "independent" ? (appLang === "fa" ? "مستقل برنده است" : "Independent wins")
              : null;
            const picksHtml = aliveIdxs.map(({ p, i }) => {
              const nm = names[i] || t("common.playerN", { n: i + 1 });
              const rLabel = (() => { const r = roles[p.roleId]; if (!r) return p.roleId; return (appLang === "fa" && r.faName) ? r.faName : (ROLE_I18N[p.roleId] && ROLE_I18N[p.roleId].name) ? ROLE_I18N[p.roleId].name : p.roleId; })();
              const pickVal = chaosPicks[String(i)] !== undefined ? String(chaosPicks[String(i)]) : "";
              const opts = [`<option value="" ${pickVal === "" ? "selected" : ""}>—</option>`].concat(
                aliveIdxs.filter(({ i: j }) => j !== i).map(({ i: j }) => {
                  const nm2 = names[j] || t("common.playerN", { n: j + 1 });
                  return `<option value="${j}" ${String(j) === pickVal ? "selected" : ""}>${escapeHtml(nm2)}</option>`;
                })
              ).join("");
              return `<label style="margin-top:8px">${escapeHtml(nm)} (${escapeHtml(rLabel)}) ${escapeHtml(appLang === "fa" ? "انتخاب می‌کند:" : "picks:")}
                <select id="fl_chaos_pick_${i}" data-chaos-idx="${i}">${opts}</select>
              </label>`;
            }).join("");
            body = `<div class="toolBox">
              <div class="note" style="margin-bottom:10px">${escapeHtml(appLang === "fa" ? `هرج و مرج — ${parts.join("، ")}. هر بازیکن یک نفر دیگر را انتخاب می‌کند.` : `Chaos — ${parts.join(", ")}. Each player picks one other.`)}</div>
              <div class="timerRow" style="grid-template-columns:1fr; margin-bottom:14px; padding-bottom:14px; border-bottom:1px solid rgba(255,255,255,.08)">
                <div class="timerCard">
                  <div class="tname">${escapeHtml(appLang === "fa" ? "زمان صحبت" : "Talk time")}</div>
                  <div class="tval clickable" id="tm_chaos">${formatMMSS(_tmrCh.remaining.chaos)}</div>
                  <div style="display:flex; gap:6px; justify-content:center; align-items:center">
                    <button class="tbtn" id="tm_btn_chaos" type="button" aria-label="Play/Pause"></button>
                    <button class="tbtn reset" id="tm_rst_chaos" type="button" aria-label="Reset">${rstSvg}</button>
                  </div>
                </div>
              </div>
              ${picksHtml}
              ${winnerLabel ? `<div style="margin-top:14px; padding:12px; border-radius:10px; background:rgba(255,255,255,.06); text-align:center; font-weight:1100; font-size:1.1em">${escapeHtml(winnerLabel)}</div>` : ""}
            </div>`;
          } else if (cur.id === "winner_run") {
            const d = f.draft || {};
            const winnerTeam = d.winnerTeam || null;
            const winnerLabelMap = {
              mafia: appLang === "fa" ? "مافیا" : "Mafia",
              citizens: appLang === "fa" ? "شهروندان" : "Citizens",
              independent: appLang === "fa" ? "مستقل" : "Independent",
            };
            const winnerPlayers = (() => {
              if (!winnerTeam) return [];
              const nostradamusSide = (d.nostradamusChosenSide === "mafia" || d.nostradamusChosenSide === "citizen") ? d.nostradamusChosenSide : null;
              return (draw.players || []).map((p, i) => ({ p, i })).filter(({ p }) => {
                if (!p) return false;
                // Pedarkhande: Nostradamus counts with their chosen side for winner announcement
                if ((p.roleId || "") === "nostradamus" && nostradamusSide) {
                  if (winnerTeam === "mafia") return nostradamusSide === "mafia";
                  if (winnerTeam === "citizens") return nostradamusSide === "citizen";
                  return false;
                }
                const team = (roles[p.roleId] && roles[p.roleId].teamFa) || "شهر";
                if (winnerTeam === "mafia") return team === "مافیا";
                if (winnerTeam === "citizens") return team === "شهر";
                if (winnerTeam === "independent") return team === "مستقل";
                return false;
              });
            })();
            body = `<div class="toolBox">
              ${winnerTeam ? `
              <div style="text-align:center; margin:16px 0">
                <div style="font-size:2.4em; margin-bottom:6px">🏆</div>
                <div style="font-size:1.5em; font-weight:1200; color:rgba(255,215,0,1)">${escapeHtml(((winnerLabelMap[winnerTeam] || winnerTeam)) + " " + (appLang === "fa" ? "برنده شد!" : "Win!"))}</div>
                ${winnerPlayers.length ? `<div style="margin-top:10px; font-size:.95em; color:var(--muted)">${winnerPlayers.map(({ p, i }) => {
                const nm = names[i] || t("common.playerN", { n: i + 1 });
                if ((p.roleId || "") === "nostradamus" && (d.nostradamusChosenSide === "mafia" || d.nostradamusChosenSide === "citizen")) {
                  const suffix = d.nostradamusChosenSide === "mafia" ? (appLang === "fa" ? " (نوستراداموس — مافیا)" : " (Nostradamus — Mafia)") : (appLang === "fa" ? " (نوستراداموس — شهر)" : " (Nostradamus — Citizens)");
                  return escapeHtml(nm + suffix);
                }
                return escapeHtml(nm);
              }).join("،\u200f ")}</div>` : ""}
              </div>` : ""}
            </div>`;
          } else if (cur.id === "namayande_rep_election") {
            const d = f.draft || {};
            const savedRep1 = (d.representatives && d.representatives[0] != null) ? d.representatives[0] : null;
            const savedRep2 = (d.representatives && d.representatives[1] != null) ? d.representatives[1] : null;
            const mkRepOptsSel = (sel, excludeIdx) => {
              const s = sel !== null ? String(sel) : "";
              const base = [`<option value="" ${s === "" ? "selected" : ""}>—</option>`];
              for (const idx of aliveIdxs) {
                if (excludeIdx !== null && idx === excludeIdx) continue;
                const v = String(idx);
                base.push(`<option value="${v}" ${v === s ? "selected" : ""}>${escapeHtml(names[idx] || t("common.playerN", { n: idx + 1 }))}</option>`);
              }
              return base.join("");
            };
            body = `<div class="toolBox">
              <div class="note" style="margin-bottom:12px">${escapeHtml(appLang === "fa"
                ? "هر بازیکن یک نماینده معرفی می‌کند. بیشترین رأی = نماینده."
                : "Each player nominates a representative. Most votes wins.")}</div>
              <div class="note warn" style="margin-bottom:12px">${escapeHtml(appLang === "fa"
                ? "⚠ اگر دقیقاً ۲ نفر مساوی → هر دو نماینده می‌شوند. اگر ≥۳ نفر مساوی → مجدد رأی‌گیری بین آن‌ها."
                : "⚠ Exactly 2 tied → both become reps. 3 or more tied → re-vote among them.")}</div>
              <label style="margin-bottom:12px">${escapeHtml(appLang === "fa" ? "نماینده اول (دور رو به جلو)" : "Representative 1 (forward round)")}
                <select id="fl_rep1">${mkRepOptsSel(savedRep1, null)}</select>
              </label>
              <label>${escapeHtml(appLang === "fa" ? "نماینده دوم (دور معکوس)" : "Representative 2 (reverse round)")}
                <select id="fl_rep2">${mkRepOptsSel(savedRep2, savedRep1)}</select>
              </label>
            </div>`;
          } else if (cur.id === "namayande_rep_action") {
            const d = f.draft || {};
            const reps = (d.representatives && d.representatives.length) ? d.representatives : [];
            const rep1Idx = reps[0] != null ? reps[0] : null;
            const rep2Idx = reps[1] != null ? reps[1] : null;
            const rep1Name = rep1Idx !== null ? (names[rep1Idx] || t("common.playerN", { n: rep1Idx + 1 })) : "—";
            const rep2Name = rep2Idx !== null ? (names[rep2Idx] || t("common.playerN", { n: rep2Idx + 1 })) : "—";
            const savedTargets = (d.repTargetsByDay && d.repTargetsByDay[String(f.day)]) ? d.repTargetsByDay[String(f.day)] : {};
            const mkRepTargetOpts = (sel) => {
              const s = sel != null ? String(sel) : "";
              const base = [`<option value="" ${s === "" ? "selected" : ""}>—</option>`];
              for (const idx of aliveIdxs) {
                const v = String(idx);
                base.push(`<option value="${v}" ${v === s ? "selected" : ""}>${escapeHtml(names[idx] || t("common.playerN", { n: idx + 1 }))}</option>`);
              }
              return base.join("");
            };
            // Show previous night's betrayal vote as MC reminder
            const prevNightKey = String((f.day || 1) - 1);
            const prevNightActions = (d.nightActionsByNight && d.nightActionsByNight[prevNightKey]) ? d.nightActionsByNight[prevNightKey] : null;
            const bRep = prevNightActions ? prevNightActions.betrayalRep : null;
            const bDir = prevNightActions ? prevNightActions.betrayalDir : null;
            const betrayalMemo = (bRep != null && bDir != null) ? (() => {
              const repName = bRep === 1 ? rep1Name : rep2Name;
              const dirText = bDir === "more"
                ? (appLang === "fa" ? "رأی بیشتر شود" : "more votes")
                : (appLang === "fa" ? "رأی کمتر شود" : "fewer votes");
              return `<div class="note warn" style="margin-bottom:12px">
                🔒 ${escapeHtml(appLang === "fa"
                  ? `رأی خیانت (شب ${prevNightKey}): نماینده ${bRep} — ${repName} → ${dirText}`
                  : `Betrayal vote (Night ${prevNightKey}): Rep ${bRep} — ${repName} → ${dirText}`)}
              </div>`;
            })() : "";
            const noRepsWarn = reps.length < 2 ? `<div class="note warn" style="margin-bottom:12px">${escapeHtml(appLang === "fa" ? "⚠ نمایندگان هنوز ثبت نشده‌اند." : "⚠ Representatives not yet recorded.")}</div>` : "";
            body = `<div class="toolBox">
              ${noRepsWarn}
              ${betrayalMemo}
              <div style="margin-bottom:10px; font-weight:1100">${escapeHtml(appLang === "fa" ? `نمایندگان: ${rep1Name} و ${rep2Name}` : `Representatives: ${rep1Name} & ${rep2Name}`)}</div>
              <label style="margin-bottom:12px">${escapeHtml(appLang === "fa" ? `هدف نماینده اول (${rep1Name})` : `Rep 1 target (${rep1Name})`)}
                <select id="fl_rep1_target">${mkRepTargetOpts(savedTargets[1])}</select>
              </label>
              <label>${escapeHtml(appLang === "fa" ? `هدف نماینده دوم (${rep2Name})` : `Rep 2 target (${rep2Name})`)}
                <select id="fl_rep2_target">${mkRepTargetOpts(savedTargets[2])}</select>
              </label>
            </div>`;
          } else if (cur.id === "namayande_cover") {
            const d = f.draft || {};
            const reps = (d.representatives && d.representatives.length) ? d.representatives : [];
            const rep1Idx = reps[0] != null ? reps[0] : null;
            const rep2Idx = reps[1] != null ? reps[1] : null;
            const savedTargets = (d.repTargetsByDay && d.repTargetsByDay[String(f.day)]) ? d.repTargetsByDay[String(f.day)] : {};
            const t1Name = savedTargets[1] != null ? (names[savedTargets[1]] || t("common.playerN", { n: savedTargets[1] + 1 })) : "—";
            const t2Name = savedTargets[2] != null ? (names[savedTargets[2]] || t("common.playerN", { n: savedTargets[2] + 1 })) : "—";
            const rep1Name = rep1Idx !== null ? (names[rep1Idx] || t("common.playerN", { n: rep1Idx + 1 })) : "—";
            const rep2Name = rep2Idx !== null ? (names[rep2Idx] || t("common.playerN", { n: rep2Idx + 1 })) : "—";
            body = `<div class="toolBox">
              <div style="margin-bottom:12px">
                <div style="font-weight:1100; margin-bottom:6px">${escapeHtml(appLang === "fa" ? "هدف‌های انتخاب‌شده:" : "Chosen targets:")}</div>
                <div class="note">• ${escapeHtml(appLang === "fa" ? `هدف نماینده اول (${rep1Name}): ${t1Name}` : `Rep 1 (${rep1Name}) target: ${t1Name}`)}</div>
                <div class="note" style="margin-top:4px">• ${escapeHtml(appLang === "fa" ? `هدف نماینده دوم (${rep2Name}): ${t2Name}` : `Rep 2 (${rep2Name}) target: ${t2Name}`)}</div>
              </div>
              <div class="note">${escapeHtml(appLang === "fa"
                ? "هر تارگت می‌تواند برای خودش کاور مشخص کند. کاورها به نوبت از تارگت‌ها دفاع می‌کنند."
                : "Each target may select a cover player. Covers defend their targets in turn.")}</div>
            </div>`;
          } else if (cur.id === "namayande_defense") {
            const d = f.draft || {};
            const savedTargets = (d.repTargetsByDay && d.repTargetsByDay[String(f.day)]) ? d.repTargetsByDay[String(f.day)] : {};
            const t1Name = savedTargets[1] != null ? (names[savedTargets[1]] || t("common.playerN", { n: savedTargets[1] + 1 })) : "—";
            const t2Name = savedTargets[2] != null ? (names[savedTargets[2]] || t("common.playerN", { n: savedTargets[2] + 1 })) : "—";
            body = `<div class="toolBox">
              <div style="font-weight:1100; margin-bottom:8px">${escapeHtml(appLang === "fa" ? "دفاعیه نهایی" : "Final Defense")}</div>
              <div class="note" style="margin-bottom:8px">${escapeHtml(appLang === "fa" ? "ابتدا کاورها، سپس تارگت‌ها از خود دفاع می‌کنند." : "Covers speak first, then targets defend themselves.")}</div>
              <div class="note">• ${escapeHtml(appLang === "fa" ? `تارگت اول: ${t1Name}` : `Target 1: ${t1Name}`)}</div>
              <div class="note" style="margin-top:4px">• ${escapeHtml(appLang === "fa" ? `تارگت دوم: ${t2Name}` : `Target 2: ${t2Name}`)}</div>
            </div>`;
          } else if (cur.id === "namayande_vote") {
            const d = f.draft || {};
            const savedTargets = (d.repTargetsByDay && d.repTargetsByDay[String(f.day)]) ? d.repTargetsByDay[String(f.day)] : {};
            const t1Idx = savedTargets[1] != null ? savedTargets[1] : null;
            const t2Idx = savedTargets[2] != null ? savedTargets[2] : null;
            const t1Name = t1Idx !== null ? (names[t1Idx] || t("common.playerN", { n: t1Idx + 1 })) : null;
            const t2Name = t2Idx !== null ? (names[t2Idx] || t("common.playerN", { n: t2Idx + 1 })) : null;
            const savedOut = (d.namayandePick && d.namayandePick[String(f.day)] != null) ? d.namayandePick[String(f.day)] : null;
            const mkVoteOutOpts = () => {
              const s = savedOut !== null ? String(savedOut) : "";
              const base = [`<option value="" ${s === "" ? "selected" : ""}>— ${escapeHtml(appLang === "fa" ? "(هیچ‌کس)" : "(nobody)")}</option>`];
              if (t1Idx !== null) {
                const t1Alive = (draw.players[t1Idx] || {}).alive !== false;
                base.push(`<option value="${t1Idx}" ${String(t1Idx) === s ? "selected" : ""} ${!t1Alive ? "disabled" : ""}>${escapeHtml(t1Name + (!t1Alive ? (appLang === "fa" ? " (خارج شد)" : " (out)") : ""))}</option>`);
              }
              if (t2Idx !== null) {
                const t2Alive = (draw.players[t2Idx] || {}).alive !== false;
                base.push(`<option value="${t2Idx}" ${String(t2Idx) === s ? "selected" : ""} ${!t2Alive ? "disabled" : ""}>${escapeHtml(t2Name + (!t2Alive ? (appLang === "fa" ? " (خارج شد)" : " (out)") : ""))}</option>`);
              }
              if (!t1Idx && !t2Idx) {
                // fallback: show all alive players if targets not set
                for (const idx of aliveIdxs) {
                  base.push(`<option value="${idx}" ${String(idx) === s ? "selected" : ""}>${escapeHtml(names[idx] || t("common.playerN", { n: idx + 1 }))}</option>`);
                }
              }
              return base.join("");
            };
            const resultLine = (() => {
              if (savedOut === null) return "";
              const nm = names[savedOut] || t("common.playerN", { n: savedOut + 1 });
              return appLang === "fa" ? `${escapeHtml(nm)} از بازی خارج می‌شود.` : `${escapeHtml(nm)} is eliminated.`;
            })();
            body = `<div class="toolBox">
              <div style="font-weight:1100; margin-bottom:8px">${escapeHtml(appLang === "fa" ? "رأی‌گیری (اختیاری)" : "Vote (optional)")}</div>
              <div class="note" style="margin-bottom:12px">${escapeHtml(appLang === "fa"
                ? "اگر یکی از تارگت‌ها رأی حدنصاب بیاورد، از بازی خارج می‌شود."
                : "If a target reaches the required vote threshold, they are eliminated.")}</div>
              <label>${escapeHtml(appLang === "fa" ? "خارج‌شده" : "Eliminated")}
                <select id="fl_namayande_out">${mkVoteOutOpts()}</select>
              </label>
              ${resultLine ? `<div class="note result" style="margin-top:10px">${resultLine}</div>` : ""}
            </div>`;
          } else if (cur.id === "night_run" || (cur.id && (String(cur.id).startsWith("night_step_") || (f.phase === "night" && steps.length > 1)))) {
            const d = f.draft || {};
            const evenNight = ((f.day || 1) % 2 === 0);
            const nightKey = String(f.day || 1);
            // Load saved actions for this night: prefer per-night draft, fallback to latest event.
            // When event exists but draft is empty, merge event into draft so selections persist when navigating back.
            if (!d.nightActionsByNight || typeof d.nightActionsByNight !== "object") d.nightActionsByNight = {};
            const savedNight = (() => {
              try {
                const byNight = (d.nightActionsByNight && d.nightActionsByNight[nightKey]) ? d.nightActionsByNight[nightKey] : null;
                if (byNight && typeof byNight === "object") return byNight;
              } catch {}
              try {
                const ev = (f.events || []).slice().reverse().find((e) => e && e.kind === "night_actions" && e.phase === "night" && e.day === f.day && e.data);
                if (ev && ev.data && typeof ev.data === "object") {
                  const merged = { ...ev.data };
                  d.nightActionsByNight[nightKey] = merged;
                  f.draft = d;
                  try { saveState(appState); } catch {}
                  return merged;
                }
              } catch {}
              return {};
            })();
            // Who is disabled by the Magician, Matador (pedarkhande), or Handcuffs this night?
            const scenario = typeof getDrawScenarioForFlow === "function" ? getDrawScenarioForFlow() : "";
            const disabledPlayerIdx = (() => {
              try {
                if (scenario === "pedarkhande") {
                  // Current night's Matador disable
                  const matadorV = savedNight.matadorDisable;
                  if (matadorV !== null && matadorV !== undefined && Number.isFinite(Number(matadorV))) {
                    return parseInt(matadorV, 10);
                  }
                  // 24-hour effect: previous night's Matador disable still applies this night
                  const prevNightKey = String(Math.max(0, (f.day || 1) - 1));
                  const prevNight = (d.nightActionsByNight && d.nightActionsByNight[prevNightKey]) ? d.nightActionsByNight[prevNightKey] : null;
                  const prevMatadorV = prevNight && prevNight.matadorDisable != null && Number.isFinite(Number(prevNight.matadorDisable))
                    ? parseInt(prevNight.matadorDisable, 10) : null;
                  if (prevMatadorV !== null) return prevMatadorV;
                }
                const v = savedNight.magicianDisable;
                if (v === null || v === undefined || v === "") return null;
                const n = parseInt(v, 10);
                return Number.isFinite(n) ? n : null;
              } catch { return null; }
            })();
            const handcuffedPlayerIdx = (() => {
              try {
                const d = f.draft || {};
                const dayKey = String(f.day || 1);
                const h = d.handcuffedByDay && d.handcuffedByDay[dayKey];
                if (h === null || h === undefined) return null;
                const n = parseInt(h, 10);
                return Number.isFinite(n) ? n : null;
              } catch { return null; }
            })();
            // Helper to find a player's index by roleId(s)
            const findRolePlayerIdx = (roleIds) => {
              const ids = Array.isArray(roleIds) ? roleIds : [roleIds];
              for (let i = 0; i < (draw.players || []).length; i++) {
                const p = draw.players[i];
                if (p && ids.includes(p.roleId)) return i;
              }
              return null;
            };
            const getDisabledNote = (playerIdx) => {
              if (playerIdx === handcuffedPlayerIdx) {
                return (appLang === "fa") ? "این نقش در این شب دستبند خورده و قابلیتش غیرفعال است." : "This role is handcuffed this night and their ability is disabled.";
              }
              if (scenario === "pedarkhande" && disabledPlayerIdx === playerIdx) {
                return (appLang === "fa") ? "این نقش توسط ماتادور غیرفعال شده (۲۴ ساعت)." : "This role is disabled by the Matador (24 hours).";
              }
              if (disabledPlayerIdx === playerIdx) {
                return (appLang === "fa") ? "این نقش در این شب توسط شعبده‌باز غیرفعال است." : "This role is disabled this night by the Magician.";
              }
              return "";
            };

            // Options for targeting alive players, but keep the selected value visible even if they died
            // due to an immediately-applied action (e.g., Mafia shot).
            const mkAliveOptsSel = (sel) => {
              const sIdx = (sel === null || sel === undefined || sel === "") ? null : parseInt(sel, 10);
              const s = (sIdx === null || !Number.isFinite(sIdx)) ? "" : String(sIdx);
              const base = [`<option value="" ${s === "" ? "selected" : ""}>—</option>`];
              for (const idx of aliveIdxs) {
                const v = String(idx);
                base.push(`<option value="${v}" ${v === s ? "selected" : ""}>${escapeHtml(names[idx] || t("common.playerN", { n: idx + 1 }))}</option>`);
              }
              // If selected is not currently alive, still show it (muted/out) so UI retains the choice.
              if (s !== "" && !aliveIdxs.includes(sIdx) && draw.players && draw.players[sIdx]) {
                const nm = names[sIdx] || t("common.playerN", { n: sIdx + 1 });
                const outTxt = appLang === "fa" ? " (خارج شد)" : " (out)";
                base.push(`<option value="${s}" selected>${escapeHtml(nm + outTxt)}</option>`);
              }
              return base.join("");
            };

            // Gunslinger support (give guns)
            const gunnerIdxs = (draw.players || [])
              .map((p, idx) => (p && p.roleId === "gunslinger" && p.alive !== false) ? idx : null)
              .filter((x) => x !== null);
            const showGunner = !!gunnerIdxs.length;
            const gunnerIdx = showGunner ? gunnerIdxs[0] : null;
            const gunnerName = (gunnerIdx !== null && Number.isFinite(gunnerIdx))
              ? (names[gunnerIdx] || t("common.playerN", { n: gunnerIdx + 1 }))
              : "—";
            const guns = f.guns || {};
            const givenCount = Object.keys(guns || {}).length;
            if (!d.nightGunGivesByNight || typeof d.nightGunGivesByNight !== "object") d.nightGunGivesByNight = {};
            const nightGives = Array.isArray(d.nightGunGivesByNight[nightKey]) ? d.nightGunGivesByNight[nightKey] : [];
            const nightGiveCount = nightGives.length;
            const nightRealCount = nightGives.filter((x) => x && x.type === "real").length;

            const noActionTxt = (appLang === "fa")
              ? "اکشنی برای ثبت ندارد."
              : "No action to record.";

            const sectionFor = (wakeLabel) => {
              const k = normWake(wakeLabel);
              // Config-driven disable: if this section's player is disabled (Magician/Matador) or handcuffed, grey out.
              const wakeToRoleIds = {
                doctor: ["doctor", "watson"],
                lecter: ["doctorLecter"],
                detective: ["detective"],
                professional: ["professional", "leon"],
                bomber: ["bomber"],
                zodiac: ["zodiac"],
                gunslinger: ["gunslinger"],
                ocean: ["ocean"],
                jokermaf: ["jokerMafia"],
                swindler: ["swindler"],
                researcher: ["researcher"],
                natasha: ["natasha"],
                sniper: ["sniper"],
                negotiator: ["negotiator"],
                kadkhoda: ["kadkhoda"],
                reporter: ["reporter"],
                representative: ["representative"],
                nato: ["nato"],
                hacker: ["hacker"],
                guide: ["guide"],
                bodyguard: ["bodyguard"],
                minemaker: ["minemaker"],
                lawyer: ["lawyer"],
                soldier: ["soldier"],
                kane: ["citizenKane"],
                constantine: ["constantine"],
              };
              const sectionRoleIds = wakeToRoleIds[k] || [k];
              const sectionPlayerIdx = findRolePlayerIdx(sectionRoleIds);
              const sectionRoleId = (sectionPlayerIdx !== null && draw.players && draw.players[sectionPlayerIdx])
                ? draw.players[sectionPlayerIdx].roleId : null;
              const sectionDisabled = sectionPlayerIdx !== null
                && (sectionPlayerIdx === disabledPlayerIdx || sectionPlayerIdx === handcuffedPlayerIdx);
              const sectionDisabledStyle = sectionDisabled ? "opacity:.4; pointer-events:none;" : "";

              if (k === "mafia") {
                // Pedarkhande: Godfather choice (shoot / sixth sense / Saul buy), Matador disable, Saul buy target
                if (scenario === "pedarkhande") {
                  const saulBuyUsed = !!(d && d.saulBuyUsed);
                  const mafiaCount = (draw.players || []).filter((p) => p && (roles[p.roleId || "citizen"] && roles[p.roleId || "citizen"].teamFa === "مافیا")).length;
                  const mafiaAliveCount = (draw.players || []).filter((p) => p && p.alive !== false && (roles[p.roleId || "citizen"] && roles[p.roleId || "citizen"].teamFa === "مافیا")).length;
                  const atLeastOneMafiaDead = mafiaCount > 0 && mafiaAliveCount < mafiaCount;
                  const saulBuyAllowed = !saulBuyUsed && atLeastOneMafiaDead;
                  const godfatherAction = (savedNight.godfatherAction != null && String(savedNight.godfatherAction)) ? String(savedNight.godfatherAction) : "shoot";
                  const saulBuyTargetIdxs = (typeof getSaulBuyTargetIndices === "function") ? getSaulBuyTargetIndices(f) : [];
                  const shootLabel = appLang === "fa" ? "شلیک" : "Shoot";
                  const sixthLabel = appLang === "fa" ? "حس ششم" : "Sixth sense";
                  const saulLabel = appLang === "fa" ? "خرید ساول" : "Saul buy";
                  return `
                    <div style="font-weight:1100; margin-bottom:6px">${escapeHtml(appLang === "fa" ? "پدرخوانده — انتخاب شب" : "Godfather — Night choice")}</div>
                    <label style="display:block; margin-bottom:8px">
                      <select id="fl_godfather_action" style="font-size:14px; padding:6px; min-width:140px">
                        <option value="shoot" ${godfatherAction === "shoot" ? "selected" : ""}>${escapeHtml(shootLabel)}</option>
                        <option value="sixth_sense" ${godfatherAction === "sixth_sense" ? "selected" : ""}>${escapeHtml(sixthLabel)}</option>
                        <option value="saul_buy" ${godfatherAction === "saul_buy" ? "selected" : ""} ${!saulBuyAllowed ? "disabled" : ""}>${escapeHtml(saulLabel)}${!saulBuyAllowed ? (appLang === "fa" ? " (غیرفعال)" : " (unavailable)") : ""}</option>
                      </select>
                    </label>
                    ${godfatherAction === "shoot" ? mkNightTargetCards("fl_mafia_shot", savedNight.mafiaShot, t("tool.flow.action.mafiaShot")) : ""}
                    ${godfatherAction === "sixth_sense" ? (() => {
                      const mkSixthSenseRoleOpts = (savedRoleId) => {
                        const saved = String(savedRoleId || "");
                        const seen = new Set();
                        const opts = [`<option value="" ${saved === "" ? "selected" : ""}>—</option>`];
                        for (const p of (draw.players || [])) {
                          if (!p || !p.roleId) continue;
                          const rid = String(p.roleId);
                          if (seen.has(rid)) continue;
                          seen.add(rid);
                          const fa = (roles[rid] && roles[rid].faName) ? roles[rid].faName : rid;
                          const en = (typeof ROLE_I18N !== "undefined" && ROLE_I18N[rid] && ROLE_I18N[rid].name) ? ROLE_I18N[rid].name : fa;
                          opts.push(`<option value="${escapeHtml(rid)}" ${rid === saved ? "selected" : ""}>${escapeHtml(appLang === "fa" ? fa : en)}</option>`);
                        }
                        return opts.join("");
                      };
                      return `
                        <div class="note" style="margin-top:6px">${escapeHtml(appLang === "fa" ? "پدرخوانده یک بازیکن را انتخاب و نقشش را حدس می‌زند. درست → خارج (واتسون نمی‌تواند نجات دهد). غلط → هیچ." : "Godfather picks a player and guesses their role. Correct → eliminated (Watson cannot save). Wrong → nothing.")}</div>
                        <div style="height:6px"></div>
                        ${mkNightTargetCards("fl_sixth_sense_target", savedNight.sixthSenseTarget, appLang === "fa" ? "بازیکن حدس‌زده‌شده" : "Guessed player")}
                        <label style="margin-top:6px">${escapeHtml(appLang === "fa" ? "نقش حدس‌زده شده" : "Guessed role")}
                          <select id="fl_sixth_sense_role">${mkSixthSenseRoleOpts(savedNight.sixthSenseRole)}</select>
                        </label>
                      `;
                    })() : ""}
                    ${godfatherAction === "saul_buy" && saulBuyAllowed ? `
                      <div class="note" style="margin-top:6px">${escapeHtml(appLang === "fa" ? "هدف‌ها شامل همه بازیکنان زنده غیرمافیا. فقط شهروند ساده موفق می‌شود؛ بقیه «خرید ناموفق»." : "Targets include all alive (non-mafia) players. Only simple citizen succeeds; others show 'Saul buy failed'.")}</div>
                      ${saulBuyTargetIdxs.length ? mkNightTargetCards("fl_saul_buy_target", savedNight.saulBuyTarget, appLang === "fa" ? "هدف خرید ساول" : "Saul buy target", saulBuyTargetIdxs) : `<div class="note warn">${escapeHtml(appLang === "fa" ? "هیچ بازیکن غیرمافیایی زنده نیست." : "No alive non-mafia player.")}</div>`}
                      ${(() => {
                        const tIdx = (savedNight.saulBuyTarget !== null && savedNight.saulBuyTarget !== undefined && Number.isFinite(Number(savedNight.saulBuyTarget))) ? parseInt(savedNight.saulBuyTarget, 10) : null;
                        if (tIdx === null) return "";
                        const p = (draw.players && draw.players[tIdx]) ? draw.players[tIdx] : null;
                        const roleId = (p && p.roleId) ? p.roleId : "citizen";
                        const isCitizen = roleId === "citizen";
                        const msg = isCitizen
                          ? (appLang === "fa" ? "خرید ساول موفق." : "Saul buy successful.")
                          : (appLang === "fa" ? "خرید ساول ناموفق." : "Saul buy failed.");
                        const cls = isCitizen ? "pass" : "warn";
                        return `<div id="fl_saul_buy_result" class="note ${cls}" style="margin-top:8px; font-weight:900">${escapeHtml(msg)}</div>`;
                      })()}
                    ` : ""}
                    ${(() => {
                      const matadorTargetIdxs = (typeof getMatadorDisableTargetIndices === "function") ? getMatadorDisableTargetIndices(f) : [];
                      if (matadorTargetIdxs.length === 0) return `<div class="note" style="margin-top:14px; opacity:.7">${escapeHtml(appLang === "fa" ? "ماتادور در بازی نیست یا فوت کرده است." : "Matador is not in the game or is dead.")}</div>`;
                      return `
                    <div style="height:14px"></div>
                    <div style="font-weight:1100; margin-bottom:6px">${escapeHtml(appLang === "fa" ? "ماتادور — غیرفعال‌کردن توان شب" : "Matador — Disable night ability")}</div>
                    <div class="note" style="margin-bottom:6px; font-size:12px">${escapeHtml(appLang === "fa" ? "ماتادور نمی‌تواند دو شب متوالی یک نفر را انتخاب کند." : "Matador cannot choose the same player two consecutive nights.")}</div>
                    ${mkNightTargetCards("fl_matador_disable", savedNight.matadorDisable, appLang === "fa" ? "بازیکن غیرفعال‌شده" : "Disabled player", matadorTargetIdxs, new Set())}
                      `;
                    })()}
                  `;
                }
                // Kabo (Capo): Mafia Don choice — Shoot / Buy (Yakooza) / Guess role (Executioner)
                if (scenario === "kabo") {
                  const kaboAction = (savedNight.godfatherAction != null && String(savedNight.godfatherAction)) ? String(savedNight.godfatherAction) : "shoot";
                  const yakoozaUsed = !!(d && d.kaboYakoozaUsed);
                  const mafiaCount = (draw.players || []).filter((p) => p && (roles[p.roleId || "citizen"] && roles[p.roleId || "citizen"].teamFa === "مافیا")).length;
                  const mafiaAliveCount = (draw.players || []).filter((p) => p && p.alive !== false && (roles[p.roleId || "citizen"] && roles[p.roleId || "citizen"].teamFa === "مافیا")).length;
                  const atLeastOneMafiaDead = mafiaCount > 0 && mafiaAliveCount < mafiaCount;
                  const yakoozaAllowed = !yakoozaUsed && atLeastOneMafiaDead;
                  const shootLabel = appLang === "fa" ? "شلیک" : "Shoot";
                  const buyLabel = appLang === "fa" ? "خرید (یاکوزا)" : "Buy (Yakooza)";
                  const guessLabel = appLang === "fa" ? "حدس نقش" : "Guess role";
                  const mkKaboRoleOpts = (savedRoleId) => {
                    const saved = String(savedRoleId || "");
                    const seen = new Set();
                    const opts = [`<option value="" ${saved === "" ? "selected" : ""}>—</option>`];
                    for (const p of (draw.players || [])) {
                      if (!p || !p.roleId) continue;
                      const rid = String(p.roleId);
                      if (seen.has(rid)) continue;
                      seen.add(rid);
                      const fa = (roles[rid] && roles[rid].faName) ? roles[rid].faName : rid;
                      const en = (typeof ROLE_I18N !== "undefined" && ROLE_I18N[rid] && ROLE_I18N[rid].name) ? ROLE_I18N[rid].name : fa;
                      opts.push(`<option value="${escapeHtml(rid)}" ${rid === saved ? "selected" : ""}>${escapeHtml(appLang === "fa" ? fa : en)}</option>`);
                    }
                    return opts.join("");
                  };
                  const yakoozaTargetIdxs = aliveIdxs.filter((idx) => {
                    const p = draw.players[idx];
                    if (!p) return false;
                    const teamFa = (roles[p.roleId || "citizen"] && roles[p.roleId || "citizen"].teamFa) || "شهر";
                    return teamFa !== "مافیا";
                  });
                  return `
                    <div style="font-weight:1100; margin-bottom:6px">${escapeHtml(appLang === "fa" ? "دن مافیا — انتخاب شب" : "Mafia Don — Night choice")}</div>
                    <label style="display:block; margin-bottom:8px">
                      <select id="fl_godfather_action" style="font-size:14px; padding:6px; min-width:160px">
                        <option value="shoot" ${kaboAction === "shoot" ? "selected" : ""}>${escapeHtml(shootLabel)}</option>
                        <option value="yakooza" ${kaboAction === "yakooza" ? "selected" : ""} ${!yakoozaAllowed ? "disabled" : ""}>${escapeHtml(buyLabel)}${!yakoozaAllowed ? (appLang === "fa" ? " (غیرفعال)" : " (unavailable)") : ""}</option>
                        <option value="guess_role" ${kaboAction === "guess_role" ? "selected" : ""}>${escapeHtml(guessLabel)}</option>
                      </select>
                    </label>
                    ${kaboAction === "shoot" ? `
                      ${mkNightTargetCards("fl_mafia_shot", savedNight.mafiaShot, t("tool.flow.action.mafiaShot"))}
                      <div style="height:10px"></div>
                    ` : ""}
                    ${kaboAction === "yakooza" && yakoozaAllowed ? `
                      <div class="note" style="margin-top:6px">${escapeHtml(appLang === "fa" ? "هدف‌ها شامل همه بازیکنان زنده غیرمافیا. فقط شهروند ساده موفق می‌شود." : "Targets include all alive non-mafia players. Only simple citizen succeeds.")}</div>
                      ${yakoozaTargetIdxs.length ? mkNightTargetCards("fl_kabo_yakooza_target", savedNight.kaboYakoozaTarget, appLang === "fa" ? "هدف خرید یاکوزا" : "Yakooza buy target", yakoozaTargetIdxs) : `<div class="note warn">${escapeHtml(appLang === "fa" ? "هیچ بازیکن غیرمافیایی زنده نیست." : "No alive non-mafia player.")}</div>`}
                    ` : ""}
                    ${kaboAction === "guess_role" ? `
                      <div class="note" style="margin-top:6px">${escapeHtml(appLang === "fa" ? "جلاد یک بازیکن را انتخاب و نقشش را حدس می‌زند. درست → خارج. غلط → هیچ." : "Executioner picks a player and guesses their role. Correct → eliminated. Wrong → nothing.")}</div>
                      <div style="height:6px"></div>
                      ${mkNightTargetCards("fl_executioner_target", savedNight.executionerTarget, appLang === "fa" ? "بازیکن حدس‌زده‌شده" : "Guessed player")}
                      <label style="margin-top:6px">${escapeHtml(appLang === "fa" ? "نقش حدس‌زده شده" : "Guessed role")}
                        <select id="fl_executioner_role">${mkKaboRoleOpts(savedNight.executionerRoleGuess)}</select>
                      </label>
                      <div style="height:10px"></div>
                    ` : ""}
                    <div style="font-weight:1100; border-top:1px solid rgba(255,255,255,.15); padding-top:10px">${escapeHtml(appLang === "fa" ? "جادوگر — بازگرداندن توانایی به هدف" : "Witch — Reflect ability to target")}</div>
                    <div class="note" style="margin-top:6px">${escapeHtml(appLang === "fa" ? "جادوگر یک شهروند را انتخاب می‌کند؛ توانایی آن بازیکن به خودش بازمی‌گردد (کارآگاه→استعلام خودش منفی؛ عطار→زهر به خودش؛ زره‌ساز→زره به خودش)." : "Witch picks a citizen; that player's ability reflects to themselves (Detective→inquiry on self=negative; Herbalist→poison self; Armorsmith→armor self).")}</div>
                    <div style="height:6px"></div>
                    ${mkNightTargetCards("fl_witch_target", savedNight.witchTarget, appLang === "fa" ? "هدف جادوگر" : "Witch target", yakoozaTargetIdxs)}
                  `;
                }
                // Check if NATO player is present and alive (NATO wakes with Mafia in some scenarios).
                const natoPlayerIdx = (() => {
                  for (let i = 0; i < (draw.players || []).length; i++) {
                    const p = draw.players[i];
                    if (p && p.roleId === "nato" && p.alive !== false) return i;
                  }
                  return null;
                })();
                // natoUsedNight: tracks which night NATO used its guess. Only locked out on OTHER nights.
                const _natoCurrentNight = f.day || 1;
                const _natoUsedNight = (d && d.natoUsedNight != null) ? Number(d.natoUsedNight) : null;
                const natoUsedNow = _natoUsedNight !== null && _natoUsedNight !== _natoCurrentNight;
                // Role select: all roles assigned in this game, deduplicated.
                const mkNatoRoleOpts = (savedRoleId) => {
                  const saved = String(savedRoleId || "");
                  const seen = new Set();
                  const opts = [`<option value="" ${saved === "" ? "selected" : ""}>—</option>`];
                  for (const p of (draw.players || [])) {
                    if (!p || !p.roleId) continue;
                    const rid = String(p.roleId);
                    if (seen.has(rid)) continue;
                    seen.add(rid);
                    const fa = (roles[rid] && roles[rid].faName) ? roles[rid].faName : rid;
                    const en = (typeof ROLE_I18N !== "undefined" && ROLE_I18N[rid] && ROLE_I18N[rid].name) ? ROLE_I18N[rid].name : fa;
                    opts.push(`<option value="${escapeHtml(rid)}" ${rid === saved ? "selected" : ""}>${escapeHtml(appLang === "fa" ? fa : en)}</option>`);
                  }
                  return opts.join("");
                };
                const natoBlock = natoPlayerIdx !== null ? `
                  <div style="height:10px"></div>
                  <div style="font-weight:1100; border-top:1px solid rgba(255,255,255,.15); padding-top:10px">${escapeHtml(appLang === "fa" ? "ناتو — حدس نقش (یک‌بار در کل بازی)" : "NATO — Role Guess (once per game)")}</div>
                  ${natoUsedNow ? `<div class="note warn" style="margin-top:6px">${escapeHtml(appLang === "fa" ? "ناتو قبلاً از قابلیت حدس نقش استفاده کرده است." : "NATO already used the role-guess ability.")}</div>` : `
                  <div class="note" style="margin-top:6px">${escapeHtml(appLang === "fa" ? "می‌تواند به‌جای شلیک، نقش دقیق یک نفر را حدس بزند. درست → خارج / غلط → هیچ." : "Can guess one player's exact role instead of shooting. Correct → out / Wrong → nothing.")}</div>
                  <div style="height:6px"></div>
                  ${mkNightTargetCards("fl_nato_target", savedNight.natoTarget, appLang === "fa" ? "هدف حدس ناتو" : "NATO guess target")}
                  <label style="margin-top:6px">${escapeHtml(appLang === "fa" ? "نقش حدس‌زده شده" : "Guessed role")}
                    <select id="fl_nato_role_guess">${mkNatoRoleOpts(savedNight.natoRoleGuess)}</select>
                  </label>
                  `}
                ` : "";
                // Sodagari (trading) block for bazras scenario — once per game by mafiaBoss
                const sodagariBlock = (() => {
                  if (scenario !== "bazras") return "";
                  const sodUsed = !!(d && d.sodagariUsed);
                  const currentNk = String(f.day || 1);
                  const sodUsedThisNight = d && d.sodagariUsedOnNight != null && Number(d.sodagariUsedOnNight) === Number(currentNk);
                  const sodUsedOther = sodUsed && !sodUsedThisNight;
                  const mafiaIdxs = (draw.players || []).map((p, i) => (p && p.alive !== false && roles[p.roleId || "citizen"] && roles[p.roleId || "citizen"].teamFa === "مافیا") ? i : null).filter((x) => x !== null);
                  const sodSaved = (d && d.nightActionsByNight && d.nightActionsByNight[currentNk]) ? d.nightActionsByNight[currentNk] : {};
                  if (sodUsedOther) {
                    return `
                      <div style="height:10px"></div>
                      <div style="font-weight:1100; border-top:1px solid rgba(255,255,255,.15); padding-top:10px">${escapeHtml(appLang === "fa" ? "سوداگری (رئیس مافیا — یک‌بار در کل بازی)" : "Sodagari / Trade (Mafia Boss — once per game)")}</div>
                      <div class="note warn" style="margin-top:6px">${escapeHtml(appLang === "fa" ? "سوداگری قبلاً انجام شده است." : "Trade already used.")}</div>
                    `;
                  }
                  return `
                    <div style="height:10px"></div>
                    <div style="font-weight:1100; border-top:1px solid rgba(255,255,255,.15); padding-top:10px">${escapeHtml(appLang === "fa" ? "سوداگری (رئیس مافیا — یک‌بار در کل بازی)" : "Sodagari / Trade (Mafia Boss — once per game)")}</div>
                    <div class="note" style="margin-top:6px">${escapeHtml(appLang === "fa" ? "رئیس مافیا یک عضو مافیا را فدا می‌کند (فردا حذف می‌شود) + یک شهروند/رویین‌تن را به مافیا تبدیل می‌کند." : "Mafia Boss sacrifices a mafia member (eliminated next morning) + converts a citizen/invulnerable to mafia.")}</div>
                    <div style="height:6px"></div>
                    ${mkNightTargetCards("fl_sodagari_sacrifice", sodSaved.sodagariSacrifice, appLang === "fa" ? "فدایی (عضو مافیا)" : "Sacrifice (mafia member)", mafiaIdxs)}
                    <div style="height:10px"></div>
                    ${mkNightTargetCards("fl_sodagari_target", sodSaved.sodagariTarget != null ? sodSaved.sodagariTarget : null, appLang === "fa" ? "هدف تبدیل (شهروند/رویین‌تن)" : "Convert target (citizen/invulnerable)")}
                  `;
                })();
                // Neutralized shot block (namayande only) — once per game, mine trap is bypassed
                const neutralizedShotBlock = (() => {
                  if (scenario !== "namayande") return "";
                  const nsUsed = !!(d && d.neutralizedShotUsed);
                  const currentNk2 = String(f.day || 1);
                  const nsUsedThisNight = d && d.neutralizedShotUsedOnNight != null && Number(d.neutralizedShotUsedOnNight) === Number(currentNk2);
                  const nsUsedOther = nsUsed && !nsUsedThisNight;
                  if (nsUsedOther) {
                    return `
                      <div style="height:10px"></div>
                      <div style="font-weight:1100; border-top:1px solid rgba(255,255,255,.15); padding-top:10px">${escapeHtml(appLang === "fa" ? "شات خنثی (یک‌بار در کل بازی)" : "Neutralized Shot (once per game)")}</div>
                      <div class="note warn" style="margin-top:6px">${escapeHtml(appLang === "fa" ? "شات خنثی قبلاً استفاده شده است." : "Neutralized shot already used.")}</div>
                    `;
                  }
                  const isChecked = !!(d && d.neutralizedShotUsedOnNight != null && Number(d.neutralizedShotUsedOnNight) === Number(currentNk2));
                  return `
                    <div style="height:10px"></div>
                    <div style="font-weight:1100; border-top:1px solid rgba(255,255,255,.15); padding-top:10px">${escapeHtml(appLang === "fa" ? "شات خنثی (یک‌بار در کل بازی)" : "Neutralized Shot (once per game)")}</div>
                    <div class="note" style="margin-top:6px">${escapeHtml(appLang === "fa" ? "اگر فعال باشد و هدف مین داشته باشد، هیچ عضوی از مافیا از مین کشته نمی‌شود." : "If active and the shot target has a mine, no mafia member dies from the mine.")}</div>
                    <label style="margin-top:6px; display:flex; align-items:center; gap:8px">
                      <input type="checkbox" id="fl_neutralized_shot" ${isChecked ? "checked" : ""} style="width:18px; height:18px">
                      ${escapeHtml(appLang === "fa" ? "استفاده از شات خنثی" : "Use neutralized shot")}
                    </label>
                  `;
                })();
                // Betrayal vote block (namayande only) — Don Mafia's special ability
                const betrayalVoteBlock = (() => {
                  if (scenario !== "namayande") return "";
                  const reps = (d && Array.isArray(d.representatives) && d.representatives.length) ? d.representatives : null;
                  const selRep = savedNight.betrayalRep != null ? String(savedNight.betrayalRep) : "";
                  const selDir = savedNight.betrayalDir || "";
                  const header = `
                    <div style="height:10px"></div>
                    <div style="font-weight:1100; border-top:1px solid rgba(255,255,255,.15); padding-top:10px">${escapeHtml(appLang === "fa" ? "رأی خیانت (دون مافیا)" : "Betrayal Vote (Don Mafia)")}</div>
                    <div class="note" style="margin-top:4px">${escapeHtml(appLang === "fa" ? "قبل از انتخاب هدف نماینده‌ها. دون روی یکی از نمایندگان رأی خیانت می‌گذارد." : "Before reps pick targets. Don places a betrayal vote on one representative.")}</div>
                  `;
                  if (!reps) {
                    return header + `<div class="note warn">${escapeHtml(appLang === "fa" ? "نمایندگان هنوز انتخاب نشده‌اند." : "Representatives not yet elected.")}</div>`;
                  }
                  const rep1Name = names[reps[0]] || t("common.playerN", { n: reps[0] + 1 });
                  const rep2Name = reps[1] !== undefined ? (names[reps[1]] || t("common.playerN", { n: reps[1] + 1 })) : null;
                  const donIdx = (draw.players || []).findIndex((p) => p && p.roleId === "mafiaBoss");
                  const donIsRep = (donIdx !== -1) ? reps.indexOf(donIdx) : -1; // 0-based
                  const mkRepOpts = () => [
                    `<option value="" ${selRep === "" ? "selected" : ""}>—</option>`,
                    `<option value="1" ${selRep === "1" ? "selected" : ""} ${donIsRep === 0 ? "disabled" : ""}>${escapeHtml((appLang === "fa" ? "نماینده اول: " : "Rep 1: ") + rep1Name + (donIsRep === 0 ? (appLang === "fa" ? " (دون — غیرمجاز)" : " (Don — not allowed)") : ""))}</option>`,
                    rep2Name ? `<option value="2" ${selRep === "2" ? "selected" : ""} ${donIsRep === 1 ? "disabled" : ""}>${escapeHtml((appLang === "fa" ? "نماینده دوم: " : "Rep 2: ") + rep2Name + (donIsRep === 1 ? (appLang === "fa" ? " (دون — غیرمجاز)" : " (Don — not allowed)") : ""))}</option>` : "",
                  ].join("");
                  const mkDirOpts = () => [
                    `<option value="" ${selDir === "" ? "selected" : ""}>—</option>`,
                    `<option value="more" ${selDir === "more" ? "selected" : ""}>${escapeHtml(appLang === "fa" ? "رأی بیشتر شود" : "More votes")}</option>`,
                    `<option value="less" ${selDir === "less" ? "selected" : ""}>${escapeHtml(appLang === "fa" ? "رأی کمتر شود" : "Fewer votes")}</option>`,
                  ].join("");
                  return header + `
                    <label style="margin-top:8px">${escapeHtml(appLang === "fa" ? "نماینده هدف" : "Target representative")}
                      <select id="fl_betrayal_rep">${mkRepOpts()}</select>
                    </label>
                    <label style="margin-top:6px">${escapeHtml(appLang === "fa" ? "جهت رأی" : "Vote direction")}
                      <select id="fl_betrayal_dir">${mkDirOpts()}</select>
                    </label>
                  `;
                })();
                return `
                  ${mkNightTargetCards("fl_mafia_shot", savedNight.mafiaShot, t("tool.flow.action.mafiaShot"))}
                  ${natoBlock}
                  ${sodagariBlock}
                  ${betrayalVoteBlock}
                  ${neutralizedShotBlock}
                `;
              }
              if (k === "professional") {
                const leonBullets = (scenario === "pedarkhande" && sectionRoleId === "leon")
                  ? (() => { const used = (d && d.leonShotsUsed != null && Number.isFinite(Number(d.leonShotsUsed))) ? Number(d.leonShotsUsed) : 0; return Math.max(0, 2 - used); })()
                  : null;
                const leonBulletsLine = (leonBullets !== null)
                  ? `<div class="note" style="margin-top:6px">${escapeHtml(appLang === "fa" ? `لئون فقط ۲ گلوله دارد. باقی‌مانده: ${fmtNum(leonBullets)}` : `Leon has only 2 bullets. Remaining: ${leonBullets}`)}</div>`
                  : "";
                return `
                  ${sectionDisabled ? `<div class="note warn" style="margin-top:6px">${escapeHtml(getDisabledNote(sectionPlayerIdx))}</div>` : ""}
                  <div style="${sectionDisabledStyle}">
                    ${mkNightTargetCards("fl_pro_shot", savedNight.professionalShot, t("tool.flow.action.professionalShot"))}
                    ${leonBulletsLine}
                  </div>
                `;
              }
              if (k === "detective") {
                const detDisabled = sectionDisabled;
                // Show last saved detective result (per night/day) if present
                const key = String(f.day || 1);
                const dr = (d && d.detectiveResultByNight && d.detectiveResultByNight[key]) ? d.detectiveResultByNight[key] : null;
                const resultLine = (() => {
                  if (detDisabled) {
                    // Disabled detective always gets a forced negative result
                    const thumb = "👎";
                    const label = (appLang === "fa") ? "شهروند" : "Citizen";
                    const pre = (appLang === "fa") ? "نتیجه استعلام: " : "Result: ";
                    return `${pre}${thumb} ${label}`;
                  }
                  if (!dr || dr.isMafia === undefined || dr.isMafia === null) return "";
                  const isM = !!dr.isMafia;
                  const thumb = isM ? "👍" : "👎";
                  const label = (appLang === "fa")
                    ? (isM ? "مافیا" : "شهروند")
                    : (isM ? "Mafia" : "Citizen");
                  const pre = (appLang === "fa") ? "نتیجه استعلام: " : "Result: ";
                  return `${pre}${thumb} ${label}`;
                })();
                return `
                  ${detDisabled ? `<div class="note warn" style="margin-top:6px">${escapeHtml(getDisabledNote(sectionPlayerIdx))}</div>` : ""}
                  <div style="${sectionDisabledStyle}">
                    ${mkNightTargetCards("fl_det_query", savedNight.detectiveQuery, t("tool.flow.action.detectiveQuery"))}
                    <div id="fl_det_result" class="note result" style="margin-top:6px; ${resultLine ? "" : "display:none"}">${escapeHtml(resultLine || "")}</div>
                  </div>
                `;
              }
              if (k === "doctor") {
                return `
                  ${sectionDisabled ? `<div class="note warn" style="margin-top:6px">${escapeHtml(getDisabledNote(sectionPlayerIdx))}</div>` : ""}
                  <div style="${sectionDisabledStyle}">
                    ${mkNightTargetCards("fl_doctor_save", savedNight.doctorSave, t("tool.flow.action.doctorSave"))}
                  </div>
                `;
              }
              if (k === "bomber") {
                const mkCodeOpts = (sel) => {
                  const s = String(sel ?? "").trim();
                  const opts = [`<option value="" ${s === "" ? "selected" : ""}>—</option>`];
                  for (let i = 1; i <= 4; i++) {
                    const v = String(i);
                    opts.push(`<option value="${v}" ${s === v ? "selected" : ""}>${v}</option>`);
                  }
                  return opts.join("");
                };
                return `
                  ${sectionDisabled ? `<div class="note warn" style="margin-top:6px">${escapeHtml(getDisabledNote(sectionPlayerIdx))}</div>` : ""}
                  <div style="${sectionDisabledStyle}">
                    ${mkNightTargetCards("fl_bomb_target", savedNight.bombTarget, t("tool.flow.action.bomber"))}
                    <label>${escapeHtml(t("tool.flow.action.bombCode"))}
                      <select id="fl_bomb_code">${mkCodeOpts((savedNight.bombCode != null ? savedNight.bombCode : d.bombCode) || "")}</select>
                    </label>
                    <div class="note alert" id="fl_bomb_code_note" style="display:none; margin-top:6px"></div>
                  </div>
                `;
              }
              if (k === "magician") {
                return `
                  ${mkNightTargetCards("fl_magician_disable", savedNight.magicianDisable, t("tool.flow.action.magicianDisable"))}
                `;
              }
              if (k === "zodiac") {
                // Keep native disabled only for the even-night restriction; use visual styling for the Magician disable.
                const zodiacLabel = t("tool.flow.action.zodiacShot") + (evenNight ? "" : (appLang === "fa" ? " (فقط شب‌های زوج)" : " (even nights only)"));
                return `
                  ${sectionDisabled ? `<div class="note warn" style="margin-top:6px">${escapeHtml(getDisabledNote(sectionPlayerIdx))}</div>` : ""}
                  <div style="${sectionDisabledStyle}">
                    ${mkNightTargetCards("fl_zodiac_shot", savedNight.zodiacShot, zodiacLabel)}
                  </div>
                `;
              }
              if (k === "ocean") {
                const nightKey = String(f.day || 1);
                // Ocean team is PERSISTENT across nights (members stay on the team permanently).
                // d.oceanTeam = full accumulated team; max 2 members can be added total per game.
                if (!d.oceanTeam || !Array.isArray(d.oceanTeam)) d.oceanTeam = [];
                if (!d.oceanWakeByNight || typeof d.oceanWakeByNight !== "object") d.oceanWakeByNight = {};
                const teamArr = d.oceanTeam.map((x) => parseInt(x, 10)).filter((x) => Number.isFinite(x));
                const selectedSet = new Set(teamArr);
                // This night's newly added members (for bad-pick check and payload).
                const thisNightAdds = Array.isArray(d.oceanWakeByNight[nightKey])
                  ? d.oceanWakeByNight[nightKey].map((x) => parseInt(x, 10)).filter((x) => Number.isFinite(x))
                  : [];
                const canAdd = teamArr.length < 2;
                const quotaText = appLang === "fa"
                  ? `(${teamArr.length} از ۲ انتخاب استفاده شده)`
                  : `(${teamArr.length} of 2 picks used)`;
                const oceanResultLine = (() => {
                  try {
                    if (!thisNightAdds.length) return "";
                    let bad = false;
                    for (const tidx of thisNightAdds) {
                      const tr = (draw.players && draw.players[tidx] && draw.players[tidx].roleId) ? draw.players[tidx].roleId : "citizen";
                      const teamFa = (roles[tr] && roles[tr].teamFa) ? roles[tr].teamFa : "شهر";
                      if (teamFa === "مافیا" || tr === "zodiac") { bad = true; break; }
                    }
                    return `<div class="note ${bad ? "warn" : "pass"}" style="margin-top:6px">${escapeHtml(t(bad ? "tool.flow.ocean.result.bad" : "tool.flow.ocean.result.good"))}</div>`;
                  } catch { return ""; }
                })();
                const oceanList = teamArr.length
                  ? teamArr.map((idx) => {
                      const nm = names[idx] || t("common.playerN", { n: idx + 1 });
                      const addedThisNight = thisNightAdds.includes(idx);
                      return `<div style="padding:4px 0; font-weight:950">${escapeHtml(nm)}${addedThisNight ? "" : ` <span style="color:var(--muted); font-size:11px">(${escapeHtml(appLang === "fa" ? "از شب قبل" : "prev. night")})</span>`}</div>`;
                    }).join("")
                  : `<div class="note" style="margin-top:6px">${escapeHtml(appLang === "fa" ? "کسی انتخاب نشده است." : "No one selected.")}</div>`;
                const oceanHidden = thisNightAdds.map(String).join(",");
                const oceanCardsHtml = canAdd
                  ? mkNightTargetCards("fl_ocean_wake", (thisNightAdds[0] != null) ? thisNightAdds[0] : null, t("tool.flow.ocean.pick"), aliveIdxs)
                  : "";
                return `
                  ${sectionDisabled ? `<div class="note warn" style="margin-top:6px">${escapeHtml(getDisabledNote(sectionPlayerIdx))}</div>` : ""}
                  <div style="${sectionDisabledStyle}">
                    <div style="font-weight:1100">${escapeHtml(t("tool.flow.ocean.team"))} <span style="color:var(--muted); font-size:12px; font-weight:800">${escapeHtml(quotaText)}</span></div>
                    <div style="height:6px"></div>
                    ${oceanList}
                    ${canAdd ? `<div style="height:10px"></div>${oceanCardsHtml}` : `<input id="fl_ocean_wake" type="hidden" value="${escapeHtml(oceanHidden)}" /><div class="note" style="margin-top:8px">${escapeHtml(appLang === "fa" ? "سقف ۲ انتخاب مصرف شده — اوشن نمی‌تواند عضو جدید اضافه کند." : "2-pick limit reached — Ocean cannot add more members.")}</div>`}
                    ${oceanResultLine}
                  </div>
                `;
              }
              if (k === "kane") {
                return `
                  ${sectionDisabled ? `<div class="note warn" style="margin-top:6px">${escapeHtml(getDisabledNote(sectionPlayerIdx))}</div>` : ""}
                  <div style="${sectionDisabledStyle}">
                    ${mkNightTargetCards("fl_kane_mark", savedNight.kaneMark, t("tool.flow.action.kaneMark"))}
                  </div>
                `;
              }
              if (k === "constantine") {
                const nc = d && d.nightConstantineAppliedByDay ? d.nightConstantineAppliedByDay : {};
                const constantineUsed = Object.keys(nc).some((dk) => {
                  const r = nc[dk];
                  return r && r.revived != null && Number.isFinite(parseInt(r.revived, 10));
                });
                const deadIdxs = (draw.players || [])
                  .map((p, idx) => (p && p.alive === false) ? idx : null)
                  .filter((x) => x !== null);
                if (constantineUsed) {
                  return `
                    ${sectionDisabled ? `<div class="note warn" style="margin-top:6px">${escapeHtml(getDisabledNote(sectionPlayerIdx))}</div>` : ""}
                    <div style="${sectionDisabledStyle}">
                      <div class="note warn" style="margin-top:6px">${escapeHtml(t("tool.flow.constantine.abilityUsed"))}</div>
                      <input type="hidden" id="fl_const_revive" value="">
                    </div>
                  `;
                }
                if (!deadIdxs.length) return `<div class="note" style="margin-top:6px">${escapeHtml(appLang === "fa" ? "کسی برای برگرداندن نیست." : "No one to revive.")}</div>`;
                return `
                  ${sectionDisabled ? `<div class="note warn" style="margin-top:6px">${escapeHtml(getDisabledNote(sectionPlayerIdx))}</div>` : ""}
                  <div style="${sectionDisabledStyle}">
                    ${mkNightTargetCards("fl_const_revive", savedNight.constantineRevive, t("tool.flow.action.constantineRevive"), deadIdxs)}
                  </div>
                `;
              }
              if (k === "nostradamus") {
                const savedArr = Array.isArray(savedNight.nostPick3) ? savedNight.nostPick3 : [];
                const cleanArr = savedArr.map((x) => parseInt(x, 10)).filter((x) => Number.isFinite(x));
                const allIdxs = (draw.players || []).map((_, i) => i);
                const nostNightKey = String(f.day || 1);
                const nostRes = (d && d.nostResultByNight && d.nostResultByNight[nostNightKey]) ? d.nostResultByNight[nostNightKey] : null;
                const nostResultLine = (!nostRes || nostRes.mafiaCount === undefined || nostRes.mafiaCount === null) ? "" : (appLang === "fa" ? `نتیجه: ${fmtNum(nostRes.mafiaCount)} نفر از این ۳ نفر مافیا هستند.` : `Result: ${nostRes.mafiaCount} of the 3 are Mafia.`);
                const cardsHtml = mkNightMultiPickCards("fl_nost_pick3", cleanArr, 3, t("tool.flow.action.nostPick3"), allIdxs);
                return `${cardsHtml}<div id="fl_nost_result" class="note result" style="margin-top:6px; ${nostResultLine ? "" : "display:none"}">${escapeHtml(nostResultLine)}</div>`;
              }
              if (k === "heir") {
                // Heir picks successor during Intro Night only (intro_night_run).
                return null;
              }
              if (k === "herbalist") {
                // Kabo: antidote decision is in dedicated steps (night_poisoned_player, night_herbalist_antidote, night_poison_result).
                // Here we only show poison pick for the current night, or exhausted.
                const herbCycleDone = !!(d && d.herbalistCycleComplete);
                const isKabo = (typeof getDrawScenarioForFlow === "function" && getDrawScenarioForFlow() === "kabo");

                if (!isKabo) {
                  // Non-Kabo: two-night mechanic — antidote decision here when prev night had poison.
                  const herbPrevKey = String(Math.max(0, (f.day || 1) - 1));
                  const herbPrevActions = (d && d.nightActionsByNight && d.nightActionsByNight[herbPrevKey]) ? d.nightActionsByNight[herbPrevKey] : null;
                  const herbPrevPoisonRaw = herbPrevActions ? herbPrevActions.herbalistPoison : null;
                  const herbPrevPoison = (herbPrevPoisonRaw !== null && herbPrevPoisonRaw !== undefined && Number.isFinite(parseInt(herbPrevPoisonRaw, 10)))
                    ? parseInt(herbPrevPoisonRaw, 10) : null;
                  if (herbPrevPoison !== null) {
                    const poisonedName = names[herbPrevPoison] || t("common.playerN", { n: herbPrevPoison + 1 });
                    const savedAnt = (savedNight.herbalistAntidote === null || savedNight.herbalistAntidote === undefined) ? null : parseInt(savedNight.herbalistAntidote, 10);
                    const antOpts = [
                      `<option value="" ${savedAnt === null ? "selected" : ""}>${escapeHtml(appLang === "fa" ? `بدون پادزهر: ${poisonedName} حذف می‌شود` : `No antidote: ${poisonedName} will be eliminated`)}</option>`,
                      `<option value="${herbPrevPoison}" ${savedAnt === herbPrevPoison ? "selected" : ""}>${escapeHtml(appLang === "fa" ? `پادزهر را به ${poisonedName} بده` : `Give antidote to ${poisonedName}`)}</option>`,
                    ].join("");
                    return `
                      <div class="note" style="margin-bottom:8px">${escapeHtml(appLang === "fa" ? `مسموم شده (شب قبل): ${poisonedName}` : `Poisoned last night: ${poisonedName}`)}</div>
                      <label>${escapeHtml(appLang === "fa" ? "تصمیم عطار (پادزهر؟)" : "Herbalist — antidote decision")}
                        <select id="fl_herb_antidote">${antOpts}</select>
                      </label>
                    `;
                  }
                }

                if (herbCycleDone) {
                  // One poison + one antidote used — abilities exhausted.
                  return `<div class="note">${escapeHtml(appLang === "fa" ? "عطار هر دو توانایی خود را استفاده کرده است." : "Herbalist has used both abilities (poison + antidote) for this game.")}</div>`;
                } else {
                  // Poison night: no active poison — show poison picker.
                  return `
                    ${mkNightTargetCards("fl_herb_poison", savedNight.herbalistPoison, t("tool.flow.action.herbalistPoison"))}
                  `;
                }
              }
              if (k === "armorsmith") {
                const armorIdx = (() => {
                  try {
                    for (let i = 0; i < (draw.players || []).length; i++) {
                      const p = draw.players[i];
                      if (p && p.roleId === "armorsmith" && p.alive !== false) return i;
                    }
                  } catch {}
                  return null;
                })();
                const selfUsed = !!(d && d.armorsmithSelfUsed);
                const sIdx = (savedNight.armorsmithArmor === null || savedNight.armorsmithArmor === undefined) ? null : parseInt(savedNight.armorsmithArmor, 10);
                const disabledSet = (selfUsed && armorIdx !== null) ? new Set([armorIdx]) : new Set();
                return `
                  ${mkNightTargetCards("fl_armor_target", sIdx, t("tool.flow.action.armorsmithArmor"), aliveIdxs, disabledSet)}
                  <div class="note" style="margin-top:6px">${escapeHtml(t("tool.flow.action.armorsmith.selfOnce"))}</div>
                `;
              }
              if (k === "lecter") {
                return `
                  ${mkNightTargetCards("fl_lecter_save", savedNight.lecterSave, appLang === "fa" ? "نجاتِ دکتر لکتر" : "Dr. Lecter save")}
                  <div class="note" style="margin-top:6px">${escapeHtml(appLang === "fa" ? "دکتر لکتر می‌تواند یک نفر را از شلیک مافیا نجات دهد." : "Dr. Lecter can save one player from the mafia shot.")}</div>
                `;
              }
              if (k === "jokermaf") {
                const currentNightNum = f.day || 1;
                const jokerUsedArr = (Array.isArray(d.jokerUsed) ? d.jokerUsed : []).filter((n) => Number(n) !== currentNightNum);
                const jokerUsedCount = jokerUsedArr.length;
                const jokerRemaining = Math.max(0, 2 - jokerUsedCount);
                const quotaText = appLang === "fa"
                  ? `(${jokerUsedCount} از ۲ بار استفاده شده — ${jokerRemaining} بار باقی‌مانده)`
                  : `(${jokerUsedCount} of 2 uses — ${jokerRemaining} remaining)`;
                return `
                  <div class="note">${escapeHtml(quotaText)}</div>
                  ${jokerRemaining > 0 ? `
                  <div style="height:6px"></div>
                  ${mkNightTargetCards("fl_joker_target", savedNight.jokerTarget, appLang === "fa" ? "هدف جوکر (برعکس‌کردن استعلام)" : "Joker target (flip inquiry)")}
                  <div class="note" style="margin-top:6px">${escapeHtml(appLang === "fa" ? "استعلام کارآگاه از این نفر، همان شب برعکس می‌شود." : "Detective inquiry on this player is flipped this night.")}</div>
                  ` : `<div class="note warn" style="margin-top:6px">${escapeHtml(appLang === "fa" ? "جوکر مافیا هر دو بار را استفاده کرده است — دیگر قابلیت ندارد." : "Joker Mafia used both flips — no more uses.")}</div>`}
                `;
              }
              if (k === "swindler") {
                return `
                  ${mkNightTargetCards("fl_swindler_target", savedNight.swindlerTarget, appLang === "fa" ? "هدف شیاد (برهم‌زنِ استعلام)" : "Swindler target (disrupt inquiry)")}
                  <div class="note" style="margin-top:6px">${escapeHtml(appLang === "fa" ? "اگر کارآگاه این نفر را استعلام کند، نتیجه «شهروند» نمایش می‌یابد." : "If Detective queries this player, the result shows as 'Citizen'.")}</div>
                `;
              }
              if (k === "researcher") {
                const isIntroNight = f.phase === "intro_night";
                return `
                  <div style="font-weight:1100; margin-bottom:6px">${escapeHtml(appLang === "fa" ? "گره محقق (لینک)" : "Researcher link")} ${isIntroNight ? `<span style="color:var(--muted); font-weight:900">(${escapeHtml(appLang === "fa" ? "شب معارفه — محقق لینک نمی‌زند" : "intro night — no link")})</span>` : ""}</div>
                  ${isIntroNight ? `<input type="hidden" id="fl_researcher_link" value="" disabled><div class="note">${escapeHtml(appLang === "fa" ? "در شب معارفه لینک ثبت نمی‌شود." : "No link on intro night.")}</div>` : mkNightTargetCards("fl_researcher_link", savedNight.researcherLink, appLang === "fa" ? "گره محقق (لینک)" : "Researcher link")}
                  ${isIntroNight ? "" : `<div class="note" style="margin-top:6px">${escapeHtml(appLang === "fa" ? "اگر محقق با شات شب یا رأی از بازی خارج شود، نفر لینک‌شده هم معمولاً خارج می‌شود (به‌جز رئیس مافیا)." : "If Researcher is eliminated, the linked player usually goes too (except Mafia Boss).")}</div>`}
                `;
              }
              if (k === "natasha") {
                return `
                  ${mkNightTargetCards("fl_natasha_target", savedNight.natashaTarget, appLang === "fa" ? "هدف سکوت ناتاشا" : "Natasha silence target")}
                  <div class="note" style="margin-top:6px">${escapeHtml(appLang === "fa" ? "این بازیکن فردا نمی‌تواند صحبت کند (معمولاً تکرار پشت‌سرهم ممنوع)." : "This player cannot speak tomorrow (usually can't be repeated consecutively).")}</div>
                `;
              }
              if (k === "sniper") {
                const sniperUsed = (() => {
                  try {
                    const currentNightKey = String(f.day || 1);
                    const byNight = d.nightActionsByNight && typeof d.nightActionsByNight === "object" ? d.nightActionsByNight : {};
                    for (const nk of Object.keys(byNight)) {
                      if (nk === currentNightKey) continue; // current night can still change
                      const n = byNight[nk];
                      if (n && n.sniperShot !== null && n.sniperShot !== undefined && Number.isFinite(Number(n.sniperShot))) return true;
                    }
                  } catch {}
                  return false;
                })();
                const sniperNote = sniperUsed
                  ? (appLang === "fa" ? "تک‌تیرانداز تیرش را قبلاً استفاده کرده است." : "Sniper already used their shot.")
                  : (appLang === "fa" ? "تک‌تیرانداز فقط یک تیر دارد. اگر به شهروند شلیک کند، خودش کشته می‌شود." : "Sniper has one shot. Shooting a Citizen eliminates the Sniper.");
                return `
                  <div class="note" style="margin-top:2px">${escapeHtml(sniperNote)}</div>
                  ${!sniperUsed ? `
                  <div style="height:6px"></div>
                  ${mkNightTargetCards("fl_sniper_shot", savedNight.sniperShot, appLang === "fa" ? "هدف تک‌تیرانداز" : "Sniper shot target")}
                  ` : ""}
                `;
              }
              if (k === "negotiator") {
                return `
                  <div class="note">${escapeHtml(appLang === "fa" ? "در شب معمولی، مذاکره‌کننده اکشن ندارد. فقط در «شب مذاکره» فعال است." : "On regular nights, Negotiator has no action. Only active on the Negotiation Night.")}</div>
                  <div style="height:6px"></div>
                  ${mkNightTargetCards("fl_negotiator_target", savedNight.negotiatorTarget, appLang === "fa" ? "هدف مذاکره (شهروند برای تبدیل)" : "Negotiation target (citizen to convert)")}
                `;
              }
              if (k === "kadkhoda") {
                const kadUsedArr = Array.isArray(d.kadkhodaLinks) ? d.kadkhodaLinks : [];
                const kadUsedCount = kadUsedArr.length;
                const kadRemaining = Math.max(0, 2 - kadUsedCount);
                const kadQuota = appLang === "fa"
                  ? `(${kadUsedCount} از ۲ لینک استفاده شده — ${kadRemaining} لینک باقی)`
                  : `(${kadUsedCount} of 2 links used — ${kadRemaining} remaining)`;
                return `
                  <div class="note">${escapeHtml(kadQuota)}</div>
                  ${kadRemaining > 0 ? `
                  <div style="height:6px"></div>
                  ${mkNightTargetCards("fl_kadkhoda_target", savedNight.kadkhodaTarget, appLang === "fa" ? "هدف بیداری کدخدا" : "Village Chief wake target")}
                  <div class="note" style="margin-top:6px">${escapeHtml(appLang === "fa" ? "اگر کدخدا یک مافیا (غیر خبرچین) را بیدار کند، کدخدا از بازی خارج می‌شود." : "If Village Chief wakes a Mafia (except Informant), Village Chief is eliminated.")}</div>
                  ` : `<div class="note warn" style="margin-top:6px">${escapeHtml(appLang === "fa" ? "کدخدا هر دو لینک را استفاده کرده است." : "Village Chief has used both links.")}</div>`}
                `;
              }
              if (k === "reporter") {
                const reporterUsed = !!(d && d.reporterUsed);
                const reporterNightKey = String(f.day || 1);
                const reporterRes = (d && d.reporterResultByNight && d.reporterResultByNight[reporterNightKey]) ? d.reporterResultByNight[reporterNightKey] : null;
                const reporterResultLine = (() => {
                  if (!reporterRes || reporterRes.target === null || reporterRes.target === undefined) return "";
                  return reporterRes.wasNegotiated
                    ? (appLang === "fa" ? "نتیجه: 👍 این بازیکن مذاکره شده." : "Result: 👍 This player was negotiated.")
                    : (appLang === "fa" ? "نتیجه: 👎 این بازیکن مذاکره نشده." : "Result: 👎 This player was not negotiated.");
                })();
                if (reporterUsed && !reporterRes) {
                  return `
                    <div class="note warn">${escapeHtml(appLang === "fa" ? "خبرنگار استعلام خود را استفاده کرده است." : "Reporter has used their inquiry.")}</div>
                  `;
                }
                return `
                  ${mkNightTargetCards("fl_reporter_target", savedNight.reporterTarget, appLang === "fa" ? "استعلام خبرنگار (مذاکره شده؟)" : "Reporter inquiry (was negotiated?)")}
                  <div id="fl_reporter_result" class="note" style="margin-top:6px; ${reporterResultLine ? "" : "display:none"}">${escapeHtml(reporterResultLine)}</div>
                `;
              }
              if (k === "investigator") {
                // Inspector only acts on Night 1.
                if ((f.day || 1) > 1) {
                  return `<div class="note">${escapeHtml(appLang === "fa" ? "بازپرس فقط در شب اول عمل می‌کند." : "Inspector only acts on Night 1.")}</div>`;
                }
                const nkStr = String(f.day || 1);
                const invSaved = (d && d.nightActionsByNight && d.nightActionsByNight[nkStr]) ? d.nightActionsByNight[nkStr] : {};
                return `
                  <div class="note">${escapeHtml(appLang === "fa" ? "بازپرس دو نفر را برای بازپرسی انتخاب می‌کند. اگر هر دو فردا زنده باشند، بازپرسی روز آغاز می‌شود." : "Inspector picks two players. If both survive to morning, interrogation begins the next day.")}</div>
                  <div style="height:6px"></div>
                  ${mkNightTargetCards("fl_investigator_t1", invSaved.investigatorT1 != null ? invSaved.investigatorT1 : null, appLang === "fa" ? "هدف اول بازپرسی" : "Interrogation target 1")}
                  <div style="height:10px"></div>
                  ${mkNightTargetCards("fl_investigator_t2", invSaved.investigatorT2 != null ? invSaved.investigatorT2 : null, appLang === "fa" ? "هدف دوم بازپرسی" : "Interrogation target 2")}
                `;
              }
              if (k === "representative") {
                return `
                  <div class="note">${escapeHtml(appLang === "fa" ? "نماینده قدرت روز دارد (وتو رأی‌گیری یا حمایت از بازیکن). این مرحله برای اطلاع‌رسانی یا سیگنال است — اکشن شبانه ندارد." : "Representative has a day power (veto vote or player protection). This step is for moderator notification only — no recordable night action.")}</div>
                `;
              }
              if (k === "nato") {
                // NATO standalone wake (in scenarios where it appears separately from the Mafia group).
                const _natoCurrentNight2 = f.day || 1;
                const _natoUsedNight2 = (d && d.natoUsedNight != null) ? Number(d.natoUsedNight) : null;
                const natoUsed2 = _natoUsedNight2 !== null && _natoUsedNight2 !== _natoCurrentNight2;
                const mkNatoRoleOpts2 = (savedRoleId) => {
                  const saved = String(savedRoleId || "");
                  const seen = new Set();
                  const opts = [`<option value="" ${saved === "" ? "selected" : ""}>—</option>`];
                  for (const p of (draw.players || [])) {
                    if (!p || !p.roleId) continue;
                    const rid = String(p.roleId);
                    if (seen.has(rid)) continue;
                    seen.add(rid);
                    const fa = (roles[rid] && roles[rid].faName) ? roles[rid].faName : rid;
                    const en = (typeof ROLE_I18N !== "undefined" && ROLE_I18N[rid] && ROLE_I18N[rid].name) ? ROLE_I18N[rid].name : fa;
                    opts.push(`<option value="${escapeHtml(rid)}" ${rid === saved ? "selected" : ""}>${escapeHtml(appLang === "fa" ? fa : en)}</option>`);
                  }
                  return opts.join("");
                };
                return `
                  ${natoUsed2 ? `<div class="note warn">${escapeHtml(appLang === "fa" ? "ناتو قبلاً از قابلیت حدس نقش استفاده کرده است." : "NATO already used the role-guess ability.")}</div>` : `
                  <div class="note" style="margin-bottom:6px">${escapeHtml(appLang === "fa" ? "می‌تواند نقش دقیق یک نفر را حدس بزند. درست → خارج / غلط → هیچ." : "Can guess one player's exact role. Correct → eliminated / Wrong → nothing.")}</div>
                  ${mkNightTargetCards("fl_nato_target", savedNight.natoTarget, appLang === "fa" ? "هدف حدس ناتو" : "NATO guess target")}
                  <label style="margin-top:6px">${escapeHtml(appLang === "fa" ? "نقش حدس‌زده شده" : "Guessed role")}
                    <select id="fl_nato_role_guess">${mkNatoRoleOpts2(savedNight.natoRoleGuess)}</select>
                  </label>
                  `}
                `;
              }
              if (k === "hacker") {
                return `
                  ${mkNightTargetCards("fl_hacker_block", savedNight.hackerBlock, appLang === "fa" ? "هدف مسدودسازی هکر" : "Hacker block target")}
                  <div class="note" style="margin-top:6px">${escapeHtml(appLang === "fa" ? "آن بازیکن همان شب نمی‌تواند از توانایی شبانه‌اش استفاده کند." : "That player cannot use their night ability this night.")}</div>
                `;
              }
              if (k === "guide") {
                const guidePrevNightKey = String((f.day || 1) - 1);
                const guidePrevActions = (d && d.nightActionsByNight && d.nightActionsByNight[guidePrevNightKey]) ? d.nightActionsByNight[guidePrevNightKey] : null;
                const guidePrevTarget = (guidePrevActions && guidePrevActions.guideTarget !== null && guidePrevActions.guideTarget !== undefined && Number.isFinite(parseInt(guidePrevActions.guideTarget, 10))) ? parseInt(guidePrevActions.guideTarget, 10) : null;
                // Build options with prev-night target disabled
                const guideTargetIdx = (savedNight.guideTarget !== null && savedNight.guideTarget !== undefined && savedNight.guideTarget !== "")
                  ? parseInt(savedNight.guideTarget, 10) : null;
                const guideTargetName = guideTargetIdx !== null ? (names[guideTargetIdx] || t("common.playerN", { n: guideTargetIdx + 1 })) : null;
                const guideTargetIsMafia = guideTargetIdx !== null
                  ? detectiveInquiryIsMafia((draw.players[guideTargetIdx] || {}).roleId || "citizen") : false;
                const guideRevealWarning = (guideTargetIsMafia && guideTargetName)
                  ? `<div class="note alert" style="margin-top:6px">⚠ ${escapeHtml(appLang === "fa" ? `راهنما برای ${guideTargetName} لو رفت.` : `Guide is revealed to ${guideTargetName}.`)}</div>` : "";
                const guideInqResultLine = (savedNight.guideInquiryTarget !== null && savedNight.guideInquiryTarget !== undefined && savedNight.guideInquiryTarget !== "")
                  ? (savedNight.guideInquiryIsMafia ? (appLang === "fa" ? "✓ مافیا" : "✓ Mafia") : (appLang === "fa" ? "✗ شهروند" : "✗ Citizen"))
                  : "";
                const guidedInquirySection = (guideTargetIdx !== null && !guideTargetIsMafia) ? `
                  <div style="margin-top:12px; padding-top:10px; border-top:1px solid rgba(255,255,255,.18)">
                    <div style="font-weight:1100">${escapeHtml(appLang === "fa" ? `${guideTargetName} — استعلام` : `${guideTargetName} — Inquiry`)}</div>
                    <div class="note" style="margin-top:4px">${escapeHtml(appLang === "fa" ? "این بازیکن بیدار می‌شود و از یک نفر استعلام می‌گیرد." : "This player wakes up and chooses someone to inquire about.")}</div>
                    <div style="margin-top:8px">${mkNightTargetCards("fl_guide_inquiry_target", savedNight.guideInquiryTarget, appLang === "fa" ? "هدف استعلام" : "Inquiry target")}</div>
                    <div id="fl_guide_inquiry_result" style="margin-top:6px; font-size:1.1em; font-weight:1100; ${guideInqResultLine ? "" : "display:none"}; color:${savedNight.guideInquiryIsMafia ? "rgba(255,100,80,1)" : "rgba(60,210,160,1)"}">${escapeHtml(guideInqResultLine)}</div>
                  </div>` : "";
                const guideDisabledSet = Number.isFinite(guidePrevTarget) ? new Set([guidePrevTarget]) : new Set();
                return `
                  ${mkNightTargetCards("fl_guide_target", savedNight.guideTarget, appLang === "fa" ? "هدف راهنما" : "Guide target", aliveIdxs, guideDisabledSet)}
                  <div class="note" style="margin-top:6px">${escapeHtml(appLang === "fa" ? "بازیکن انتخاب‌شده از یک نفر استعلام می‌گیرد. اگر مافیا انتخاب شود، هویت راهنما برای آن مافیا لو می‌رود." : "The chosen player inquires about someone. If mafia is chosen, Guide's identity is revealed to that mafia.")}</div>
                  ${guideRevealWarning}
                  ${guidedInquirySection}
                `;
              }
              if (k === "bodyguard") {
                return `
                  ${mkNightTargetCards("fl_bodyguard_protect", savedNight.bodyguardProtect, appLang === "fa" ? "هدف محافظت (در برابر ترور)" : "Bodyguard protect target")}
                  <div class="note" style="margin-top:6px">${escapeHtml(appLang === "fa" ? "اگر یاغی (ترور) آن شب این نفر را هدف قرار دهد، ترور ناموفق است. خودِ محافظ نیز در برابر ترور مصون است." : "If the Rebel assassinates this player, the attempt fails. Bodyguard is also immune to assassination.")}</div>
                `;
              }
              if (k === "minemaker") {
                const minemakerUsed = !!(d && d.minemakerUsed);
                const currentMineRaw = (d && d.minemakerMine !== null && d.minemakerMine !== undefined && Number.isFinite(Number(d.minemakerMine))) ? parseInt(d.minemakerMine, 10) : null;
                const mineTargetName = (currentMineRaw !== null && names[currentMineRaw]) ? names[currentMineRaw] : (currentMineRaw !== null ? t("common.playerN", { n: currentMineRaw + 1 }) : "");
                return `
                  ${minemakerUsed ? `
                  <div class="note warn">${escapeHtml(appLang === "fa" ? `مین‌گذار قابلیتش را استفاده کرده${currentMineRaw !== null ? ` — مین روی: ${mineTargetName}` : ""}.` : `Minemaker has used their mine${currentMineRaw !== null ? ` — mine on: ${mineTargetName}` : ""}.`)}</div>
                  ` : `
                  ${mkNightTargetCards("fl_minemaker_target", savedNight.minemakerTarget, appLang === "fa" ? "هدف مین (یک‌بار در کل بازی)" : "Mine target (once per game)")}
                  <div class="note" style="margin-top:6px">${escapeHtml(appLang === "fa" ? "اگر مافیا همان شب این نفر را شات کند، مین منفجر می‌شود و یک داوطلب از مافیا نیز خارج می‌شود." : "If mafia shoots this player the same night, mine explodes and a volunteering mafia member is also eliminated.")}</div>
                  `}
                `;
              }
              if (k === "lawyer") {
                const lawyerUsed = !!(d && d.lawyerUsed);
                return `
                  ${lawyerUsed ? `
                  <div class="note warn">${escapeHtml(appLang === "fa" ? "وکیل قابلیتش را استفاده کرده است." : "Lawyer has used their protection.")}</div>
                  ` : `
                  ${mkNightTargetCards("fl_lawyer_target", savedNight.lawyerTarget, appLang === "fa" ? "هدف مصونیت (یک‌بار در کل بازی)" : "Immunity target (once per game)")}
                  <div class="note" style="margin-top:6px">${escapeHtml(appLang === "fa" ? "این بازیکن فردا از حذف با رأی‌گیری مصون است." : "This player is immune to vote-elimination tomorrow.")}</div>
                  `}
                `;
              }
              if (k === "soldier") {
                return `
                  ${mkNightTargetCards("fl_soldier_target", savedNight.soldierTarget, appLang === "fa" ? "دریافت‌کننده تیر (سرباز)" : "Bullet recipient (Soldier)")}
                  <div class="note" style="margin-top:6px">${escapeHtml(appLang === "fa" ? "مافیا → سرباز خارج می‌شود. شهروند → او می‌تواند شلیک کند." : "Mafia → Soldier is eliminated. Citizen → they may shoot.")}</div>
                  <div style="margin-top:10px">${mkNightTargetCards("fl_soldier_gun_shot", savedNight.soldierGunShot, appLang === "fa" ? "هدف شلیک شهروند (اگر تیر به شهروند رفته)" : "Citizen gun shot target (if bullet given to citizen)")}</div>
                  <div class="note" style="margin-top:6px">${escapeHtml(appLang === "fa" ? "مافیا → مافیا خارج؛ دون مافیا → هیچ‌کس؛ شهروند → خودش خارج می‌شود. خالی بگذارید اگر شلیک نکرد." : "Mafia → mafia out; Don Mafia → nobody; Citizen → recipient out. Leave blank if they did not shoot.")}</div>
                `;
              }
              if (k === "gunslinger") {
                if (!showGunner) return `<div class="note">${escapeHtml(noActionTxt)}</div>`;
                const gunHolders = Object.keys(guns || {})
                  .map((k) => parseInt(k, 10))
                  .filter((idx) => Number.isFinite(idx) && idx >= 0 && draw.players && idx < draw.players.length)
                  .filter((idx) => (draw.players[idx] && draw.players[idx].alive !== false));
                const gunsList = gunHolders.length
                  ? gunHolders.map((idx) => {
                      const g = guns[idx] || {};
                      const nm = names[idx] || t("common.playerN", { n: idx + 1 });
                      const typeLabel = (g.type === "real") ? t("tool.flow.guns.type.real") : t("tool.flow.guns.type.fake");
                      const usedTxt = g.used ? ` <span style="color:var(--muted); font-weight:900">(${escapeHtml(appLang === "fa" ? "مصرف شد" : "used")})</span>` : "";
                      return `<div style="display:flex; align-items:center; justify-content:space-between; gap:10px; padding:6px 0">
                        <div style="font-weight:950">${escapeHtml(nm)} — <span style="color:var(--muted)">${escapeHtml(typeLabel)}</span>${usedTxt}</div>
                        <button class="btn" type="button" data-gun-rm="${idx}" style="padding:6px 10px; font-size:12px">${escapeHtml(t("tool.flow.guns.remove"))}</button>
                      </div>`;
                    }).join("")
                  : `<div class="note" style="margin-top:6px">${escapeHtml(appLang === "fa" ? "فعلاً کسی تفنگ ندارد." : "No one has a gun yet.")}</div>`;
                return `
                  <div class="note" style="margin-top:6px">${escapeHtml(t("tool.flow.guns.gunslingerIs", { name: gunnerName }))}</div>
                  ${sectionDisabled ? `<div class="note warn" style="margin-top:8px">${escapeHtml(getDisabledNote(sectionPlayerIdx))}</div>` : ""}
                  <div style="${sectionDisabledStyle}">
                    <div class="row one" style="margin-top:8px">
                      <label>${escapeHtml(t("tool.flow.guns.giveTo"))}
                        <select id="fl_gun_give_to">${optsAlive}</select>
                      </label>
                      <label>${escapeHtml(t("tool.flow.guns.type"))}
                        <select id="fl_gun_type">
                          <option value="real">${escapeHtml(t("tool.flow.guns.type.real"))}</option>
                          <option value="fake">${escapeHtml(t("tool.flow.guns.type.fake"))}</option>
                        </select>
                      </label>
                    </div>
                    <div class="note" style="margin-top:8px">${escapeHtml(t("tool.flow.guns.selfFakeOnly"))}</div>
                    <div style="height:10px"></div>
                    <button class="btn" id="fl_gun_give" type="button">${escapeHtml(t("tool.flow.guns.give"))}</button>
                    <div class="note" id="fl_gun_give_note" style="display:none; margin-top:8px"></div>
                  </div>
                  <div style="height:12px"></div>
                  <div style="font-weight:1100">${escapeHtml(t("tool.flow.guns.hasGun"))}</div>
                  <div style="height:6px"></div>
                  ${gunsList}
                `;
              }
              return `<div class="note">${escapeHtml(noActionTxt)}</div>`;
            };

            const orderedRaw = (wake && wake.length) ? wake : [];
            // Intro-only roles (e.g. Nostradamus) act only on intro night, not on Night 1+ (per pedarkhande.md)
            const orderedFiltered = orderedRaw.filter((w) => {
              const x = String(w || "").toLowerCase();
              return !x.includes("intro night only") && !x.includes("فقط شب معارفه");
            });
            // Bomb can only be used once per game; hide Bomber from night order after that.
            const bombAlreadyUsed = (() => {
              try {
                const byDay = (f.draft && f.draft.bombByDay && typeof f.draft.bombByDay === "object") ? f.draft.bombByDay : {};
                for (const day of Object.keys(byDay)) {
                  const rec = byDay[day];
                  if (rec && (rec.target !== null && rec.target !== undefined)) return true;
                }
                if (Array.isArray(f.events)) {
                  if (f.events.some((e) => e && e.kind === "bomb_resolve")) return true;
                }
                return false;
              } catch { return false; }
            })();
            // Hide Zodiac entirely on odd nights (no wake, no action block).
            // Pedarkhande: skip Kane when Kane is dead (invisible bullet after revealing mafia).
            const keepKaneAlive = (w) => {
              if (scenario !== "pedarkhande") return true;
              const x = String(w || "").toLowerCase();
              if (!x.includes("kane") && !x.includes("کین")) return true;
              const kaneIdx = (draw.players || []).findIndex((p) => p && p.roleId === "citizenKane");
              if (kaneIdx === -1) return true;
              return (draw.players[kaneIdx] && draw.players[kaneIdx].alive !== false);
            };
            // Skip roles not in the draw (must match flow-engine's keepRoleInDraw).
            const keepRoleInDraw = (stepId) => {
              const players = draw && draw.players;
              if (!players || !players.length) return true;
              const sid = String(stepId || "");
              const stepToRoles = { night_heir: ["heir"], night_herbalist: ["herbalist"], night_detective: ["detective"], night_armorsmith: ["armorsmith"], night_kadkhoda: ["kadkhoda"], night_doctor: ["doctor", "watson"], night_constantine: ["constantine"], night_kane: ["citizenKane"], night_ocean: ["ocean"], night_bomber: ["bomber"], night_zodiac: ["zodiac"], night_professional: ["professional", "leon"], night_sniper: ["sniper"], night_negotiator: ["negotiator"], night_reporter: ["reporter"], night_researcher: ["researcher"], night_swindler: ["swindler"], night_natasha: ["natasha"], night_jokermaf: ["jokerMafia"], night_lecter: ["doctorLecter"], night_magician: ["magician"], night_hacker: ["hacker"], night_guide: ["guide"], night_bodyguard: ["bodyguard"], night_minemaker: ["minemaker"], night_lawyer: ["lawyer"], night_soldier: ["soldier"], night_nato: ["nato"], night_investigator: ["investigator"] };
              const roleIds = stepToRoles[sid];
              if (!roleIds) return true;
              if (sid === "night_mafia") return players.some((p) => p && p.roleId && (roles[p.roleId] && roles[p.roleId].teamFa === "مافیا"));
              return players.some((p) => p && roleIds.includes(p.roleId));
            };
            const flowCfg = (typeof getFlowConfig === "function") ? getFlowConfig(scenario) : null;
            const nightStepIds = Array.isArray(flowCfg && flowCfg.night) ? flowCfg.night : null;
            // Build ordered with same filters as flow-engine; iterate over wake with original index for stepId.
            const ordered = [];
            for (let i = 0; i < orderedRaw.length; i++) {
              const w = orderedRaw[i];
              const x = String(w || "").toLowerCase();
              if (x.includes("intro night only") || x.includes("فقط شب معارفه")) continue;
              if (!evenNight && normWake(w) === "zodiac") continue;
              if ((normWake(w) === "bomber" && bombAlreadyUsed) || !keepKaneAlive(w)) continue;
              const stepId = (nightStepIds && i < nightStepIds.length) ? String(nightStepIds[i]) : null;
              if (stepId && !keepRoleInDraw(stepId)) continue;
              ordered.push(w);
            }
            // Death timing helpers (see `setPlayerLife` -> `deadAtByIdx`)
            const deathRec = (idx) => {
              try {
                const r = d && d.deadAtByIdx ? d.deadAtByIdx[String(idx)] : null;
                return (r && typeof r === "object") ? r : null;
              } catch {
                return null;
              }
            };
            const deadBeforeTonight = (idx) => {
              try {
                const p = (draw && draw.players) ? draw.players[idx] : null;
                if (!p) return true;
                if (p.alive !== false) return false;
                const r = deathRec(idx);
                // No record => treat as dead-before (safe).
                if (!r) return true;
                const rd = Number(r.day || 1);
                const rp = String(r.phase || "day");
                // We are in night_run, so f.phase should be "night".
                // If they died in a previous day/night, they are dead before tonight.
                if (rd < Number(f.day || 1)) return true;
                // If they died earlier today (day phase), they are dead for tonight.
                if (rd === Number(f.day || 1) && rp === "day") return true;
                // If they died this same night (resolved at dawn), they can still act tonight.
                if (rd === Number(f.day || 1) && rp === "night") return false;
                return true;
              } catch {
                return true;
              }
            };
            const aliveTonight = (idx) => {
              try {
                const p = (draw && draw.players) ? draw.players[idx] : null;
                if (!p) return false;
                if (p.alive !== false) return true;
                // dead now, but if death is "this night", treat as alive for tonight (pending).
                return !deadBeforeTonight(idx);
              } catch {
                return false;
              }
            };
            const nightStatusTag = (idx) => {
              try {
                const p = (draw && draw.players) ? draw.players[idx] : null;
                if (!p) return null;
                if (p.alive !== false) return null;
                return deadBeforeTonight(idx) ? "dead" : "pending";
              } catch {
                return null;
              }
            };
            const wakeActorSuffix = (wakeLabel) => {
              try {
                const k = normWake(wakeLabel);
                const joiner = (appLang === "fa") ? "، " : ", ";
                const deadTag = (appLang === "fa") ? "مرده" : "dead";
                const pendingTag = (appLang === "fa") ? "در انتظار صبح" : "pending";
                const labelFor = (idx) => {
                  return (names && names[idx]) ? names[idx] : t("common.playerN", { n: idx + 1 });
                };
                const alive = (idx) => aliveTonight(idx);
                const idxsByRole = (roleIds, { onlyAlive } = {}) => {
                  try {
                    const out = [];
                    for (let i = 0; i < (draw.players || []).length; i++) {
                      const p = draw.players[i];
                      if (!p) continue;
                      if (onlyAlive && !alive(i)) continue;
                      if (roleIds.includes(p.roleId)) out.push(i);
                    }
                    return out;
                  } catch {
                    return [];
                  }
                };
                const idxsByTeamFa = (teamFa, { onlyAlive } = {}) => {
                  try {
                    const out = [];
                    for (let i = 0; i < (draw.players || []).length; i++) {
                      const p = draw.players[i];
                      if (!p) continue;
                      if (onlyAlive && !alive(i)) continue;
                      const rid = p.roleId || "citizen";
                      const tf = (roles[rid] && roles[rid].teamFa) ? roles[rid].teamFa : "شهر";
                      if (tf === teamFa) out.push(i);
                    }
                    return out;
                  } catch {
                    return [];
                  }
                };

                // Shared role-id lookup for all wake keys
                const wakeRoleMap = {
                  doctor: ["doctor", "watson"],
                  lecter: ["doctorLecter"],
                  detective: ["detective"],
                  professional: ["professional", "leon"],
                  bomber: ["bomber"],
                  magician: ["magician"],
                  zodiac: ["zodiac"],
                  gunslinger: ["gunslinger"],
                  ocean: ["ocean"],
                  jokermaf: ["jokerMafia"],
                  swindler: ["swindler"],
                  researcher: ["researcher"],
                  natasha: ["natasha"],
                  sniper: ["sniper"],
                  negotiator: ["negotiator"],
                  kadkhoda: ["kadkhoda"],
                  heir: ["heir"],
                  herbalist: ["herbalist"],
                  armorsmith: ["armorsmith"],
                  nostradamus: ["nostradamus"],
                  kane: ["citizenKane"],
                  constantine: ["constantine"],
                  reporter: ["reporter"],
                  representative: ["representative"],
                  investigator: ["investigator"],
                };
                let idxs = [];
                if (k === "mafia") {
                  // Mafia wake is a team wake in most scenarios.
                  idxs = idxsByTeamFa("مافیا", { onlyAlive: false });
                } else if (wakeRoleMap[k]) {
                  idxs = idxsByRole(wakeRoleMap[k], { onlyAlive: false });
                }

                if (!idxs.length) return "";
                const list = idxs
                  .map((idx) => {
                    const st = nightStatusTag(idx);
                    if (st === "dead") return `${labelFor(idx)} (${deadTag})`;
                    if (st === "pending") return `${labelFor(idx)} (${pendingTag})`;
                    return labelFor(idx);
                  })
                  .join(joiner);
                return list ? ` (${list})` : "";
              } catch {
                return "";
              }
            };
            const wakeActors = (wakeLabel) => {
              try {
                const k = normWake(wakeLabel);
                const alive = (idx) => aliveTonight(idx);
                const idxsByRole = (roleIds) => {
                  const out = [];
                  for (let i = 0; i < (draw.players || []).length; i++) {
                    const p = draw.players[i];
                    if (!p) continue;
                    if (roleIds.includes(p.roleId)) out.push(i);
                  }
                  return out;
                };
                const idxsByTeamFa = (teamFa) => {
                  const out = [];
                  for (let i = 0; i < (draw.players || []).length; i++) {
                    const p = draw.players[i];
                    if (!p) continue;
                    const rid = p.roleId || "citizen";
                    const tf = (roles[rid] && roles[rid].teamFa) ? roles[rid].teamFa : "شهر";
                    if (tf === teamFa) out.push(i);
                  }
                  return out;
                };

                const wakeRoleMap2 = {
                  doctor: ["doctor", "watson"],
                  lecter: ["doctorLecter"],
                  detective: ["detective"],
                  professional: ["professional", "leon"],
                  bomber: ["bomber"],
                  magician: ["magician"],
                  zodiac: ["zodiac"],
                  gunslinger: ["gunslinger"],
                  ocean: ["ocean"],
                  jokermaf: ["jokerMafia"],
                  swindler: ["swindler"],
                  researcher: ["researcher"],
                  natasha: ["natasha"],
                  sniper: ["sniper"],
                  negotiator: ["negotiator"],
                  kadkhoda: ["kadkhoda"],
                  heir: ["heir"],
                  herbalist: ["herbalist"],
                  armorsmith: ["armorsmith"],
                  nostradamus: ["nostradamus"],
                  kane: ["citizenKane"],
                  constantine: ["constantine"],
                  reporter: ["reporter"],
                  representative: ["representative"],
                  investigator: ["investigator"],
                  nato: ["nato"],
                  hacker: ["hacker"],
                  guide: ["guide"],
                  bodyguard: ["bodyguard"],
                  minemaker: ["minemaker"],
                  lawyer: ["lawyer"],
                  soldier: ["soldier"],
                };
                let all = [];
                if (k === "mafia") {
                  all = idxsByTeamFa("مافیا");
                } else if (wakeRoleMap2[k]) {
                  all = idxsByRole(wakeRoleMap2[k]);
                }
                const aliveIdxs = all.filter((idx) => alive(idx));
                return { all, alive: aliveIdxs };
              } catch {
                return { all: [], alive: [] };
              }
            };
            let _wakeNum = 0;
            const oneBlock = (w) => {
              const a = wakeActors(w);
              if (!a.all.length) return "";
              const _introOnly = normWake(w);
              if (_introOnly === "heir") return "";
              if (_introOnly === "nostradamus" && (f.day || 1) !== 1) return "";
              _wakeNum++;
              const isDeadBlock = a.alive.length === 0;
              const deadBadge = isDeadBlock ? ` • ${appLang === "fa" ? "مرده" : "dead"}` : "";
              const headerTxt = `${_wakeNum}. ${String(w || "")}${wakeActorSuffix(w)}${deadBadge}`;
              return `
                <div style="padding:10px 0; border-bottom:1px solid rgba(255,255,255,.06); ${isDeadBlock ? "opacity:.55; filter:saturate(.2);" : ""}">
                  <div style="font-weight:1100">${escapeHtml(headerTxt)}</div>
                  <div style="height:8px"></div>
                  <div class="row one">
                    ${isDeadBlock ? `<div class="note">${escapeHtml(appLang === "fa" ? "این نقش/تیم قبل از امشب مرده است و اکشن ندارد." : "This role/team is dead before tonight and has no action.")}</div>` : sectionFor(w)}
                  </div>
                </div>
              `;
            };
            const isPerRoleNight = cur.id && (String(cur.id).startsWith("night_step_") || (f.phase === "night" && steps.length > 1));
            // Use cur.title (from filtered steps) as the wake label — ensures content matches the step title
            // even when ordered has different length (e.g. roles filtered out by keepRoleInDraw).
            const actionBlocks = isPerRoleNight
              ? (() => {
                  const w = (cur && cur.title) ? cur.title : (ordered && (f.step || 0) >= 0 && (f.step || 0) < ordered.length) ? ordered[f.step] : undefined;
                  if (w === undefined) return `<div class="note">${escapeHtml(noActionTxt)}</div>`;
                  return oneBlock(w) || `<div class="note">${escapeHtml(noActionTxt)}</div>`;
                })()
              : ordered.map((w) => oneBlock(w)).filter(Boolean).join("");

            // Researcher chain death warning: shown when the mafia shot target is the researcher
            // and the researcher has a link set for this night.
            const researcherNightChainNote = (() => {
              try {
                const shotIdxRaw = savedNight && savedNight.mafiaShot != null ? parseInt(savedNight.mafiaShot, 10) : null;
                if (shotIdxRaw === null || !Number.isFinite(shotIdxRaw)) return "";
                const shotPlayer = draw.players[shotIdxRaw];
                if (!shotPlayer || shotPlayer.roleId !== "researcher") return "";
                const linkIdxRaw = savedNight && savedNight.researcherLink != null ? parseInt(savedNight.researcherLink, 10) : null;
                if (linkIdxRaw === null || !Number.isFinite(linkIdxRaw)) return "";
                const linkPlayer = draw.players[linkIdxRaw];
                if (!linkPlayer) return "";
                const linkedRoleId = linkPlayer.roleId || "citizen";
                if (linkedRoleId === "mafiaBoss") return "";
                if (scenario === "bazras" && linkedRoleId !== "nato" && linkedRoleId !== "swindler") return "";
                const linkedName = names[linkIdxRaw] || t("common.playerN", { n: linkIdxRaw + 1 });
                const msg = appLang === "fa"
                  ? `⚠ محقق هدف شلیک مافیاست — ${linkedName} (که محقق با او لینک داشت) نیز از بازی خارج می‌شود.`
                  : `⚠ Researcher is the mafia shot target — ${linkedName} (linked to Researcher) is also eliminated.`;
                return `<div class="note result" style="margin-top:8px">${escapeHtml(msg)}</div>`;
              } catch {
                return "";
              }
            })();

            body = `
              ${bombLine ? `<div class="note" style="margin-top:6px">${escapeHtml(bombLine)}</div>` : ``}
              <div style="height:10px"></div>
              <div class="fl-scrollable" style="max-height: 60vh; overflow:auto; -webkit-overflow-scrolling: touch; border:1px solid rgba(255,255,255,.08); border-radius:14px; padding:10px; background: rgba(17,24,36,.25)">
                ${actionBlocks || `<div class="note">${escapeHtml(t("tool.wake.none"))}</div>`}
              </div>
              ${researcherNightChainNote}
            `;
          } else if (cur.id === "night_wake") {
            body = `${bombLine ? `<div class="note" style="margin-top:8px">${escapeHtml(bombLine)}</div>` : ``}
              <div style="height:10px"></div>
              ${wake.length ? wake.map((x, i) => `<div style="padding:6px 0;font-weight:950">${i + 1}. ${escapeHtml(x)}</div>`).join("") : `<div class="note">${escapeHtml(t("tool.wake.none"))}</div>`}`;
          } else if (cur.id === "day_guns") {
            // When entering this step from a later step (going backward), deaths were
            // applied on "Next" — revert them so players appear alive while reviewing.
            // Shots and used-gun state are PRESERVED so the moderator doesn't need to
            // re-enter everything; clicking Next again will re-apply the same deaths.
            // When re-rendering within the step (after firing), applied===false so no revert.
            try {
              const dayKey = String(f.day || 1);
              const d2 = f.draft || {};
              const rec = (d2.gunShotAppliedByDay && d2.gunShotAppliedByDay[dayKey]) || null;
              if (rec && rec.applied) {
                const shots = (rec.shots || []).slice().reverse();
                for (const shot of shots) {
                  // Revert the actual death, but leave guns[shooter].used = true
                  // and rec.shots intact so the pending list stays visible.
                  if (shot.type === "real" && shot.targetPrevAlive) {
                    try { setPlayerLife(shot.target, { alive: true }); } catch {}
                  }
                }
                rec.applied = false;
                // Remove gun_shot events so they can be re-added cleanly on Next.
                if (Array.isArray(f.events)) {
                  f.events = f.events.filter((e) => !(e && e.kind === "gun_shot" && e.phase === f.phase && Number(e.day) === Number(f.day)));
                }
                f.draft = d2;
                try { renderCast(); } catch {}
                saveState(appState);
              }
            } catch {}

            // Bomb revert: entering this step from beyond (going backward) reverts any applied bomb kill.
            if (!bombApplyJustHappened) {
              try {
                const db = f.draft || {};
                if (!db.bombByDay || typeof db.bombByDay !== "object") db.bombByDay = {};
                if (!db.bombResolveByDay || typeof db.bombResolveByDay !== "object") db.bombResolveByDay = {};
                if (!db.bombAppliedByDay || typeof db.bombAppliedByDay !== "object") db.bombAppliedByDay = {};
                const bkey = String(f.day || 1);
                const bprev = (db.bombAppliedByDay[bkey] && typeof db.bombAppliedByDay[bkey] === "object") ? db.bombAppliedByDay[bkey] : null;
                if (bprev && bprev.killed !== null && bprev.killed !== undefined && Number.isFinite(Number(bprev.killed))) {
                  const bpi = parseInt(bprev.killed, 10);
                  if (bprev.prevAlive === true) {
                    try { setPlayerLife(bpi, { alive: true }); } catch {}
                  }
                  bprev.killed = null;
                  bprev.prevAlive = null;
                  db.bombAppliedByDay[bkey] = bprev;
                }
                if (db.bombResolveByDay[bkey] && typeof db.bombResolveByDay[bkey] === "object") {
                  db.bombResolveByDay[bkey].resolved = false;
                  db.bombResolveByDay[bkey].outcome = null;
                }
                f.draft = db;
                saveState(appState);
              } catch {}
            }

            // list gun holders
            const guns = f.guns || {};
            const holders = Object.keys(guns)
              .map((k) => parseInt(k, 10))
              .filter((idx) => Number.isFinite(idx) && idx >= 0 && idx < names.length)
              .filter((idx) => (draw.players[idx] && draw.players[idx].alive !== false)); // alive only

            const holderList = holders.length
              ? holders.map((idx) => {
                  const g = guns[idx] || {};
                  const typeLabel = (g.type === "real") ? t("tool.flow.guns.type.real") : t("tool.flow.guns.type.fake");
                  const usedTxt = g.used ? ` <span style="color:var(--muted); font-weight:900">(${escapeHtml(appLang === "fa" ? "مصرف شد" : "used")})</span>` : "";
                  return `<div style="padding:6px 0; font-weight:950">${escapeHtml(names[idx])} — <span style="color:var(--muted)">${escapeHtml(typeLabel)}</span>${usedTxt}</div>`;
                }).join("")
              : `<div class="note" style="margin-top:6px">${escapeHtml(appLang === "fa" ? "فعلاً کسی تفنگ ندارد." : "No one has a gun yet.")}</div>`;

            const shooterOpts = [`<option value="">—</option>`].concat(
              holders.filter((idx) => !(guns[idx] && guns[idx].used)).map((idx) => `<option value="${idx}">${escapeHtml(names[idx])}</option>`)
            ).join("");
            const targetOpts = optsAlive;

            // Pending shots this phase (recorded but not yet fatal until Next is clicked).
            const pendingShots = (() => {
              try {
                const dayKey = String(f.day || 1);
                const d2 = f.draft || {};
                const rec = (d2.gunShotAppliedByDay && d2.gunShotAppliedByDay[dayKey]) || null;
                return (rec && Array.isArray(rec.shots)) ? rec.shots : [];
              } catch { return []; }
            })();
            const pendingShotsHtml = pendingShots.length
              ? `
                <div style="height:12px"></div>
                <div style="font-weight:1100">${escapeHtml(appLang === "fa" ? "تیرهای شلیک‌شده (در این مرحله):" : "Shots fired this phase:")}</div>
                <div style="height:6px"></div>
                ${pendingShots.map((s) => {
                  const shooterName = escapeHtml(names[s.shooter] || t("common.playerN", { n: s.shooter + 1 }));
                  const targetName = escapeHtml(names[s.target] || t("common.playerN", { n: s.target + 1 }));
                  const typeLabel = s.type === "real" ? (appLang === "fa" ? "واقعی" : "real") : (appLang === "fa" ? "جعلی" : "fake");
                  return `<div style="display:flex; align-items:center; justify-content:space-between; gap:8px; padding:4px 0">
                    <div style="color:rgba(255,160,80,1); font-weight:1000">${shooterName} → ${targetName} <span style="color:var(--muted); font-weight:900">(${escapeHtml(typeLabel)})</span></div>
                    <button class="smallbtn" data-gun-shot-rm="${s.shooter}" type="button" style="padding:6px 10px; font-size:12px; flex:0 0 auto">${escapeHtml(appLang === "fa" ? "حذف" : "Undo")}</button>
                  </div>`;
                }).join("")}
                <div class="note" style="margin-top:6px">${escapeHtml(appLang === "fa" ? "بازیکنان تیرخورده تا پایان این مرحله زنده‌اند. با «بعدی» خارج می‌شوند." : "Shot players stay alive until this phase ends. Deaths apply when you press Next.")}</div>
              `
              : "";

            // Bomb section (shown inline below guns when a bomb is planted today).
            const bombSectionHtml = (() => {
              try {
                const db = f.draft || {};
                if (!db.bombByDay || typeof db.bombByDay !== "object") return "";
                if (!db.bombResolveByDay || typeof db.bombResolveByDay !== "object") db.bombResolveByDay = {};
                const brec = db.bombByDay[String(f.day)] || null;
                const btargetIdx = (brec && brec.target !== null && brec.target !== undefined && Number.isFinite(Number(brec.target))) ? parseInt(brec.target, 10) : null;
                const bhasBomb = !!(f.bombActive || (brec && btargetIdx !== null));
                if (!bhasBomb) return "";
                const btargetName = (btargetIdx !== null) ? (names[btargetIdx] || t("common.playerN", { n: btargetIdx + 1 })) : "—";
                const bplantedCode = (brec && brec.code != null && String(brec.code).trim()) ? String(brec.code).trim() : "";
                const bguardIdx = (() => {
                  for (let i = 0; i < (draw.players || []).length; i++) {
                    const p = draw.players[i];
                    if (!p) continue;
                    const rid = p.roleId || "citizen";
                    if (roles[rid] && roles[rid].canSacrificeForBomb) return i;
                  }
                  return null;
                })();
                const bhasGuard = bguardIdx !== null;
                // Guard is alive for sacrifice if: alive before this day AND not pending-dead
                // from a real gun shot recorded in this phase (gun deaths commit on Next, not immediately).
                const bguardPendingDead = (() => {
                  try {
                    const dayKey = String(f.day || 1);
                    const rec = (db.gunShotAppliedByDay && db.gunShotAppliedByDay[dayKey]) || null;
                    if (!rec || !Array.isArray(rec.shots)) return false;
                    return rec.shots.some((s) => s && s.target === bguardIdx && s.type === "real" && s.targetPrevAlive);
                  } catch { return false; }
                })();
                const bguardAlive = bguardIdx !== null
                  && draw.players[bguardIdx]
                  && draw.players[bguardIdx].alive !== false
                  && !bguardPendingDead;
                const bguardDisabledPrevNight = (bguardIdx !== null && db.disabledByNight && db.disabledByNight[String(f.day)] != null)
                  ? (parseInt(db.disabledByNight[String(f.day)], 10) === bguardIdx) : false;
                const bguardCanSacrifice = bhasGuard && bguardAlive && !bguardDisabledPrevNight;
                const bguardName = (bguardIdx !== null) ? (names[bguardIdx] || t("common.playerN", { n: bguardIdx + 1 })) : "—";
                const br0 = (db.bombResolveByDay[String(f.day)] && typeof db.bombResolveByDay[String(f.day)] === "object")
                  ? db.bombResolveByDay[String(f.day)]
                  : { guardSacrifice: false, guardGuess: "", targetGuess: "", resolved: false, outcome: null };
                const bmkCodeOpts = (sel) => {
                  const s = String(sel ?? "").trim();
                  const opts = [`<option value="" ${s === "" ? "selected" : ""}>—</option>`];
                  for (let i = 1; i <= 4; i++) {
                    const v = String(i);
                    opts.push(`<option value="${v}" ${s === v ? "selected" : ""}>${v}</option>`);
                  }
                  return opts.join("");
                };
                const bheadline = (appLang === "fa")
                  ? `بمب جلوی «${btargetName}» کاشته شده است${bplantedCode ? ` (کد: ${fmtNum(bplantedCode)})` : ""}.`
                  : `Bomb planted in front of "${btargetName}"${bplantedCode ? ` (code: ${bplantedCode})` : ""}.`;
                const bguardLine = bhasGuard
                  ? (bguardAlive
                    ? (bguardDisabledPrevNight ? (appLang === "fa" ? `محافظ (${bguardName}) شب گذشته غیرفعال شده و نمی‌تواند فدا شود.` : `Guard (${bguardName}) was disabled last night and cannot sacrifice.`) : "")
                    : (appLang === "fa" ? `محافظ (${bguardName}) مرده است.` : `Guard (${bguardName}) is dead.`))
                  : (appLang === "fa" ? "محافظ در این بازی وجود ندارد." : "No Guard in this game.");
                const boutcomeLine = (() => {
                  if (!bplantedCode) return "";
                  const bapplied = !!(br0 && br0.resolved);
                  const bsac = !!(bguardCanSacrifice && br0 && br0.guardSacrifice);
                  const bguardGuess = String((br0 && br0.guardGuess) || "").trim();
                  const btargetGuess = String((br0 && br0.targetGuess) || "").trim();
                  const bguess = bsac ? bguardGuess : btargetGuess;
                  const bprefix = (appLang === "fa")
                    ? (bapplied ? "نتیجه (اعمال‌شده): " : "نتیجه: ")
                    : (bapplied ? "Result (applied): " : "Result: ");
                  if (!bguess) {
                    return bprefix + (appLang === "fa"
                      ? (bsac ? "کدِ محافظ را انتخاب کنید." : "حدسِ هدف را انتخاب کنید.")
                      : (bsac ? "Pick Guard guess." : "Pick target guess."));
                  }
                  const bok = String(bguess) === String(bplantedCode);
                  const bo = bsac
                    ? (bok ? "neutralized_guard" : "guard_died")
                    : (bok ? "neutralized_target" : "target_died");
                  if (bo === "neutralized_guard") return bprefix + (appLang === "fa" ? "محافظ بمب را خنثی کرد." : "Guard neutralized the bomb.");
                  if (bo === "guard_died") return bprefix + (appLang === "fa" ? "محافظ اشتباه حدس زد و مرد." : "Guard guessed wrong and died.");
                  if (bo === "neutralized_target") return bprefix + (appLang === "fa" ? "هدف درست حدس زد و بمب خنثی شد." : "Target guessed right; bomb neutralized.");
                  if (bo === "target_died") return bprefix + (appLang === "fa" ? "هدف اشتباه حدس زد و مرد." : "Target guessed wrong and died.");
                  return "";
                })();
                return `
                  <div style="height:14px; border-top:1px solid rgba(255,255,255,.12); margin-top:12px; padding-top:2px"></div>
                  <div class="note" style="margin-top:6px">${escapeHtml(bheadline)}</div>
                  <div style="height:10px"></div>
                  ${bguardLine ? `<div class="note">${escapeHtml(bguardLine)}</div><div style="height:10px"></div>` : ``}
                  ${bhasGuard ? `
                    <label for="fl_bomb_guard" style="display:flex; flex-direction:row; align-items:center; justify-content:space-between; gap:14px; font-weight:950; cursor:pointer; user-select:none; -webkit-user-select:none">
                      <span>${escapeHtml(appLang === "fa" ? "محافظ فدا می‌شود؟" : "Does Guard sacrifice?")}</span>
                      <input id="fl_bomb_guard" type="checkbox" ${br0.guardSacrifice ? "checked" : ""} ${bguardCanSacrifice ? "" : "disabled"} style="width:24px; height:24px; margin:0; accent-color: var(--primary)" />
                    </label>
                    <div style="height:10px"></div>
                  ` : ``}
                  ${bhasGuard && br0.guardSacrifice ? `
                    <label>${escapeHtml(appLang === "fa" ? `حدسِ محافظ (${bguardName})` : `Guard (${bguardName}) guess`)}
                      <select id="fl_bomb_guard_guess">${bmkCodeOpts(br0.guardGuess)}</select>
                    </label>
                  ` : `
                    <label>${escapeHtml(appLang === "fa" ? `حدسِ ${btargetName}` : `${btargetName} guess`)}
                      <select id="fl_bomb_target_guess">${bmkCodeOpts(br0.targetGuess)}</select>
                    </label>
                  `}
                  ${boutcomeLine ? `<div class="note result" style="margin-top:10px">${escapeHtml(boutcomeLine)}</div>` : ``}
                  <div class="note" style="margin-top:10px">${escapeHtml(appLang === "fa" ? "با انتخاب حدس، نتیجه بلافاصله اعمال می‌شود." : "Your choice applies immediately.")}</div>
                `;
              } catch { return ""; }
            })();

            body = `
              <div class="note" style="margin-top:6px">${escapeHtml(t("tool.flow.guns.title"))}</div>
              <div style="height:10px"></div>
              <div style="font-weight:1100">${escapeHtml(t("tool.flow.guns.hasGun"))}</div>
              <div style="height:6px"></div>
              ${holderList}
              ${pendingShotsHtml}
              <div style="height:12px"></div>
              <div style="font-weight:1100">${escapeHtml(t("tool.flow.guns.fire"))}</div>
              <div class="row one" style="margin-top:8px">
                <label>${escapeHtml(t("tool.flow.guns.shooter"))}
                  <select id="fl_gun_shooter">${shooterOpts}</select>
                </label>
                <label>${escapeHtml(t("tool.flow.guns.target"))}
                  <select id="fl_gun_target">${targetOpts}</select>
                </label>
              </div>
              <div style="height:10px"></div>
              <button class="btn primary" id="fl_gun_fire" type="button">${escapeHtml(t("tool.flow.guns.fire"))}</button>
              <div class="note" id="fl_gun_note" style="display:none; margin-top:10px"></div>
              ${bombSectionHtml}
            `;
          } else if (cur.id === "day_gun_expiry") {
            // Entering this step (from any direction) reverts previously applied expiry
            // deaths so the player list accurately reflects "who still has an unfired
            // real gun right now".  Deaths are applied when the moderator clicks Next.
            try { revertGunExpiryForDay(f); } catch {}
            try { renderCast(); } catch {}
            saveState(appState);

            const expiryGuns = f.guns || {};
            const expiryVictims = Object.keys(expiryGuns)
              .map((k) => parseInt(k, 10))
              .filter((idx) => Number.isFinite(idx) && idx >= 0 && idx < names.length)
              .filter((idx) => draw.players[idx] && draw.players[idx].alive !== false)
              .filter((idx) => expiryGuns[idx] && !expiryGuns[idx].used && expiryGuns[idx].type === "real");

            body = expiryVictims.length
              ? `
                <div class="note" style="margin-top:6px">${escapeHtml(t("tool.flow.day.gunExpiry.desc"))}</div>
                <div style="height:10px"></div>
                ${expiryVictims.map((idx) => `<div style="padding:6px 0; font-weight:1000; color:rgba(255,160,80,1)">${escapeHtml(names[idx] || t("common.playerN", { n: idx + 1 }))}</div>`).join("")}
                <div class="note" style="margin-top:10px">${escapeHtml(appLang === "fa" ? "برای خارج کردن این بازیکنان «بعدی» را بزنید." : "Click Next to eliminate these players.")}</div>
              `
              : `<div class="note" style="margin-top:6px">${escapeHtml(t("tool.flow.day.gunExpiry.none"))}</div>`;
          } else if (cur.id === "night_actions") {
            const d = f.draft || {};
            const evenNight = ((f.day || 1) % 2 === 0);
            const gunnerIdxs = (draw.players || [])
              .map((p, idx) => (p && p.roleId === "gunslinger" && p.alive !== false) ? idx : null)
              .filter((x) => x !== null);
            const showGunner = !!gunnerIdxs.length;
            const gunnerOpts = [`<option value="">—</option>`].concat(
              gunnerIdxs.map((idx) => `<option value="${idx}">${escapeHtml(names[idx])}</option>`)
            ).join("");
            const guns = f.guns || {};
            const givenCount = Object.keys(guns || {}).length;
            const nightKey = String(f.day || 1);
            if (!d.nightGunGivesByNight || typeof d.nightGunGivesByNight !== "object") d.nightGunGivesByNight = {};
            const nightGives = Array.isArray(d.nightGunGivesByNight[nightKey]) ? d.nightGunGivesByNight[nightKey] : [];
            const nightGiveCount = nightGives.length;
            const nightRealCount = nightGives.filter((x) => x && x.type === "real").length;
            body = `
              <div class="fl-scrollable" style="max-height: 46vh; overflow:auto; -webkit-overflow-scrolling: touch;">
                ${showGunner ? `
                <div style="font-weight:1100">${escapeHtml(t("tool.flow.guns.add"))}</div>
                <div class="row one" style="margin-top:8px">
                  <label>${escapeHtml(appLang === "fa" ? "تفنگدار" : "Gunslinger")}
                    <select id="fl_gun_from">${gunnerOpts}</select>
                  </label>
                  <label>${escapeHtml(t("tool.flow.guns.giveTo"))}
                    <select id="fl_gun_give_to">${optsAlive}</select>
                  </label>
                  <label>${escapeHtml(t("tool.flow.guns.type"))}
                    <select id="fl_gun_type">
                      <option value="real">${escapeHtml(t("tool.flow.guns.type.real"))}</option>
                      <option value="fake">${escapeHtml(t("tool.flow.guns.type.fake"))}</option>
                    </select>
                  </label>
                </div>
                <div class="note" style="margin-top:8px">${escapeHtml(t("tool.flow.guns.selfFakeOnly"))}</div>
                <div style="height:10px"></div>
                <button class="btn" id="fl_gun_give" type="button">${escapeHtml(t("tool.flow.guns.give"))}</button>
                <div class="note" id="fl_gun_give_note" style="display:none; margin-top:8px"></div>
                <div style="height:14px"></div>
                ` : ``}
                <div class="row one">
                  <label>${escapeHtml(t("tool.flow.action.mafiaShot"))}
                    <select id="fl_mafia_shot">${opts}</select>
                  </label>
                  <label>${escapeHtml(t("tool.flow.action.doctorSave"))}
                    <select id="fl_doctor_save">${opts}</select>
                  </label>
                  <label>${escapeHtml(t("tool.flow.action.bomber"))}
                    <select id="fl_bomb_target">${opts}</select>
                  </label>
                  <label>${escapeHtml(t("tool.flow.action.bombCode"))}
                    <select id="fl_bomb_code">
                      <option value="" ${(String(d.bombCode || "").trim() === "") ? "selected" : ""}>—</option>
                      <option value="1" ${(String(d.bombCode || "").trim() === "1") ? "selected" : ""}>1</option>
                      <option value="2" ${(String(d.bombCode || "").trim() === "2") ? "selected" : ""}>2</option>
                      <option value="3" ${(String(d.bombCode || "").trim() === "3") ? "selected" : ""}>3</option>
                      <option value="4" ${(String(d.bombCode || "").trim() === "4") ? "selected" : ""}>4</option>
                    </select>
                  </label>
                  <label>${escapeHtml(t("tool.flow.action.magicianDisable"))}
                    <select id="fl_magician_disable">${opts}</select>
                  </label>
                  <label>${escapeHtml(t("tool.flow.action.zodiacShot"))} ${evenNight ? "" : `<span style="color:var(--muted); font-weight:900">(even nights only)</span>`}
                    <select id="fl_zodiac_shot" ${evenNight ? "" : "disabled"}>${opts}</select>
                  </label>
                  <label>${escapeHtml(t("tool.flow.action.oceanWake"))}
                    <select id="fl_ocean_wake" multiple size="${Math.min(8, Math.max(3, aliveIdxs.length))}">${opts}</select>
                  </label>
                </div>
              </div>
            `;
          } else {
            body = `
              ${bombLine ? `<div class="note" style="margin-top:6px">${escapeHtml(bombLine)}</div><div style="height:10px"></div>` : ``}
              <div class="note">${escapeHtml(appLang === "fa" ? "این مرحله هنوز کنترل اختصاصی ندارد." : "This step does not have a dedicated control yet.")}</div>
            `;
          }

          openToolModal(t("tool.flow.title"), `
            <div class="toolBox">
              <div style="text-align:center">
                <div style="font-weight:1200; font-size:22px; letter-spacing:.2px">${escapeHtml(flowPhaseTitle(f))}</div>
                <div style="color:var(--muted); font-weight:900; font-size:12px; margin-top:6px">${escapeHtml(stepLine)} • ${escapeHtml(cur.title)}</div>
              </div>

              <div style="height:12px"></div>
              ${body}

              <div style="height:14px"></div>
              <div class="actions">
                <button class="btn" id="fl_prev" type="button">${escapeHtml(t("tool.flow.prev"))}</button>
                ${f.phase !== "winner" ? `<button class="btn primary" id="fl_next" type="button">${escapeHtml(t("tool.flow.next"))}</button>` : ""}
              </div>
            </div>
          `, { hideBottom: true });

          $("fl_prev").onclick = () => {
            // Persist night selections before leaving so they survive back-navigation.
            try {
              const steps = getFlowSteps(f);
              const cur = steps[Math.min(steps.length - 1, Math.max(0, f.step || 0))];
              const isPerRoleNight = cur && cur.id && (String(cur.id).startsWith("night_step_") || (f.phase === "night" && steps.length > 1));
              if (isPerRoleNight && typeof snapshotNightActionsFromUI === "function") {
                snapshotNightActionsFromUI(true);
              }
            } catch {}
            prevFlowStep();
          };

          // Inline timers embedded in day_vote, day_elim, kabo_shoot, chaos_run, and bazras_interrogation steps.
          if (cur && (cur.id === "day_vote" || cur.id === "day_elim" || cur.id === "kabo_shoot" || cur.id === "chaos_run" || cur.id === "bazras_interrogation")) {
            ensureTimers();
            if (!audioUnlocked) try { unlockAudio(); } catch {}
            const timerKeys = cur.id === "day_vote" ? ["talk", "challenge"] : cur.id === "chaos_run" ? ["chaos"] : cur.id === "bazras_interrogation" ? ["talk"] : ["defense"];
            for (const key of timerKeys) {
              const btn = document.getElementById("tm_btn_" + key);
              if (btn) btn.onclick = () => startOrPauseTimer(key);
              const rst = document.getElementById("tm_rst_" + key);
              if (rst) rst.onclick = () => resetSingleTimer(key);
              const val = document.getElementById("tm_" + key);
              if (val) val.onclick = () => showTimerPicker(key, showFlowTool);
            }
            updateTimerIcons();
            if (appState.god.timers.running && !timerInterval) {
              timerInterval = setInterval(tickTimers, 250);
            }
          }

          // Chaos pick changes — save and re-render to update computed winner.
          if (cur && cur.id === "chaos_run") {
            try {
              document.querySelectorAll("[data-chaos-idx]").forEach((sel) => {
                sel.addEventListener("change", () => {
                  try {
                    const idx = String(sel.dataset.chaosIdx);
                    const val = sel.value;
                    const d2 = f.draft || {};
                    if (!d2.chaosPicks) d2.chaosPicks = {};
                    if (val === "") { delete d2.chaosPicks[idx]; } else { d2.chaosPicks[idx] = parseInt(val, 10); }
                    f.draft = d2;
                    saveState(appState);
                    showFlowTool();
                  } catch {}
                });
              });
            } catch {}
          }


          const commitVoteFromUI = () => {
            try {
              // Button-toggle voting: selection is already saved live on each click.
              // Just record the voter count for the defense-round threshold.
              const d = f.draft || {};
              d.voteVotersByDay = (d.voteVotersByDay && typeof d.voteVotersByDay === "object") ? d.voteVotersByDay : {};
              d.voteVotersByDay[f.day] = aliveIdxs.length;
              f.draft = d;
              saveState(appState);
              return true;
            } catch {
              return false;
            }
          };
          const snapshotElimVotesFromUI = () => {
            try {
              const d = f.draft || {};
              if (!d.elimVotesByDay || typeof d.elimVotesByDay !== "object") d.elimVotesByDay = {};
              const candIdxs = Array.isArray(d.elimCandidatesByDay && d.elimCandidatesByDay[f.day]) ? d.elimCandidatesByDay[f.day] : [];
              const voters = aliveIdxs.length;
              const eligibleVoters = Math.max(0, voters - 1);
              const elimThreshold = getDefenseThreshold(eligibleVoters);
              // No defendants (no one reached threshold) => nothing to eliminate, allow advancing.
              if (!candIdxs.length) {
                d.elimVotesByDay[f.day] = {};
                d.elimLeadersByDay = (d.elimLeadersByDay && typeof d.elimLeadersByDay === "object") ? d.elimLeadersByDay : {};
                d.elimLeadersByDay[f.day] = [];
                d.elimPickedByDay = (d.elimPickedByDay && typeof d.elimPickedByDay === "object") ? d.elimPickedByDay : {};
                d.elimPickedByDay[f.day] = null;
                f.draft = d;
                addFlowEvent("day_elim", { counts: {}, best: 0, leaders: [] });
                try { addFlowEvent("day_elim_out", { out: null }); } catch {}
                try { applyDayElimFromPayload(f, { out: null }); } catch {}
                saveState(appState);
                return true;
              }
              const maxVotes = Math.max(0, aliveIdxs.length - 1);
              const counts = {};
              let best = 0;
              for (const idx of candIdxs) {
                const el = document.getElementById(`fl_elim_${idx}`);
                const raw = el ? el.value : "0";
                const n = Math.max(0, Math.min(maxVotes, Math.floor(Number(raw || 0))));
                counts[idx] = Number.isFinite(n) ? n : 0;
                best = Math.max(best, counts[idx] || 0);
              }
              d.elimVotesByDay[f.day] = counts;
              const leaders = Object.keys(counts)
                .map((k) => ({ idx: parseInt(k, 10), v: counts[k] }))
                .filter((x) => Number.isFinite(x.idx))
                .sort((a, b) => (b.v - a.v) || (a.idx - b.idx));
              const top = leaders.filter((x) => x.v === best && best > 0);
              d.elimLeadersByDay = (d.elimLeadersByDay && typeof d.elimLeadersByDay === "object") ? d.elimLeadersByDay : {};
              d.elimLeadersByDay[f.day] = top.map((x) => x.idx);
              d.elimPickedByDay = (d.elimPickedByDay && typeof d.elimPickedByDay === "object") ? d.elimPickedByDay : {};
              const prevPicked = (d.elimPickedByDay && d.elimPickedByDay[f.day] !== undefined) ? d.elimPickedByDay[f.day] : null;
              const prevPickedIdxRaw = Number.isFinite(Number(prevPicked)) ? parseInt(prevPicked, 10) : null;
              const prevPickedIdx = (prevPickedIdxRaw !== null && Number.isFinite(prevPickedIdxRaw)) ? prevPickedIdxRaw : (() => {
                try {
                  const ev = (f.events || []).slice().reverse().find((e) => e && e.kind === "day_elim_draw" && Number(e.day) === Number(f.day));
                  const p = ev && ev.data ? ev.data.picked : null;
                  const n = parseInt(String(p ?? ""), 10);
                  return Number.isFinite(n) ? n : null;
                } catch {
                  return null;
                }
              })();
              const keptPicked = (top.length === 1)
                ? top[0].idx
                : (top.length > 1 && prevPickedIdx !== null && top.some((x) => x.idx === prevPickedIdx))
                  ? prevPickedIdx
                  : null;
              d.elimPickedByDay[f.day] = keptPicked;
              f.draft = d;
              addFlowEvent("day_elim", { counts, best, leaders: top.map((x) => x.idx) });
              // Deaths are NOT applied live while votes are being entered.
              // The actual elimination is committed when the user presses Next (commitElimFromUI).
              saveState(appState);
              return true;
            } catch {
              return false;
            }
          };
          const snapshotNightActionsFromUI = (mergeOnly) => {
            try {
              const nk = String(f.day || 1);
              const d = f.draft || {};
              if (!d.nightActionsByNight || typeof d.nightActionsByNight !== "object") d.nightActionsByNight = {};
              const per = (mergeOnly && d.nightActionsByNight[nk] && typeof d.nightActionsByNight[nk] === "object")
                ? { ...d.nightActionsByNight[nk] } : {};
              // Only when relevant controls exist (night_run page), or when mergeOnly we always run to merge into draft.
              const hasAny = mergeOnly ||
                document.getElementById("fl_mafia_shot") ||
                document.getElementById("fl_doctor_save") ||
                document.getElementById("fl_det_query") ||
                document.getElementById("fl_pro_shot") ||
                document.getElementById("fl_bomb_target") ||
                document.getElementById("fl_magician_disable") ||
                document.getElementById("fl_zodiac_shot") ||
                document.getElementById("fl_ocean_wake") ||
                document.getElementById("fl_bomb_code") ||
                document.getElementById("fl_kane_mark") ||
                document.getElementById("fl_const_revive") ||
                document.getElementById("fl_nost_pick3") ||
                document.getElementById("fl_heir_pick") ||
                document.getElementById("fl_herb_poison") ||
                document.getElementById("fl_herb_antidote") ||
                document.getElementById("fl_armor_target") ||
                document.getElementById("fl_lecter_save") ||
                document.getElementById("fl_joker_target") ||
                document.getElementById("fl_swindler_target") ||
                document.getElementById("fl_researcher_link") ||
                document.getElementById("fl_natasha_target") ||
                document.getElementById("fl_sniper_shot") ||
                document.getElementById("fl_negotiator_target") ||
                document.getElementById("fl_kadkhoda_target") ||
                document.getElementById("fl_hacker_block") ||
                document.getElementById("fl_guide_target") ||
                document.getElementById("fl_guide_inquiry_target") ||
                document.getElementById("fl_bodyguard_protect") ||
                document.getElementById("fl_minemaker_target") ||
                document.getElementById("fl_lawyer_target") ||
                document.getElementById("fl_nato_target") ||
                document.getElementById("fl_nato_role_guess") ||
                document.getElementById("fl_sixth_sense_target") ||
                document.getElementById("fl_sixth_sense_role") ||
                document.getElementById("fl_investigator_t1") ||
                document.getElementById("fl_investigator_t2") ||
                document.getElementById("fl_sodagari_sacrifice") ||
                document.getElementById("fl_sodagari_target") ||
                document.getElementById("fl_soldier_target") ||
                document.getElementById("fl_soldier_gun_shot") ||
                document.getElementById("fl_neutralized_shot") ||
                document.getElementById("fl_betrayal_rep") ||
                document.getElementById("fl_betrayal_dir") ||
                document.getElementById("fl_capo_bullet_order") ||
                document.getElementById("fl_kabo_yakooza_target") ||
                document.getElementById("fl_executioner_target") ||
                document.getElementById("fl_executioner_role");
              if (!hasAny) return false;

              const read = (id) => { const el = document.getElementById(id); return el ? (el.value || "") : ""; };
              const readNum = (id) => { const v = read(id); return v === "" ? null : parseInt(v, 10); };
              const readCheck = (id) => { const el = document.getElementById(id); return el ? !!el.checked : false; };
              if (document.getElementById("fl_mafia_shot") || !mergeOnly) per.mafiaShot = readNum("fl_mafia_shot");
              if (document.getElementById("fl_godfather_action") || !mergeOnly) per.godfatherAction = read("fl_godfather_action") || "shoot";
              if (document.getElementById("fl_saul_buy_target") || !mergeOnly) per.saulBuyTarget = readNum("fl_saul_buy_target");
              if (document.getElementById("fl_sixth_sense_target") || !mergeOnly) per.sixthSenseTarget = readNum("fl_sixth_sense_target");
              if (document.getElementById("fl_sixth_sense_role") || !mergeOnly) per.sixthSenseRole = String(read("fl_sixth_sense_role") || "");
              if (document.getElementById("fl_matador_disable") || !mergeOnly) per.matadorDisable = readNum("fl_matador_disable");
              if (document.getElementById("fl_kabo_yakooza_target") || !mergeOnly) per.kaboYakoozaTarget = readNum("fl_kabo_yakooza_target");
              if (document.getElementById("fl_executioner_target") || !mergeOnly) per.executionerTarget = readNum("fl_executioner_target");
              if (document.getElementById("fl_executioner_role") || !mergeOnly) per.executionerRoleGuess = String(read("fl_executioner_role") || "");
              if (document.getElementById("fl_witch_target") || !mergeOnly) per.witchTarget = readNum("fl_witch_target");
              if (getDrawScenarioForFlow() === "pedarkhande" && per.godfatherAction && per.godfatherAction !== "shoot") per.mafiaShot = null;
              if (getDrawScenarioForFlow() === "pedarkhande" && per.godfatherAction && per.godfatherAction !== "sixth_sense") { per.sixthSenseTarget = null; per.sixthSenseRole = null; }
              if (getDrawScenarioForFlow() === "kabo" && per.godfatherAction && per.godfatherAction !== "shoot") per.mafiaShot = null;
              if (getDrawScenarioForFlow() === "kabo" && per.godfatherAction && per.godfatherAction !== "yakooza") per.kaboYakoozaTarget = null;
              if (getDrawScenarioForFlow() === "kabo" && per.godfatherAction && per.godfatherAction !== "guess_role") { per.executionerTarget = null; per.executionerRoleGuess = null; }
              if (document.getElementById("fl_doctor_save") || !mergeOnly) per.doctorSave = readNum("fl_doctor_save");
              if (document.getElementById("fl_det_query") || !mergeOnly) per.detectiveQuery = readNum("fl_det_query");
              if (document.getElementById("fl_pro_shot") || !mergeOnly) per.professionalShot = readNum("fl_pro_shot");
              if (document.getElementById("fl_bomb_target") || !mergeOnly) per.bombTarget = readNum("fl_bomb_target");
              if (document.getElementById("fl_bomb_code") || !mergeOnly) per.bombCode = String(read("fl_bomb_code") || "").trim() || null;
              if (document.getElementById("fl_magician_disable") || !mergeOnly) per.magicianDisable = readNum("fl_magician_disable");
              if (document.getElementById("fl_zodiac_shot") || !mergeOnly) per.zodiacShot = readNum("fl_zodiac_shot");
              if (document.getElementById("fl_kane_mark") || !mergeOnly) per.kaneMark = readNum("fl_kane_mark");
              if (document.getElementById("fl_const_revive") || !mergeOnly) per.constantineRevive = readNum("fl_const_revive");
              if (document.getElementById("fl_heir_pick") || !mergeOnly) per.heirPick = readNum("fl_heir_pick");
              if (document.getElementById("fl_herb_poison") || !mergeOnly) per.herbalistPoison = readNum("fl_herb_poison");
              if (document.getElementById("fl_herb_antidote") || !mergeOnly) per.herbalistAntidote = readNum("fl_herb_antidote");
              if (document.getElementById("fl_armor_target") || !mergeOnly) per.armorsmithArmor = readNum("fl_armor_target");
              if (document.getElementById("fl_lecter_save") || !mergeOnly) per.lecterSave = readNum("fl_lecter_save");
              if (document.getElementById("fl_joker_target") || !mergeOnly) per.jokerTarget = readNum("fl_joker_target");
              if (document.getElementById("fl_swindler_target") || !mergeOnly) per.swindlerTarget = readNum("fl_swindler_target");
              if (document.getElementById("fl_researcher_link") || !mergeOnly) per.researcherLink = readNum("fl_researcher_link");
              if (document.getElementById("fl_natasha_target") || !mergeOnly) per.natashaTarget = readNum("fl_natasha_target");
              if (document.getElementById("fl_sniper_shot") || !mergeOnly) per.sniperShot = readNum("fl_sniper_shot");
              if (document.getElementById("fl_negotiator_target") || !mergeOnly) per.negotiatorTarget = readNum("fl_negotiator_target");
              if (document.getElementById("fl_kadkhoda_target") || !mergeOnly) per.kadkhodaTarget = readNum("fl_kadkhoda_target");
              if (document.getElementById("fl_hacker_block") || !mergeOnly) per.hackerBlock = readNum("fl_hacker_block");
              if (document.getElementById("fl_guide_target") || !mergeOnly) per.guideTarget = readNum("fl_guide_target");
              if (document.getElementById("fl_guide_inquiry_target") || !mergeOnly) per.guideInquiryTarget = readNum("fl_guide_inquiry_target");
              if (document.getElementById("fl_bodyguard_protect") || !mergeOnly) per.bodyguardProtect = readNum("fl_bodyguard_protect");
              if (document.getElementById("fl_minemaker_target") || !mergeOnly) per.minemakerTarget = readNum("fl_minemaker_target");
              if (document.getElementById("fl_lawyer_target") || !mergeOnly) per.lawyerTarget = readNum("fl_lawyer_target");
              if (document.getElementById("fl_nato_target") || !mergeOnly) per.natoTarget = readNum("fl_nato_target");
              if (document.getElementById("fl_nato_role_guess") || !mergeOnly) per.natoRoleGuess = String(read("fl_nato_role_guess") || "");
              if (document.getElementById("fl_reporter_target") || !mergeOnly) per.reporterTarget = readNum("fl_reporter_target");
              if (document.getElementById("fl_investigator_t1") || !mergeOnly) per.investigatorT1 = readNum("fl_investigator_t1");
              if (document.getElementById("fl_investigator_t2") || !mergeOnly) per.investigatorT2 = readNum("fl_investigator_t2");
              if (document.getElementById("fl_sodagari_sacrifice") || !mergeOnly) per.sodagariSacrifice = readNum("fl_sodagari_sacrifice");
              if (document.getElementById("fl_sodagari_target") || !mergeOnly) per.sodagariTarget = readNum("fl_sodagari_target");
              if (document.getElementById("fl_soldier_target") || !mergeOnly) per.soldierTarget = readNum("fl_soldier_target");
              if (document.getElementById("fl_soldier_gun_shot") || !mergeOnly) per.soldierGunShot = readNum("fl_soldier_gun_shot");
              if (document.getElementById("fl_neutralized_shot") || !mergeOnly) per.neutralizedShot = readCheck("fl_neutralized_shot");
              if (document.getElementById("fl_betrayal_rep") || !mergeOnly) per.betrayalRep = readNum("fl_betrayal_rep");
              if (document.getElementById("fl_betrayal_dir") || !mergeOnly) per.betrayalDir = read("fl_betrayal_dir") || null;
              if (document.getElementById("fl_nost_pick3") || !mergeOnly) {
                const el = document.getElementById("fl_nost_pick3");
                if (el) {
                  const s = String(el.value || "").trim();
                  per.nostPick3 = !s ? [] : s.split(",").map((x) => parseInt(String(x || "").trim(), 10)).filter((x) => Number.isFinite(x)).slice(0, 3);
                } else if (!mergeOnly) per.nostPick3 = [];
              }
              if (document.getElementById("fl_ocean_wake") || !mergeOnly) {
                const el = document.getElementById("fl_ocean_wake");
                if (el) {
                  try {
                    if (String((el.tagName || "")).toUpperCase() === "SELECT" && el.selectedOptions) {
                      per.oceanWake = Array.from(el.selectedOptions).map((o) => parseInt(o.value, 10)).filter((x) => Number.isFinite(x));
                    } else {
                      const s = String(el.value || "").trim();
                      per.oceanWake = !s ? [] : s.split(",").map((x) => parseInt(String(x || "").trim(), 10)).filter((x) => Number.isFinite(x));
                    }
                  } catch { per.oceanWake = []; }
                } else if (!mergeOnly) per.oceanWake = [];
              }
              per.guideInquiryIsMafia = (per.guideInquiryTarget != null && per.guideInquiryTarget !== undefined)
                ? (() => {
                    try {
                      const tp = (appState.draw && appState.draw.players && appState.draw.players[per.guideInquiryTarget]) || {};
                      return typeof detectiveInquiryIsMafia === "function" ? detectiveInquiryIsMafia(tp.roleId || "citizen") : null;
                    } catch { return null; }
                  })()
                : null;

              // Witch (Kabo): when herbalist is bewitched, herbalist poisons self — override stored value.
              if (getDrawScenarioForFlow() === "kabo" && per.witchTarget != null && Number.isFinite(Number(per.witchTarget))) {
                const wt = parseInt(per.witchTarget, 10);
                const tgt = (appState.draw && appState.draw.players && appState.draw.players[wt]) || null;
                const role = (tgt && tgt.roleId) ? tgt.roleId : "citizen";
                if (role === "herbalist") per.herbalistPoison = wt;
              }

              d.nightActionsByNight[nk] = per;
              d.bombCode = (per.bombCode != null && String(per.bombCode)) ? String(per.bombCode) : "";
              d.oceanWake = Array.isArray(per.oceanWake) ? per.oceanWake : [];
              f.draft = d;
              // Persist draft on merge (per-role night) so selections survive navigation and event has data.
              if (mergeOnly) {
                try { saveState(appState); } catch {}
              }
              // Track Armorsmith self-armor consumption (once per game), but allow clearing.
              try {
                if (per.armorsmithArmor !== null && Number.isFinite(Number(per.armorsmithArmor))) {
                  const armorIdx = (() => {
                    for (let i = 0; i < (appState.draw.players || []).length; i++) {
                      const p = appState.draw.players[i];
                      if (p && p.roleId === "armorsmith" && p.alive !== false) return i;
                    }
                    return null;
                  })();
                  if (armorIdx !== null && parseInt(per.armorsmithArmor, 10) === armorIdx) {
                    d.armorsmithSelfUsed = true;
                    d.armorsmithSelfUsedOnNight = Number(nk);
                    f.draft = d;
                  }
                }
              } catch {}

              // Track neutralized shot once-per-game usage, allow clearing on same night.
              try {
                if (per.neutralizedShot) {
                  d.neutralizedShotUsed = true;
                  d.neutralizedShotUsedOnNight = Number(nk);
                } else if (d.neutralizedShotUsedOnNight != null && Number(d.neutralizedShotUsedOnNight) === Number(nk)) {
                  d.neutralizedShotUsed = false;
                  d.neutralizedShotUsedOnNight = null;
                }
                f.draft = d;
              } catch {}

              // Track sodagari once-per-game usage, allow clearing on same night.
              try {
                if (per.sodagariSacrifice !== null || per.sodagariTarget !== null) {
                  d.sodagariUsed = true;
                  d.sodagariUsedOnNight = Number(nk);
                } else if (d.sodagariUsedOnNight != null && Number(d.sodagariUsedOnNight) === Number(nk)) {
                  d.sodagariUsed = false;
                  d.sodagariUsedOnNight = null;
                }
                f.draft = d;
              } catch {}
              // Saul buy "used" is set only by flow-engine when conversion is applied (applyNightSaulBuyFromPayload).
              // Do NOT set d.saulBuyUsed here — having a selection (saulBuyTarget) does not mean "used".
              // That would make Saul buy unavailable as soon as user selects a citizen, preventing Back→change.

              const payload = {
                mafiaShot: per.mafiaShot != null ? per.mafiaShot : null,
                doctorSave: per.doctorSave != null ? per.doctorSave : null,
                detectiveQuery: per.detectiveQuery != null ? per.detectiveQuery : null,
                professionalShot: per.professionalShot != null ? per.professionalShot : null,
                bombTarget: per.bombTarget != null ? per.bombTarget : null,
                bombCode: (per.bombCode != null && String(per.bombCode).trim()) ? String(per.bombCode).trim() : null,
                magicianDisable: per.magicianDisable != null ? per.magicianDisable : null,
                zodiacShot: per.zodiacShot != null ? per.zodiacShot : null,
                oceanWake: (Array.isArray(per.oceanWake) && per.oceanWake.length) ? per.oceanWake : null,
                kaneMark: per.kaneMark != null ? per.kaneMark : null,
                constantineRevive: per.constantineRevive != null ? per.constantineRevive : null,
                nostPick3: (Array.isArray(per.nostPick3) && per.nostPick3.length) ? per.nostPick3 : null,
                heirPick: per.heirPick != null ? per.heirPick : null,
                herbalistPoison: per.herbalistPoison != null ? per.herbalistPoison : null,
                herbalistAntidote: per.herbalistAntidote != null ? per.herbalistAntidote : null,
                armorsmithArmor: per.armorsmithArmor != null ? per.armorsmithArmor : null,
                lecterSave: per.lecterSave != null ? per.lecterSave : null,
                jokerTarget: per.jokerTarget != null ? per.jokerTarget : null,
                swindlerTarget: per.swindlerTarget != null ? per.swindlerTarget : null,
                researcherLink: per.researcherLink != null ? per.researcherLink : null,
                natashaTarget: per.natashaTarget != null ? per.natashaTarget : null,
                sniperShot: per.sniperShot != null ? per.sniperShot : null,
                negotiatorTarget: per.negotiatorTarget != null ? per.negotiatorTarget : null,
                kadkhodaTarget: per.kadkhodaTarget != null ? per.kadkhodaTarget : null,
                hackerBlock: per.hackerBlock != null ? per.hackerBlock : null,
                guideTarget: per.guideTarget != null ? per.guideTarget : null,
                guideInquiryTarget: per.guideInquiryTarget != null ? per.guideInquiryTarget : null,
                guideInquiryIsMafia: per.guideInquiryIsMafia,
                bodyguardProtect: per.bodyguardProtect != null ? per.bodyguardProtect : null,
                minemakerTarget: per.minemakerTarget != null ? per.minemakerTarget : null,
                lawyerTarget: per.lawyerTarget != null ? per.lawyerTarget : null,
                natoTarget: per.natoTarget != null ? per.natoTarget : null,
                natoRoleGuess: (per.natoRoleGuess != null && String(per.natoRoleGuess)) ? String(per.natoRoleGuess) : null,
                reporterTarget: per.reporterTarget != null ? per.reporterTarget : null,
                investigatorT1: per.investigatorT1 != null ? per.investigatorT1 : null,
                investigatorT2: per.investigatorT2 != null ? per.investigatorT2 : null,
                sodagariSacrifice: per.sodagariSacrifice != null ? per.sodagariSacrifice : null,
                sodagariTarget: per.sodagariTarget != null ? per.sodagariTarget : null,
                godfatherAction: (per.godfatherAction != null && String(per.godfatherAction)) ? String(per.godfatherAction) : null,
                witchTarget: per.witchTarget != null ? per.witchTarget : null,
                saulBuyTarget: per.saulBuyTarget != null ? per.saulBuyTarget : null,
                sixthSenseTarget: per.sixthSenseTarget != null ? per.sixthSenseTarget : null,
                sixthSenseRole: (per.sixthSenseRole != null && String(per.sixthSenseRole).trim()) ? String(per.sixthSenseRole).trim() : null,
                matadorDisable: per.matadorDisable != null ? per.matadorDisable : null,
                soldierTarget: per.soldierTarget != null ? per.soldierTarget : null,
                soldierGunShot: per.soldierGunShot != null ? per.soldierGunShot : null,
                neutralizedShot: per.neutralizedShot === true,
                betrayalRep: per.betrayalRep != null ? per.betrayalRep : null,
                betrayalDir: per.betrayalDir != null ? per.betrayalDir : null,
              };
              // Witch (Kabo): ability reflects to target — override payload so target's ability applies to themselves.
              if (getDrawScenarioForFlow() === "kabo" && payload.witchTarget != null && Number.isFinite(Number(payload.witchTarget))) {
                const wt = parseInt(payload.witchTarget, 10);
                const tgt = (appState.draw && appState.draw.players && appState.draw.players[wt]) || null;
                const role = (tgt && tgt.roleId) ? tgt.roleId : "citizen";
                if (role === "detective") payload.detectiveQuery = wt;
                else if (role === "herbalist") payload.herbalistPoison = wt;
                else if (role === "armorsmith") payload.armorsmithArmor = wt;
              }
              // Clear handcuffed or disabled (Magician/Matador) player's actions
              try {
                const draw = appState.draw;
                const scenarioSave = typeof getDrawScenarioForFlow === "function" ? getDrawScenarioForFlow() : "";
                const handcuffedIdx = (d.handcuffedByDay && d.handcuffedByDay[nk] != null) ? parseInt(d.handcuffedByDay[nk], 10) : null;
                let disabledIdx = null;
                if (scenarioSave === "pedarkhande") {
                  if (payload.matadorDisable != null && payload.matadorDisable !== undefined && Number.isFinite(Number(payload.matadorDisable))) {
                    disabledIdx = parseInt(payload.matadorDisable, 10);
                  } else {
                    const prevNightKey = String(Math.max(0, Number(nk) - 1));
                    const prevNight = (d.nightActionsByNight && d.nightActionsByNight[prevNightKey]) ? d.nightActionsByNight[prevNightKey] : null;
                    const prevMatadorV = prevNight && prevNight.matadorDisable != null && Number.isFinite(Number(prevNight.matadorDisable))
                      ? parseInt(prevNight.matadorDisable, 10) : null;
                    if (prevMatadorV !== null) disabledIdx = prevMatadorV;
                  }
                }
                if (disabledIdx === null && payload.magicianDisable != null && payload.magicianDisable !== undefined && Number.isFinite(Number(payload.magicianDisable))) {
                  disabledIdx = parseInt(payload.magicianDisable, 10);
                }
                const blockedIdx = Number.isFinite(handcuffedIdx) ? handcuffedIdx : (Number.isFinite(disabledIdx) ? disabledIdx : null);
                if (blockedIdx !== null && draw && draw.players) {
                  const findRoleIdx = (roleIds) => {
                    const ids = Array.isArray(roleIds) ? roleIds : [roleIds];
                    for (let i = 0; i < (draw.players || []).length; i++) {
                      if (draw.players[i] && ids.includes(draw.players[i].roleId)) return i;
                    }
                    return null;
                  };
                  const roleToFields = {
                    doctor: ["doctorSave"], watson: ["doctorSave"], doctorLecter: ["lecterSave"],
                    detective: ["detectiveQuery"], professional: ["professionalShot"], leon: ["professionalShot"],
                    bomber: ["bombTarget", "bombCode"], zodiac: ["zodiacShot"], ocean: ["oceanWake"],
                    gunslinger: ["gunGiveTo", "gunType"], magician: ["magicianDisable"],
                    constantine: ["constantineRevive"], citizenKane: ["kaneMark"], heir: ["heirPick"],
                    herbalist: ["herbalistPoison", "herbalistAntidote"], armorsmith: ["armorsmithArmor"],
                    jokerMafia: ["jokerTarget"], swindler: ["swindlerTarget"], researcher: ["researcherLink"],
                    natasha: ["natashaTarget"], sniper: ["sniperShot"], negotiator: ["negotiatorTarget"],
                    kadkhoda: ["kadkhodaTarget"], hacker: ["hackerBlock"], guide: ["guideTarget", "guideInquiryTarget", "guideInquiryIsMafia"],
                    bodyguard: ["bodyguardProtect"], minemaker: ["minemakerTarget"], lawyer: ["lawyerTarget"],
                    nato: ["natoTarget", "natoRoleGuess"], reporter: ["reporterTarget"],
                    investigator: ["investigatorT1", "investigatorT2"], sodagari: ["sodagariSacrifice", "sodagariTarget"],
                    godfather: ["godfatherAction", "mafiaShot", "saulBuyTarget", "sixthSenseTarget", "sixthSenseRole"], witch: ["witchTarget"], matador: ["matadorDisable"],
                    soldier: ["soldierTarget", "soldierGunShot"],
                  };
                  for (const [roleKey, fields] of Object.entries(roleToFields)) {
                    const rid = roleKey === "godfather" ? ["godfather", "mafiaBoss"] : [roleKey];
                    const actorIdx = findRoleIdx(rid);
                    if (actorIdx === blockedIdx) {
                      for (const field of fields) {
                        if (payload[field] !== undefined) payload[field] = null;
                      }
                    }
                  }
                }
              } catch {}
              if (!mergeOnly) addFlowEvent("night_actions", payload);

              // NOTE: Bomb is planted at NIGHT, but becomes "active" on the NEXT day.
              // So we DO NOT toggle `f.bombActive` here. It will be set during the night→day transition.

              // Apply mafia shot immediately (so closing the UI still shows correct alive/dead).
              // IMPORTANT: Night kills are resolved at the END of the night (night -> day),
              // so being shot does NOT prevent a role from acting that same night.
              // (Disables like Magician/Matador can still block actions that night.)

              // Detective result (for display)
              try {
                const key = String(f.day || 1);
                const d = f.draft || {};
                if (!d.detectiveResultByNight || typeof d.detectiveResultByNight !== "object") d.detectiveResultByNight = {};

                if (payload.detectiveQuery !== null && appState.draw && appState.draw.players && appState.draw.players[payload.detectiveQuery]) {
                  const tIdx = payload.detectiveQuery;
                  const tr = (appState.draw.players[tIdx] && appState.draw.players[tIdx].roleId) ? appState.draw.players[tIdx].roleId : "citizen";
                  // If detective is disabled by Magician this night, they always receive a false (negative) result.
                  const detPlayerIdx2 = (() => {
                    try {
                      for (let i = 0; i < (appState.draw.players || []).length; i++) {
                        const p = appState.draw.players[i];
                        if (p && p.roleId === "detective") return i;
                      }
                    } catch {}
                    return null;
                  })();
                  const detIsDisabled = (
                    payload.magicianDisable !== null && payload.magicianDisable !== undefined &&
                    Number.isFinite(Number(payload.magicianDisable)) &&
                    detPlayerIdx2 !== null && parseInt(payload.magicianDisable, 10) === detPlayerIdx2
                  );
                  // Check if JokerMafia is flipping this target's result tonight.
                  const jokerFlipped = (
                    payload.jokerTarget !== null && payload.jokerTarget !== undefined &&
                    Number.isFinite(Number(payload.jokerTarget)) &&
                    parseInt(payload.jokerTarget, 10) === tIdx
                  );
                  // Swindler targets the detective player — if it guessed correctly, ALL of
                  // the detective's results that night are forced to negative (citizen).
                  const swindlerHit = (
                    payload.swindlerTarget !== null && payload.swindlerTarget !== undefined &&
                    Number.isFinite(Number(payload.swindlerTarget)) &&
                    detPlayerIdx2 !== null &&
                    parseInt(payload.swindlerTarget, 10) === detPlayerIdx2
                  );
                  let isMafia = detIsDisabled ? false : detectiveInquiryIsMafia(tr);
                  if (swindlerHit) isMafia = false; // swindler makes result appear as citizen
                  if (jokerFlipped) isMafia = !isMafia; // joker flips the (possibly already swindled) result
                  // Track JokerMafia usage (max 2 per game)
                  try {
                    if (!d.jokerUsed || !Array.isArray(d.jokerUsed)) d.jokerUsed = [];
                    const nightNum = f.day || 1;
                    if (jokerFlipped) {
                      if (!d.jokerUsed.includes(nightNum)) d.jokerUsed.push(nightNum);
                    } else {
                      // User cleared the joker target — remove this night from used list
                      d.jokerUsed = d.jokerUsed.filter((n) => Number(n) !== nightNum);
                    }
                    f.draft = d;
                  } catch {}
                  d.detectiveResultByNight[key] = { target: tIdx, isMafia, at: Date.now() };
                  f.draft = d;
                  addFlowEvent("detective_query", { target: tIdx, isMafia });

                  // Update UI immediately (no full re-render needed).
                  try {
                    const el = document.getElementById("fl_det_result");
                    if (el) {
                      const thumb = isMafia ? "👍" : "👎";
                      const label = (appLang === "fa") ? (isMafia ? "مافیا" : "شهروند") : (isMafia ? "Mafia" : "Citizen");
                      const pre = (appLang === "fa") ? "نتیجه استعلام: " : "Result: ";
                      el.style.display = "";
                      el.textContent = `${pre}${thumb} ${label}`;
                    }
                  } catch {}
                } else {
                  // If cleared, hide/remove the result for this night so we don't show stale values.
                  d.detectiveResultByNight[key] = null;
                  f.draft = d;
                  try {
                    const el = document.getElementById("fl_det_result");
                    if (el) { el.style.display = "none"; el.textContent = ""; }
                  } catch {}
                  try { addFlowEvent("detective_query", { target: null, isMafia: null, cleared: true }); } catch {}
                }
              } catch {}

              // Nostradamus result (intro night only): count how many of the picks are actually Mafia.
              try {
                if ((f.day || 1) === 1) {
                  const nostKey = String(f.day || 1);
                  const nd = f.draft || {};
                  if (!nd.nostResultByNight || typeof nd.nostResultByNight !== "object") nd.nostResultByNight = {};
                  const picks = Array.isArray(payload.nostPick3) ? payload.nostPick3 : [];
                  if (picks.length > 0) {
                    let mafiaCount = 0;
                    for (const idx of picks) {
                      const p = appState.draw && appState.draw.players && appState.draw.players[idx];
                      const rid = (p && p.roleId) ? p.roleId : "citizen";
                      // Same rule as detective inquiry: Godfather/Don/MafiaBoss/Alcapone appear as city.
                      if (rid === "godfather" || rid === "mafiaBoss" || rid === "danMafia" || rid === "alcapone") continue;
                      const teamFa = (roles[rid] && roles[rid].teamFa) ? roles[rid].teamFa : "شهر";
                      if (teamFa === "مافیا") mafiaCount++;
                    }
                    nd.nostResultByNight[nostKey] = { picks, mafiaCount, at: Date.now() };
                    f.draft = nd;
                    try {
                      const el = document.getElementById("fl_nost_result");
                      if (el) {
                        const n = picks.length;
                        const mLabel = appLang === "fa"
                          ? `نتیجه: ${fmtNum(mafiaCount)} نفر از این ${fmtNum(n)} نفر مافیا هستند.`
                          : `Result: ${mafiaCount} of these ${n} are Mafia.`;
                        el.style.display = "";
                        el.textContent = mLabel;
                      }
                    } catch {}
                  } else {
                    nd.nostResultByNight[nostKey] = null;
                    f.draft = nd;
                    try {
                      const el = document.getElementById("fl_nost_result");
                      if (el) { el.style.display = "none"; el.textContent = ""; }
                    } catch {}
                  }
                }
              } catch {}

              // Track NATO role-guess usage per-night so back-navigation keeps the night editable.
              try {
                const gd2 = f.draft || {};
                const _natoNight = f.day || 1;
                if (natoTarget !== "" && natoRoleGuess !== "") {
                  gd2.natoUsedNight = _natoNight;
                  f.draft = gd2;
                } else if ((gd2.natoUsedNight != null) && Number(gd2.natoUsedNight) === _natoNight) {
                  // User cleared the guess on the same night it was set — unset it.
                  gd2.natoUsedNight = null;
                  f.draft = gd2;
                }
              } catch {}

              // Track Minemaker mine placement (once per game).
              try {
                const gd3 = f.draft || {};
                if (minemakerTarget !== "") {
                  gd3.minemakerUsed = true;
                  gd3.minemakerUsedOnNight = Number(nk);
                  gd3.minemakerMine = parseInt(minemakerTarget, 10);
                  f.draft = gd3;
                } else if (gd3.minemakerUsedOnNight != null && Number(gd3.minemakerUsedOnNight) === Number(nk)) {
                  // User cleared on the same night it was set — unset it.
                  gd3.minemakerUsed = false;
                  gd3.minemakerUsedOnNight = null;
                  gd3.minemakerMine = null;
                  f.draft = gd3;
                }
              } catch {}

              // Track Lawyer protection usage (once per game).
              try {
                const gd4 = f.draft || {};
                if (lawyerTarget !== "") {
                  gd4.lawyerUsed = true;
                  gd4.lawyerUsedOnNight = Number(nk);
                  f.draft = gd4;
                } else if (gd4.lawyerUsedOnNight != null && Number(gd4.lawyerUsedOnNight) === Number(nk)) {
                  gd4.lawyerUsed = false;
                  gd4.lawyerUsedOnNight = null;
                  f.draft = gd4;
                }
              } catch {}

              // Reporter inquiry result — thumbs up if the chosen player was ever negotiated.
              try {
                const reporterKey = String(f.day || 1);
                const gdr = f.draft || {};
                if (!gdr.reporterResultByNight || typeof gdr.reporterResultByNight !== "object") gdr.reporterResultByNight = {};
                if (reporterTarget !== "" && appState.draw && appState.draw.players && appState.draw.players[parseInt(reporterTarget, 10)]) {
                  const tIdx = parseInt(reporterTarget, 10);
                  // Check previous nights (already applied at night→day transition).
                  const negByDay = (gdr.nightNegotiatorAppliedByDay && typeof gdr.nightNegotiatorAppliedByDay === "object") ? gdr.nightNegotiatorAppliedByDay : {};
                  let wasNegotiated = false;
                  for (const dk of Object.keys(negByDay)) {
                    const rec = negByDay[dk];
                    if (rec && rec.succeeded === true && Number.isFinite(Number(rec.converted)) && parseInt(rec.converted, 10) === tIdx) {
                      wasNegotiated = true;
                      break;
                    }
                  }
                  // Also check the current night's payload directly (not yet applied to draft).
                  if (!wasNegotiated && payload.negotiatorTarget !== null && payload.negotiatorTarget !== undefined &&
                      Number.isFinite(Number(payload.negotiatorTarget)) && parseInt(payload.negotiatorTarget, 10) === tIdx) {
                    const p = appState.draw.players[tIdx];
                    const roleId = (p && p.roleId) ? p.roleId : "citizen";
                    wasNegotiated = (roleId === "citizen") || (roleId === "armored" && !gdr.armoredVoteUsed);
                  }
                  gdr.reporterResultByNight[reporterKey] = { target: tIdx, wasNegotiated, at: Date.now() };
                  gdr.reporterUsed = true;
                  f.draft = gdr;
                  try {
                    const el = document.getElementById("fl_reporter_result");
                    if (el) {
                      const resultText = wasNegotiated
                        ? (appLang === "fa" ? "نتیجه: 👍 این بازیکن مذاکره شده." : "Result: 👍 This player was negotiated.")
                        : (appLang === "fa" ? "نتیجه: 👎 این بازیکن مذاکره نشده." : "Result: 👎 This player was not negotiated.");
                      el.style.display = "";
                      el.textContent = resultText;
                    }
                  } catch {}
                } else {
                  gdr.reporterResultByNight[reporterKey] = null;
                  f.draft = gdr;
                  try {
                    const el = document.getElementById("fl_reporter_result");
                    if (el) { el.style.display = "none"; el.textContent = ""; }
                  } catch {}
                }
              } catch {}

              // Guide: store meta-result (was guide's target mafia?) for status timeline.
              try {
                const guideKey = String(f.day || 1);
                const gd5 = f.draft || {};
                if (!gd5.guideResultByNight || typeof gd5.guideResultByNight !== "object") gd5.guideResultByNight = {};
                if (guideTarget !== "" && appState.draw && appState.draw.players && appState.draw.players[parseInt(guideTarget, 10)]) {
                  const tIdx = parseInt(guideTarget, 10);
                  const tr = (appState.draw.players[tIdx] && appState.draw.players[tIdx].roleId) ? appState.draw.players[tIdx].roleId : "citizen";
                  const isMafia = detectiveInquiryIsMafia(tr);
                  gd5.guideResultByNight[guideKey] = { target: tIdx, isMafia, at: Date.now() };
                } else {
                  gd5.guideResultByNight[guideKey] = null;
                }
                f.draft = gd5;
              } catch {}
              // Guided player's inquiry result — update inline display.
              try {
                const inqEl = document.getElementById("fl_guide_inquiry_result");
                if (inqEl) {
                  if (per.guideInquiryTarget !== null && per.guideInquiryIsMafia !== null) {
                    const isMaf = per.guideInquiryIsMafia;
                    inqEl.textContent = isMaf
                      ? (appLang === "fa" ? "✓ مافیا" : "✓ Mafia")
                      : (appLang === "fa" ? "✗ شهروند" : "✗ Citizen");
                    inqEl.style.color = isMaf ? "rgba(255,100,80,1)" : "rgba(60,210,160,1)";
                    inqEl.style.display = "";
                  } else {
                    inqEl.style.display = "none";
                    inqEl.textContent = "";
                  }
                }
              } catch {}

              saveState(appState);
              return true;
            } catch {
              return false;
            }
          };
          // Let closing the tool modal auto-save Flow inputs.
          try {
            window.__flowOnClose = () => {
              try {
                // Night actions: use mergeOnly=true so we only update fields for controls that exist
                // in the current step's DOM — otherwise we'd overwrite other steps' data with null.
                snapshotNightActionsFromUI(true);
              } catch {}
              try {
                // Day elimination votes
                if (document.querySelector('select[id^="fl_elim_"]')) {
                  snapshotElimVotesFromUI();
                }
              } catch {}
              // Persist draft to localStorage so selections survive tab close / refresh.
              try { saveState(appState); } catch {}
            };
          } catch {}
          const commitElimFromUI = () => {
            try {
              const d = f.draft || {};
              if (!d.elimVotesByDay || typeof d.elimVotesByDay !== "object") d.elimVotesByDay = {};
              const candIdxs = Array.isArray(d.elimCandidatesByDay && d.elimCandidatesByDay[f.day]) ? d.elimCandidatesByDay[f.day] : [];
              // No defendants today => allow advancing.
              if (!candIdxs.length) {
                try { addFlowEvent("day_elim", { counts: {}, best: 0, leaders: [] }); } catch {}
                try { addFlowEvent("day_elim_out", { out: null }); } catch {}
                try { applyDayElimFromPayload(f, { out: null }); } catch {}
                try { saveState(appState); } catch {}
                return true;
              }

              const maxVotes = Math.max(0, aliveIdxs.length - 1);
              const counts = {};
              let best = 0;
              for (const idx of candIdxs) {
                const el = document.getElementById(`fl_elim_${idx}`);
                const raw = el ? el.value : "0";
                const n = Math.max(0, Math.min(maxVotes, Math.floor(Number(raw || 0))));
                counts[idx] = Number.isFinite(n) ? n : 0;
                best = Math.max(best, counts[idx] || 0);
              }
              d.elimVotesByDay[f.day] = counts;

              // Single defendant: require threshold to be voted out.
              if (candIdxs.length === 1) {
                const voters = aliveIdxs.length;
                const eligibleVoters = Math.max(0, voters - 1);
                const threshold = getDefenseThreshold(eligibleVoters);
                const only = candIdxs[0];
                const v = counts[only] || 0;
                const out = (v >= threshold) ? only : null;
                d.elimLeadersByDay = (d.elimLeadersByDay && typeof d.elimLeadersByDay === "object") ? d.elimLeadersByDay : {};
                d.elimLeadersByDay[f.day] = (best > 0) ? [only] : [];
                d.elimPickedByDay = (d.elimPickedByDay && typeof d.elimPickedByDay === "object") ? d.elimPickedByDay : {};
                d.elimPickedByDay[f.day] = out;
                f.draft = d;
                addFlowEvent("day_elim", { counts, best, leaders: (best > 0) ? [only] : [] });
                addFlowEvent("day_elim_out", { out, auto: true, single: true });
                try { applyDayElimFromPayload(f, { out }); } catch {}
                try { renderCast(); } catch {}
                try { if (typeof renderNameGrid === "function") renderNameGrid(); } catch {}
                saveState(appState);
                return true;
              }

              const leaders = Object.keys(counts)
                .map((k) => ({ idx: parseInt(k, 10), v: counts[k] }))
                .filter((x) => Number.isFinite(x.idx))
                .sort((a, b) => (b.v - a.v) || (a.idx - b.idx));
              const top = leaders.filter((x) => x.v === best && best > 0);
              d.elimLeadersByDay = (d.elimLeadersByDay && typeof d.elimLeadersByDay === "object") ? d.elimLeadersByDay : {};
              d.elimLeadersByDay[f.day] = top.map((x) => x.idx);
              d.elimPickedByDay = (d.elimPickedByDay && typeof d.elimPickedByDay === "object") ? d.elimPickedByDay : {};
              const prevPicked = (d.elimPickedByDay && d.elimPickedByDay[f.day] !== undefined) ? d.elimPickedByDay[f.day] : null;
              const prevPickedIdxRaw = Number.isFinite(Number(prevPicked)) ? parseInt(prevPicked, 10) : null;
              const prevPickedIdx = (prevPickedIdxRaw !== null && Number.isFinite(prevPickedIdxRaw)) ? prevPickedIdxRaw : (() => {
                try {
                  const ev = (f.events || []).slice().reverse().find((e) => e && e.kind === "day_elim_draw" && Number(e.day) === Number(f.day));
                  const p = ev && ev.data ? ev.data.picked : null;
                  const n = parseInt(String(p ?? ""), 10);
                  return Number.isFinite(n) ? n : null;
                } catch {
                  return null;
                }
              })();
              const keptPicked = (top.length === 1)
                ? top[0].idx
                : (top.length > 1 && prevPickedIdx !== null && top.some((x) => x.idx === prevPickedIdx))
                  ? prevPickedIdx
                  : null;
              d.elimPickedByDay[f.day] = keptPicked;
              f.draft = d;

              addFlowEvent("day_elim", { counts, best, leaders: top.map((x) => x.idx) });
              saveState(appState);

              // No one is eliminated (e.g., scenario allows no-out, or votes are all 0): allow advancing.
              if (!(best > 0) || !top.length) {
                try { addFlowEvent("day_elim_out", { out: null }); } catch {}
                try { applyDayElimFromPayload(f, { out: null }); } catch {}
                return true;
              }

              // Single winner: apply elimination and allow advancing.
              if (top.length === 1 && best > 0) {
                try { applyDayElimFromPayload(f, { out: top[0].idx }); } catch {}
                addFlowEvent("day_elim_out", { out: top[0].idx, auto: true });
                try { renderCast(); } catch {}
                try { if (typeof renderNameGrid === "function") renderNameGrid(); } catch {}
                saveState(appState);
                return true;
              }

              // Tie: if Draw already picked someone, allow advancing; otherwise require Draw.
              if (top.length > 1 && keptPicked !== null) {
                try { applyDayElimFromPayload(f, { out: keptPicked }); } catch {}
                addFlowEvent("day_elim_out", { out: keptPicked, draw: true, via: "next" });
                try { renderCast(); } catch {}
                try { if (typeof renderNameGrid === "function") renderNameGrid(); } catch {}
                saveState(appState);
                return true;
              }

              showFlowTool();
              return false;
            } catch {
              return false;
            }
          };

          const flNextEl = document.getElementById("fl_next");
          if (flNextEl) flNextEl.onclick = () => {
            // Nostradamus choose side: validate selection before advancing
            if (cur && cur.id === "nostradamus_choose_side") {
              try {
                const d = f.draft || {};
                const nostRes = (d.nostResultByNight && d.nostResultByNight["0"]) ? d.nostResultByNight["0"] : null;
                const mafiaCount = (nostRes && nostRes.mafiaCount !== undefined && nostRes.mafiaCount !== null) ? Number(nostRes.mafiaCount) : 0;
                const forcedMafia = mafiaCount >= 2;
                let val = (d.nostradamusChosenSide === "citizen" || d.nostradamusChosenSide === "mafia") ? d.nostradamusChosenSide : null;
                if (forcedMafia && !val) {
                  d.nostradamusChosenSide = "mafia";
                  f.draft = d;
                  saveState(appState);
                  val = "mafia";
                }
                if (d.nostradamusChooseSideError) {
                  delete d.nostradamusChooseSideError;
                  f.draft = d;
                  saveState(appState);
                }
              } catch {}
              nextFlowStep();
              return;
            }
            const nightSteps = getFlowSteps(f) || [];
            if (cur && cur.id === "night_poisoned_player") {
              // Values are already in draft from card +/- clicks; no DOM read needed.
              nextFlowStep();
              return;
            }
            if (cur && cur.id === "night_herbalist_antidote") {
              // Values are already in draft from card clicks; no DOM read needed.
              nextFlowStep();
              return;
            }
            if (cur && cur.id === "night_poison_result") {
              nextFlowStep();
              return;
            }
            const isPerRoleNightStep = cur && cur.id && (String(cur.id).startsWith("night_step_") || (f.phase === "night" && nightSteps.length > 1));
            if (cur && (cur.id === "night_run" || isPerRoleNightStep)) {
              if (isPerRoleNightStep) {
                // Per-role night: merge current step's form into draft, then on last step emit night_actions and advance.
                try {
                  if (typeof snapshotNightActionsFromUI === "function") {
                    snapshotNightActionsFromUI(true);
                  }
                  // Persist draft after merge so nightActionsByNight is saved before phase transition.
                  try { saveState(appState); } catch {}
                  const isLastNightStep = nightSteps.length > 0 && (f.step || 0) >= nightSteps.length - 1;
                  if (isLastNightStep) {
                    try {
                    const nk = String(f.day || 1);
                    const d = f.draft || {};
                    const per = (d.nightActionsByNight && d.nightActionsByNight[nk] && typeof d.nightActionsByNight[nk] === "object")
                      ? d.nightActionsByNight[nk] : {};
                    const guideInquiryIsMafia = (per.guideInquiryTarget != null && per.guideInquiryTarget !== undefined)
                      ? (() => {
                          try {
                            const tp = (appState.draw && appState.draw.players && appState.draw.players[per.guideInquiryTarget]) || {};
                            return typeof detectiveInquiryIsMafia === "function"
                              ? detectiveInquiryIsMafia(tp.roleId || "citizen") : null;
                          } catch { return null; }
                        })()
                      : null;
                    const payload = {
                      mafiaShot: per.mafiaShot != null ? per.mafiaShot : null,
                      doctorSave: per.doctorSave != null ? per.doctorSave : null,
                      detectiveQuery: per.detectiveQuery != null ? per.detectiveQuery : null,
                      professionalShot: per.professionalShot != null ? per.professionalShot : null,
                      bombTarget: per.bombTarget != null ? per.bombTarget : null,
                      bombCode: (per.bombCode != null && String(per.bombCode).trim()) ? String(per.bombCode).trim() : null,
                      magicianDisable: per.magicianDisable != null ? per.magicianDisable : null,
                      zodiacShot: per.zodiacShot != null ? per.zodiacShot : null,
                      oceanWake: (Array.isArray(per.oceanWake) && per.oceanWake.length) ? per.oceanWake.slice() : null,
                      kaneMark: per.kaneMark != null ? per.kaneMark : null,
                      constantineRevive: per.constantineRevive != null ? per.constantineRevive : null,
                      nostPick3: (Array.isArray(per.nostPick3) && per.nostPick3.length) ? per.nostPick3 : null,
                      heirPick: per.heirPick != null ? per.heirPick : null,
                      herbalistPoison: per.herbalistPoison != null ? per.herbalistPoison : null,
                      herbalistAntidote: per.herbalistAntidote != null ? per.herbalistAntidote : null,
                      armorsmithArmor: per.armorsmithArmor != null ? per.armorsmithArmor : null,
                      lecterSave: per.lecterSave != null ? per.lecterSave : null,
                      jokerTarget: per.jokerTarget != null ? per.jokerTarget : null,
                      swindlerTarget: per.swindlerTarget != null ? per.swindlerTarget : null,
                      researcherLink: per.researcherLink != null ? per.researcherLink : null,
                      natashaTarget: per.natashaTarget != null ? per.natashaTarget : null,
                      sniperShot: per.sniperShot != null ? per.sniperShot : null,
                      negotiatorTarget: per.negotiatorTarget != null ? per.negotiatorTarget : null,
                      kadkhodaTarget: per.kadkhodaTarget != null ? per.kadkhodaTarget : null,
                      hackerBlock: per.hackerBlock != null ? per.hackerBlock : null,
                      guideTarget: per.guideTarget != null ? per.guideTarget : null,
                      guideInquiryTarget: per.guideInquiryTarget != null ? per.guideInquiryTarget : null,
                      guideInquiryIsMafia: guideInquiryIsMafia,
                      bodyguardProtect: per.bodyguardProtect != null ? per.bodyguardProtect : null,
                      minemakerTarget: per.minemakerTarget != null ? per.minemakerTarget : null,
                      lawyerTarget: per.lawyerTarget != null ? per.lawyerTarget : null,
                      natoTarget: per.natoTarget != null ? per.natoTarget : null,
                      natoRoleGuess: (per.natoRoleGuess != null && String(per.natoRoleGuess)) ? String(per.natoRoleGuess) : null,
                      reporterTarget: per.reporterTarget != null ? per.reporterTarget : null,
                      investigatorT1: per.investigatorT1 != null ? per.investigatorT1 : null,
                      investigatorT2: per.investigatorT2 != null ? per.investigatorT2 : null,
                      sodagariSacrifice: per.sodagariSacrifice != null ? per.sodagariSacrifice : null,
                      sodagariTarget: per.sodagariTarget != null ? per.sodagariTarget : null,
                      godfatherAction: (per.godfatherAction != null && String(per.godfatherAction)) ? String(per.godfatherAction) : null,
                      witchTarget: per.witchTarget != null ? per.witchTarget : null,
                      saulBuyTarget: per.saulBuyTarget != null ? per.saulBuyTarget : null,
                      kaboYakoozaTarget: per.kaboYakoozaTarget != null ? per.kaboYakoozaTarget : null,
                      executionerTarget: per.executionerTarget != null ? per.executionerTarget : null,
                      executionerRoleGuess: (per.executionerRoleGuess != null && String(per.executionerRoleGuess).trim()) ? String(per.executionerRoleGuess).trim() : null,
                      sixthSenseTarget: per.sixthSenseTarget != null ? per.sixthSenseTarget : null,
                      sixthSenseRole: (per.sixthSenseRole != null && String(per.sixthSenseRole).trim()) ? String(per.sixthSenseRole).trim() : null,
                      matadorDisable: per.matadorDisable != null ? per.matadorDisable : null,
                      soldierTarget: per.soldierTarget != null ? per.soldierTarget : null,
                      soldierGunShot: per.soldierGunShot != null ? per.soldierGunShot : null,
                      neutralizedShot: per.neutralizedShot === true,
                      betrayalRep: per.betrayalRep != null ? per.betrayalRep : null,
                      betrayalDir: per.betrayalDir != null ? per.betrayalDir : null,
                    };
                    addFlowEvent("night_actions", payload);
                    } catch (e) {
                      try { console.warn("night step payload", e); } catch {}
                    }
                  }
                } catch (e) {
                  try { console.warn("night step save", e); } catch {}
                }
                nextFlowStep();
                return;
              }
              // Single-page night_run: snapshot selections before advancing so they persist.
              try {
                if (typeof snapshotNightActionsFromUI === "function") {
                  snapshotNightActionsFromUI(true);
                }
                try { saveState(appState); } catch {}
              } catch {}
              nextFlowStep();
              return;
            }
            if (cur && cur.id === "day_bomb") {
              try { applyBombResultFromForm(); } catch {}
              try {
                const stepsAfter = getFlowSteps(f);
                const voteIdx = stepsAfter.findIndex((s) => s && s.id === "day_vote");
                f.step = (voteIdx >= 0) ? voteIdx : 0;
                saveState(appState);
              } catch {}
              showFlowTool();
              return;
            }
            if (cur && cur.id === "kabo_suspect_select") {
              nextFlowStep();
              return;
            }
            if (cur && cur.id === "day_vote") {
              commitVoteFromUI();
              nextFlowStep();
              return;
            }
            if (cur && cur.id === "day_guns") {
              try { applyBombResultFromForm(); } catch {}
              nextFlowStep();
              return;
            }
            if (cur && cur.id === "day_elim") {
              try { commitElimFromUI(); } catch {}
              nextFlowStep();
              return;
            }
            // Deferred-apply steps: apply deaths on Next, not on selection change.
            if (cur && cur.id === "bazras_forced_vote") {
              try {
                const d2 = f.draft || {};
                const dayKey = String(f.day || 1);
                const prevNK = String(Math.max(0, (f.day || 1) - 1));
                const invT = d2.investigatorTargetsByNight && d2.investigatorTargetsByNight[prevNK];
                const fvT1 = invT && invT.t1 != null ? invT.t1 : null;
                const fvT2 = invT && invT.t2 != null ? invT.t2 : null;
                const rec2 = (d2.bazrasInterrogationByDay && d2.bazrasInterrogationByDay[dayKey]) || {};
                const votes = rec2.votes || {};
                const nv1 = Math.max(0, parseInt(votes[fvT1] || 0, 10));
                const nv2 = Math.max(0, parseInt(votes[fvT2] || 0, 10));
                const hasV = nv1 > 0 || nv2 > 0;
                const outcome = !hasV ? null : (nv1 > nv2 ? String(fvT1) : nv2 > nv1 ? String(fvT2) : "tie");
                applyBazrasInterrogationFromPayload(f, { decision: rec2.decision || null, outcome });
                renderCast();
              } catch {}
              nextFlowStep();
              return;
            }
            if (cur && cur.id === "namayande_vote") {
              try {
                const d2 = f.draft || {};
                const dayKey = String(f.day || 1);
                const pick = (d2.namayandePick && d2.namayandePick[dayKey] != null) ? d2.namayandePick[dayKey] : null;
                applyDayElimFromPayload(f, { out: pick });
                renderCast();
              } catch {}
              nextFlowStep();
              return;
            }
            if (cur && cur.id === "kabo_shoot") {
              try {
                const d2 = f.draft || {};
                const dayKey = String(f.day || 1);
                const realGun = d2.kaboGunByDay && d2.kaboGunByDay[dayKey];
                const savedShoot = d2.kaboShootByDay && d2.kaboShootByDay[dayKey];
                const realTarget = (savedShoot && realGun) ? (realGun === "gun1" ? savedShoot.gun1 : savedShoot.gun2) : null;
                applyDayElimFromPayload(f, { out: realTarget != null ? realTarget : null, kaboShot: realTarget != null });
                if (realTarget !== null && realTarget !== undefined) {
                  try { addFlowEvent("day_elim_out", { out: realTarget, kaboShot: true }); } catch {}
                }
                renderCast();
              } catch {}
              nextFlowStep();
              return;
            }
            nextFlowStep();
          };

          // Auto-save: persist changes immediately when user selects values.
          if (cur && (cur.id === "day_bomb" || cur.id === "day_guns")) {
            try {
              const saveBombDraft = () => {
                try {
                  const d = f.draft || {};
                  if (!d.bombResolveByDay || typeof d.bombResolveByDay !== "object") d.bombResolveByDay = {};
                  const r0 = (d.bombResolveByDay[String(f.day)] && typeof d.bombResolveByDay[String(f.day)] === "object")
                    ? d.bombResolveByDay[String(f.day)]
                    : {};
                  r0.guardSacrifice = !!(document.getElementById("fl_bomb_guard") && document.getElementById("fl_bomb_guard").checked);
                  r0.guardGuess = String(((document.getElementById("fl_bomb_guard_guess") || {}).value) || "").trim();
                  r0.targetGuess = String(((document.getElementById("fl_bomb_target_guess") || {}).value) || "").trim();
                  d.bombResolveByDay[String(f.day)] = r0;
                  f.draft = d;
                  saveState(appState);
                } catch {}
              };
              const els = ["fl_bomb_guard", "fl_bomb_guard_guess", "fl_bomb_target_guess"]
                .map((id) => document.getElementById(id))
                .filter(Boolean);
              els.forEach((el) => el.addEventListener("change", () => {
                saveBombDraft();
                if (applyBombResultFromForm()) bombApplyJustHappened = true;
                try { showFlowTool(); } catch {}
                bombApplyJustHappened = false;
              }));
            } catch {}
          }
          if (cur && cur.id === "day_vote") {
            try {
              const btns = document.querySelectorAll(".fl_vote_btn");
              btns.forEach((btn) => {
                btn.addEventListener("click", (e) => {
                  try {
                    // Challenge badge click — toggle "challenge used" for this player.
                    if (e.target && e.target.hasAttribute && e.target.hasAttribute("data-challenge")) {
                      e.stopPropagation();
                      const cidx = parseInt(e.target.dataset.idx, 10);
                      if (!Number.isFinite(cidx)) return;
                      const d = f.draft || {};
                      if (!d.challengeUsedByDay || typeof d.challengeUsedByDay !== "object") d.challengeUsedByDay = {};
                      if (!Array.isArray(d.challengeUsedByDay[f.day])) d.challengeUsedByDay[f.day] = [];
                      const cp = d.challengeUsedByDay[f.day].map(Number).indexOf(cidx);
                      if (cp >= 0) d.challengeUsedByDay[f.day].splice(cp, 1);
                      else d.challengeUsedByDay[f.day].push(cidx);
                      f.draft = d;
                      saveState(appState);
                      showFlowTool();
                      return;
                    }
                    // Card body click — toggle candidate for defense.
                    const idx = parseInt(btn.dataset.idx, 10);
                    if (!Number.isFinite(idx)) return;
                    const d = f.draft || {};
                    if (!d.voteCandidatesByDay || typeof d.voteCandidatesByDay !== "object") d.voteCandidatesByDay = {};
                    const sel = Array.isArray(d.voteCandidatesByDay[f.day]) ? d.voteCandidatesByDay[f.day].slice() : [];
                    const pos = sel.indexOf(idx);
                    if (pos >= 0) sel.splice(pos, 1);
                    else sel.push(idx);
                    d.voteCandidatesByDay[f.day] = sel;
                    f.draft = d;
                    saveState(appState);
                    showFlowTool();
                  } catch {}
                });
              });
            } catch {}
          }
          if (cur && cur.id === "day_elim") {
            try {
              const els = document.querySelectorAll('select[id^="fl_elim_"]');
              els.forEach((el) => {
                el.addEventListener("change", () => {
                  try { snapshotElimVotesFromUI(); } catch {}
                  // Re-render so the result (and Draw visibility) updates immediately.
                  try { showFlowTool(); } catch {}
                });
              });
            } catch {}
          }
          // Bazras mid-day: card buttons save inspector's continue/cancel decision — no kill applied yet.
          if (cur && cur.id === "bazras_midday") {
            try {
              ["cancel", "continue"].forEach((val) => {
                const btn = document.getElementById("fl_bazras_" + val);
                if (btn) btn.addEventListener("click", () => {
                  try {
                    const d = f.draft || {};
                    const dayKey = String(f.day || 1);
                    if (!d.bazrasInterrogationByDay || typeof d.bazrasInterrogationByDay !== "object") d.bazrasInterrogationByDay = {};
                    const rec = d.bazrasInterrogationByDay[dayKey] || {};
                    rec.decision = val;
                    d.bazrasInterrogationByDay[dayKey] = rec;
                    f.draft = d;
                    saveState(appState);
                    showFlowTool();
                  } catch {}
                });
              });
            } catch {}
          }
          // Bazras forced vote: +/- cards update vote counts and derive winner → apply elimination.
          if (cur && cur.id === "bazras_forced_vote") {
            try {
              const d2 = f.draft || {};
              const dayKey2 = String(f.day || 1);
              const prevNK2 = String(Math.max(0, (f.day || 1) - 1));
              const invT2 = d2.investigatorTargetsByNight && d2.investigatorTargetsByNight[prevNK2];
              const fvT1 = invT2 && invT2.t1 != null ? invT2.t1 : null;
              const fvT2 = invT2 && invT2.t2 != null ? invT2.t2 : null;
              const adjustFVVote = (idx, delta) => {
                try {
                  if (!d2.bazrasInterrogationByDay || typeof d2.bazrasInterrogationByDay !== "object") d2.bazrasInterrogationByDay = {};
                  const rec2 = d2.bazrasInterrogationByDay[dayKey2] || {};
                  if (!rec2.votes || typeof rec2.votes !== "object") rec2.votes = {};
                  rec2.votes[idx] = Math.max(0, parseInt(rec2.votes[idx] || 0, 10) + delta);
                  d2.bazrasInterrogationByDay[dayKey2] = rec2;
                  f.draft = d2;
                  saveState(appState);
                  showFlowTool();
                } catch {}
              };
              document.querySelectorAll(".bazras_fv_plus").forEach((btn) => {
                btn.addEventListener("click", () => adjustFVVote(parseInt(btn.dataset.idx, 10), 1));
              });
              document.querySelectorAll(".bazras_fv_minus").forEach((btn) => {
                btn.addEventListener("click", () => adjustFVVote(parseInt(btn.dataset.idx, 10), -1));
              });
            } catch {}
          }
          // Namayande rep election: save elected representatives on select change.
          if (cur && cur.id === "namayande_rep_election") {
            try {
              const saveReps = () => {
                const v1 = (document.getElementById("fl_rep1") || {}).value || "";
                const v2 = (document.getElementById("fl_rep2") || {}).value || "";
                const d2 = f.draft || {};
                d2.representatives = [];
                if (v1 !== "") d2.representatives.push(parseInt(v1, 10));
                if (v2 !== "") d2.representatives.push(parseInt(v2, 10));
                f.draft = d2;
                saveState(appState);
                // Re-render rep2 options to exclude selected rep1
                try { showFlowTool(); } catch {}
              };
              const r1El = document.getElementById("fl_rep1");
              const r2El = document.getElementById("fl_rep2");
              if (r1El) r1El.addEventListener("change", saveReps);
              if (r2El) r2El.addEventListener("change", () => {
                const v2 = (document.getElementById("fl_rep2") || {}).value || "";
                const d2 = f.draft || {};
                const existing = Array.isArray(d2.representatives) ? d2.representatives : [];
                d2.representatives = [existing[0] != null ? existing[0] : null, v2 !== "" ? parseInt(v2, 10) : null].filter(x => x !== null);
                f.draft = d2;
                saveState(appState);
              });
            } catch {}
          }
          // Namayande rep action: save rep targets on select change.
          if (cur && cur.id === "namayande_rep_action") {
            try {
              const saveTargets = () => {
                const v1 = (document.getElementById("fl_rep1_target") || {}).value || "";
                const v2 = (document.getElementById("fl_rep2_target") || {}).value || "";
                const d2 = f.draft || {};
                if (!d2.repTargetsByDay || typeof d2.repTargetsByDay !== "object") d2.repTargetsByDay = {};
                d2.repTargetsByDay[String(f.day)] = {
                  1: v1 !== "" ? parseInt(v1, 10) : null,
                  2: v2 !== "" ? parseInt(v2, 10) : null,
                };
                f.draft = d2;
                saveState(appState);
              };
              const t1El = document.getElementById("fl_rep1_target");
              const t2El = document.getElementById("fl_rep2_target");
              if (t1El) t1El.addEventListener("change", saveTargets);
              if (t2El) t2El.addEventListener("change", saveTargets);
            } catch {}
          }
          // Namayande vote: apply/revert elimination on select change, re-render for result line.
          if (cur && cur.id === "namayande_vote") {
            try {
              const outEl = document.getElementById("fl_namayande_out");
              if (outEl) {
                outEl.addEventListener("change", () => {
                  const val = outEl.value;
                  const outIdx = val === "" ? null : parseInt(val, 10);
                  const d2 = f.draft || {};
                  if (!d2.namayandePick || typeof d2.namayandePick !== "object") d2.namayandePick = {};
                  d2.namayandePick[String(f.day)] = outIdx;
                  f.draft = d2;
                  try { saveState(appState); } catch {}
                  try { showFlowTool(); } catch {}
                });
              }
            } catch {}
          }
          // Herbalist antidote: card tap selects Give or Withhold.
          if (cur && cur.id === "night_herbalist_antidote") {
            try {
              const prevNightKey = String(Math.max(0, (f.day || 1) - 1));
              const prevNa = (f.draft && f.draft.nightActionsByNight && f.draft.nightActionsByNight[prevNightKey]) || null;
              const poisonIdx = (prevNa && prevNa.herbalistPoison != null && Number.isFinite(parseInt(prevNa.herbalistPoison, 10))) ? parseInt(prevNa.herbalistPoison, 10) : null;
              document.querySelectorAll(".herbalist_antidote_card").forEach((btn) => {
                btn.addEventListener("click", () => {
                  const val = btn.dataset.value || "withhold";
                  const give = val === "give";
                  if (!f.draft) f.draft = {};
                  if (!f.draft.nightActionsByNight) f.draft.nightActionsByNight = {};
                  const nk = String(f.day || 1);
                  if (!f.draft.nightActionsByNight[nk]) f.draft.nightActionsByNight[nk] = {};
                  f.draft.nightActionsByNight[nk].herbalistAntidote = give && poisonIdx != null ? poisonIdx : null;
                  saveState(appState);
                  showFlowTool();
                });
              });
            } catch {}
          }
          // Poison antidote vote: +/- cards update agree/disagree; message updates live.
          if (cur && cur.id === "night_poisoned_player") {
            try {
              const d2 = f.draft || {};
              if (!d2.poisonAntidoteVoteByDay || typeof d2.poisonAntidoteVoteByDay !== "object") d2.poisonAntidoteVoteByDay = {};
              const dayKey = String(f.day || 1);
              if (!d2.poisonAntidoteVoteByDay[dayKey] || typeof d2.poisonAntidoteVoteByDay[dayKey] !== "object") d2.poisonAntidoteVoteByDay[dayKey] = { agree: 0, disagree: 0 };
              const adjust = (vote, delta) => {
                const v = d2.poisonAntidoteVoteByDay[dayKey];
                const curVal = Math.max(0, Number(v[vote]) || 0);
                v[vote] = Math.max(0, curVal + delta);
                f.draft = d2;
                saveState(appState);
                showFlowTool();
              };
              document.querySelectorAll(".poison_antidote_plus").forEach((btn) => {
                btn.addEventListener("click", () => adjust(btn.dataset.vote || "agree", 1));
              });
              document.querySelectorAll(".poison_antidote_minus").forEach((btn) => {
                btn.addEventListener("click", () => adjust(btn.dataset.vote || "agree", -1));
              });
            } catch {}
          }
          // Kabo trust vote: +/- buttons update vote counts, card tap sets trusted manually.
          if (cur && cur.id === "kabo_trust_vote") {
            try {
              const d2 = f.draft || {};
              const dayKey = String(f.day || 1);
              if (!d2.kaboTrustVotesByDay || typeof d2.kaboTrustVotesByDay !== "object") d2.kaboTrustVotesByDay = {};
              if (!d2.kaboTrustedByDay || typeof d2.kaboTrustedByDay !== "object") d2.kaboTrustedByDay = {};
              const adjustVote = (idx, delta) => {
                if (!d2.kaboTrustVotesByDay[dayKey] || typeof d2.kaboTrustVotesByDay[dayKey] !== "object") d2.kaboTrustVotesByDay[dayKey] = {};
                const cur2 = Math.max(0, parseInt(d2.kaboTrustVotesByDay[dayKey][idx] || 0, 10));
                d2.kaboTrustVotesByDay[dayKey][idx] = Math.max(0, cur2 + delta);
                // Auto-update trusted from max votes
                const allVotes = d2.kaboTrustVotesByDay[dayKey];
                let maxV = 0; let best = null; let tc = 0;
                for (const i of aliveIdxs) {
                  const v = Math.max(0, parseInt(allVotes[i] || 0, 10));
                  if (v > maxV) { maxV = v; best = i; tc = 1; }
                  else if (v === maxV && maxV > 0) tc++;
                }
                d2.kaboTrustedByDay[dayKey] = (tc === 1 && best !== null) ? best : null;
                f.draft = d2;
                saveState(appState);
                showFlowTool();
              };
              document.querySelectorAll(".kabo_trust_plus").forEach((btn) => {
                btn.addEventListener("click", () => adjustVote(parseInt(btn.dataset.idx, 10), 1));
              });
              document.querySelectorAll(".kabo_trust_minus").forEach((btn) => {
                btn.addEventListener("click", () => adjustVote(parseInt(btn.dataset.idx, 10), -1));
              });
            } catch {}
          }
          // Kabo suspect select: card tap toggles suspect (max 2).
          if (cur && cur.id === "kabo_suspect_select") {
            try {
              const d2 = f.draft || {};
              const dayKey = String(f.day || 1);
              document.querySelectorAll(".kabo_suspect_btn").forEach((btn) => {
                btn.addEventListener("click", () => {
                  const idx = parseInt(btn.dataset.idx, 10);
                  if (!Number.isFinite(idx)) return;
                  if (!d2.kaboSuspectsByDay || typeof d2.kaboSuspectsByDay !== "object") d2.kaboSuspectsByDay = {};
                  const cur2 = Array.isArray(d2.kaboSuspectsByDay[dayKey]) ? d2.kaboSuspectsByDay[dayKey].map(Number) : [];
                  let arr = [...cur2];
                  const pos = arr.indexOf(idx);
                  if (pos !== -1) { arr.splice(pos, 1); }
                  else { if (arr.length >= 2) arr.shift(); arr.push(idx); }
                  d2.kaboSuspectsByDay[dayKey] = arr;
                  f.draft = d2;
                  saveState(appState);
                  showFlowTool();
                });
              });
            } catch {}
          }
          // Kabo mid-day: gun pick buttons.
          if (cur && cur.id === "kabo_midday") {
            try {
              const d2 = f.draft || {};
              const dayKey = String(f.day || 1);
              ["gun1", "gun2"].forEach((gun) => {
                const btn = document.getElementById("kabo_midday_" + gun);
                if (btn) btn.onclick = () => {
                  if (!d2.kaboGunByDay || typeof d2.kaboGunByDay !== "object") d2.kaboGunByDay = {};
                  d2.kaboGunByDay[dayKey] = gun;
                  f.draft = d2;
                  saveState(appState);
                  showFlowTool();
                };
              });
            } catch {}
          }
          // Kabo shoot: two gun selects — apply kill via real gun's target.
          if (cur && cur.id === "kabo_shoot") {
            try {
              const d2 = f.draft || {};
              const curDK = String(f.day || 1);
              const realGun2 = (d2.kaboGunByDay && d2.kaboGunByDay[curDK]) ? d2.kaboGunByDay[curDK] : null;
              const applyKaboShoot = () => {
                if (!d2.kaboShootByDay || typeof d2.kaboShootByDay !== "object") d2.kaboShootByDay = {};
                const g1v = (document.getElementById("fl_kabo_gun1_target") || {}).value;
                const g2v = (document.getElementById("fl_kabo_gun2_target") || {}).value;
                const g1T = (g1v === undefined || g1v === "") ? null : parseInt(g1v, 10);
                const g2T = (g2v === undefined || g2v === "") ? null : parseInt(g2v, 10);
                d2.kaboShootByDay[String(f.day)] = { gun1: g1T, gun2: g2T };
                f.draft = d2;
                saveState(appState);
                try { showFlowTool(); } catch {}
              };
              const g1El = document.getElementById("fl_kabo_gun1_target");
              const g2El = document.getElementById("fl_kabo_gun2_target");
              if (g1El) g1El.addEventListener("change", () => {
                // If both guns now point at the same player, clear the OTHER gun.
                const v1 = g1El.value, v2 = g2El ? g2El.value : "";
                if (v1 !== "" && v2 !== "" && v1 === v2 && g2El) g2El.value = "";
                applyKaboShoot();
              });
              if (g2El) g2El.addEventListener("change", () => {
                const v1 = g1El ? g1El.value : "", v2 = g2El.value;
                if (v1 !== "" && v2 !== "" && v1 === v2 && g1El) g1El.value = "";
                applyKaboShoot();
              });
            } catch {}
          }
          if (cur && (cur.id === "intro_night_run" || cur.id === "intro_night_nostradamus" || cur.id === "night_run" || (cur.id && (String(cur.id).startsWith("night_step_") || String(cur.id).startsWith("day_end_card_") || (f.phase === "night" && steps.length > 1))))) {
            const mergeOnChange = !!(cur.id && (String(cur.id).startsWith("night_step_") || (f.phase === "night" && steps.length > 1)));
            const ids = [
              "fl_mafia_shot",
              "fl_godfather_action",
              "fl_saul_buy_target",
              "fl_sixth_sense_target",
              "fl_sixth_sense_role",
              "fl_matador_disable",
              "fl_doctor_save",
              "fl_det_query",
              "fl_pro_shot",
              "fl_bomb_target",
              "fl_magician_disable",
              "fl_zodiac_shot",
              "fl_ocean_wake",
              "fl_bomb_code",
              "fl_kane_mark",
              "fl_const_revive",
              "fl_heir_pick",
              "fl_herb_poison",
              "fl_herb_antidote",
              "fl_armor_target",
              "fl_lecter_save",
              "fl_joker_target",
              "fl_swindler_target",
              "fl_researcher_link",
              "fl_natasha_target",
              "fl_sniper_shot",
              "fl_negotiator_target",
              "fl_kadkhoda_target",
              "fl_hacker_block",
              "fl_guide_target",
              "fl_guide_inquiry_target",
              "fl_bodyguard_protect",
              "fl_minemaker_target",
              "fl_lawyer_target",
              "fl_nato_target",
              "fl_nato_role_guess",
              "fl_reporter_target",
              "fl_investigator_t1",
              "fl_investigator_t2",
              "fl_sodagari_sacrifice",
              "fl_sodagari_target",
              "fl_soldier_target",
              "fl_soldier_gun_shot",
              "fl_betrayal_rep",
              "fl_betrayal_dir",
              "fl_capo_bullet_order",
            ];
            // Helper: enforce mafia-shot ↔ NATO-guess mutual exclusion.
            // Neither side is ever hard-disabled — both remain interactive so the user
            // can always switch back by choosing "—". Dimming is visual hint only.
            const enforceNatoMafiaMutex = () => {
              try {
                const shotEl  = document.getElementById("fl_mafia_shot");
                const natoTEl = document.getElementById("fl_nato_target");
                const natoGEl = document.getElementById("fl_nato_role_guess");
                if (!shotEl && !natoTEl) return;
                const shotActive = shotEl && shotEl.value !== "";
                const natoActive = (natoTEl && natoTEl.value !== "") || (natoGEl && natoGEl.value !== "");
                // Dim the inactive side as a hint. For card UI, mafia shot is a hidden input — dim its group.
                if (shotEl) {
                  if (shotEl.type === "hidden" && shotEl.nextElementSibling && shotEl.nextElementSibling.classList && shotEl.nextElementSibling.classList.contains("nightTargetGroup")) {
                    shotEl.nextElementSibling.style.opacity = natoActive ? "0.45" : "";
                  } else {
                    shotEl.style.opacity = natoActive ? "0.45" : "";
                  }
                }
                if (natoTEl) natoTEl.style.opacity = shotActive ? "0.45" : "";
                if (natoGEl) natoGEl.style.opacity = shotActive ? "0.45" : "";
              } catch {}
            };

            for (const id of ids) {
              const el = document.getElementById(id);
              if (!el) continue;
              const evt = "change";
              try {
                el.addEventListener(evt, () => {
                  // Mutual exclusion: when mafia shot is chosen, clear NATO fields (and vice versa).
                  if (id === "fl_mafia_shot") {
                    const shotEl = document.getElementById("fl_mafia_shot");
                    if (shotEl && shotEl.value !== "") {
                      const natoTEl = document.getElementById("fl_nato_target");
                      const natoGEl = document.getElementById("fl_nato_role_guess");
                      if (natoTEl) natoTEl.value = "";
                      if (natoGEl) natoGEl.value = "";
                    }
                  }
                  if (id === "fl_nato_target" || id === "fl_nato_role_guess") {
                    const natoTEl = document.getElementById("fl_nato_target");
                    const natoGEl = document.getElementById("fl_nato_role_guess");
                    const natoActive = (natoTEl && natoTEl.value !== "") || (natoGEl && natoGEl.value !== "");
                    if (natoActive) {
                      const shotEl = document.getElementById("fl_mafia_shot");
                      if (shotEl) shotEl.value = "";
                    }
                  }
                  snapshotNightActionsFromUI(mergeOnChange);
                  enforceNatoMafiaMutex();
                  // Re-render when disable target changes so blocked actions get greyed/disabled correctly.
                  if (id === "fl_magician_disable" || id === "fl_matador_disable") {
                    try { showFlowTool(); } catch {}
                  }
                  // Re-render when guide target changes so the guided player inquiry section appears/updates.
                  if (id === "fl_guide_target") {
                    try { showFlowTool(); } catch {}
                  }
                  // Re-render when Godfather action changes (pedarkhande) so shoot vs Saul buy UI updates.
                  if (id === "fl_godfather_action") {
                    try { showFlowTool(); } catch {}
                  }
                  // Clear bomb code validation feedback when user selects a code/target.
                  if (id === "fl_bomb_code" || id === "fl_bomb_target") {
                    try {
                      const sel = document.getElementById("fl_bomb_code");
                      const note = document.getElementById("fl_bomb_code_note");
                      if (sel) { sel.style.borderColor = ""; sel.style.boxShadow = ""; }
                      if (note) { note.style.display = "none"; note.textContent = ""; }
                    } catch {}
                  }
                });
              } catch {}
            }
            // Apply initial disable state in case saved data has one side already set.
            enforceNatoMafiaMutex();
            // One-time delegated click/pointerdown for night player cards (update hidden input, save, refresh card styles).
            if (!window.__nightCardDelegateBound) {
              window.__nightCardDelegateBound = true;
              const NIGHT_CARD_IDLE_STYLE = "background:rgba(255,255,255,.06);border:2px solid rgba(255,255,255,.12);";
              const NIGHT_CARD_SEL_STYLE = "background:rgba(99,179,237,.25);border:2px solid #63b3ed;";
              let lastNightCardTap = { key: "", t: 0 };
              const handleNightCardTap = (ev) => {
                // ev.target can be a text node when clicking button text; text nodes have no closest()
                let el = ev.target;
                if (el && typeof el.closest !== "function") el = el.parentElement;
                const card = el && el.closest && el.closest(".nightPlayerCard");
                if (!card) return;
                if (card.getAttribute("data-disabled") === "true") return;
                const tapKey = (card.getAttribute("data-field") || "") + ":" + (card.getAttribute("data-idx") ?? "");
                if (tapKey === lastNightCardTap.key && Date.now() - lastNightCardTap.t < 400) return;
                lastNightCardTap = { key: tapKey, t: Date.now() };
                ev.preventDefault();
                const field = card.getAttribute("data-field");
                const idx = (card.getAttribute("data-idx") != null) ? card.getAttribute("data-idx") : "";
                const input = document.getElementById(field);
                if (!input) return;
                const group = card.closest(".nightTargetGroup");
                const isMultiPick = group && group.getAttribute("data-multipick") === "true";
                if (isMultiPick) {
                  const max = Math.max(1, parseInt(group.getAttribute("data-max") || "1", 10));
                  let arr = (input.value || "").split(",").map((x) => parseInt(String(x).trim(), 10)).filter((x) => Number.isFinite(x));
                  const idxNum = idx === "" ? null : parseInt(idx, 10);
                  if (idxNum !== null && Number.isFinite(idxNum)) {
                    const i = arr.indexOf(idxNum);
                    if (i >= 0) arr.splice(i, 1);
                    else if (arr.length < max) arr.push(idxNum);
                  }
                  arr = arr.slice(0, max);
                  input.value = arr.join(",");
                  const isIntro = group.getAttribute("data-intro") === "true";
                  if (isIntro && field === "fl_intro_nost_pick3") {
                    try {
                      const f = ensureFlow();
                      const d = f.draft || {};
                      if (!d.nightActionsByNight) d.nightActionsByNight = {};
                      if (!d.nightActionsByNight["0"]) d.nightActionsByNight["0"] = {};
                      d.nightActionsByNight["0"].nostPick3 = arr.slice(0, 3);
                      if (!d.nostResultByNight || typeof d.nostResultByNight !== "object") d.nostResultByNight = {};
                      if (arr.length > 0) {
                        let mafiaCount = 0;
                        for (const i of arr) {
                          const p = appState.draw && appState.draw.players && appState.draw.players[i];
                          const rid = (p && p.roleId) ? p.roleId : "citizen";
                          if (rid === "godfather" || rid === "mafiaBoss" || rid === "danMafia" || rid === "alcapone") continue;
                          const teamFa = (roles[rid] && roles[rid].teamFa) ? roles[rid].teamFa : "شهر";
                          if (teamFa === "مافیا") mafiaCount++;
                        }
                        d.nostResultByNight["0"] = { picks: arr, mafiaCount, at: Date.now() };
                      } else {
                        d.nostResultByNight["0"] = null;
                      }
                      f.draft = d;
                      saveState(appState);
                      showFlowTool();
                    } catch {}
                  } else if (field === "fl_end_card_silence_targets") {
                    try {
                      const f = ensureFlow();
                      const d = f.draft || {};
                      const dayKey = String(f.day || 1);
                      if (!d.endCardActionByDay || typeof d.endCardActionByDay !== "object") d.endCardActionByDay = {};
                      if (!d.endCardActionByDay[dayKey]) d.endCardActionByDay[dayKey] = {};
                      d.endCardActionByDay[dayKey].targets = arr.slice(0, max);
                      f.draft = d;
                      saveState(appState);
                      showFlowTool();
                    } catch {}
                  } else {
                    try {
                      const f = ensureFlow();
                      const steps = getFlowSteps(f);
                      const cur = steps[Math.min(steps.length - 1, Math.max(0, f.step || 0))];
                      snapshotNightActionsFromUI(!!(cur && cur.id && (String(cur.id).startsWith("night_step_") || (f.phase === "night" && steps.length > 1))));
                    } catch {}
                    try { showFlowTool(); } catch {}
                  }
                  const selSet = new Set(arr);
                  group.querySelectorAll(".nightPlayerCard").forEach((c) => {
                    const v = (c.getAttribute("data-idx") != null) ? c.getAttribute("data-idx") : "";
                    const isSel = v !== "" && selSet.has(parseInt(v, 10));
                    const base = "border-radius:14px;cursor:pointer;display:flex;align-items:center;justify-content:center;text-align:center;padding:10px;font-size:13px;line-height:1.3;transition:background .12s,border-color .12s;box-shadow:0 2px 8px rgba(0,0,0,.2);min-height:48px;touch-action:manipulation;user-select:none;";
                    const colorWeight = isSel ? "color:#fff;font-weight:1100;" : "color:rgba(255,255,255,.85);font-weight:950;";
                    c.style.cssText = base + (isSel ? NIGHT_CARD_SEL_STYLE : NIGHT_CARD_IDLE_STYLE) + colorWeight;
                  });
                  return;
                }
                input.value = idx;
                if (field === "fl_nostradamus_side") {
                  try {
                    const f = ensureFlow();
                    const d = f.draft || {};
                    if (idx === "citizen" || idx === "mafia") {
                      d.nostradamusChosenSide = idx;
                      if (d.nostradamusChooseSideError) delete d.nostradamusChooseSideError;
                      f.draft = d;
                      saveState(appState);
                      showFlowTool();
                    }
                  } catch {}
                  if (group) {
                    group.querySelectorAll(".nightPlayerCard").forEach((c) => {
                      const v = (c.getAttribute("data-idx") != null) ? c.getAttribute("data-idx") : "";
                      const isSel = v === idx;
                      const base = "border-radius:14px;cursor:pointer;display:flex;align-items:center;justify-content:center;text-align:center;padding:10px;font-size:13px;line-height:1.3;transition:background .12s,border-color .12s;box-shadow:0 2px 8px rgba(0,0,0,.2);min-height:48px;touch-action:manipulation;user-select:none;";
                      const colorWeight = isSel ? "color:#fff;font-weight:1100;" : "color:rgba(255,255,255,.85);font-weight:950;";
                      const dis = c.getAttribute("data-disabled") === "true";
                      c.style.cssText = base + (isSel ? NIGHT_CARD_SEL_STYLE : NIGHT_CARD_IDLE_STYLE) + colorWeight + (dis ? "opacity:.55;pointer-events:none;" : "");
                    });
                  }
                  return;
                }
                if (field === "fl_end_card_target") {
                  try {
                    const f = ensureFlow();
                    const d = f.draft || {};
                    const dayKey = String(f.day || 1);
                    if (!d.endCardActionByDay || typeof d.endCardActionByDay !== "object") d.endCardActionByDay = {};
                    if (!d.endCardActionByDay[dayKey]) d.endCardActionByDay[dayKey] = {};
                    d.endCardActionByDay[dayKey].target = idx === "" ? null : parseInt(idx, 10);
                    f.draft = d;
                    saveState(appState);
                    showFlowTool();
                  } catch {}
                  return;
                }
                if (field === "fl_ocean_wake") {
                  try {
                    const f = ensureFlow();
                    const d = f.draft || {};
                    const nightKey = String(f.day || 1);
                    if (!d.oceanTeam || !Array.isArray(d.oceanTeam)) d.oceanTeam = [];
                    if (!d.oceanWakeByNight || typeof d.oceanWakeByNight !== "object") d.oceanWakeByNight = {};
                    const prevAdds = Array.isArray(d.oceanWakeByNight[nightKey]) ? d.oceanWakeByNight[nightKey].slice() : [];
                    if (idx === "") {
                      d.oceanWakeByNight[nightKey] = [];
                      for (const i of prevAdds) d.oceanTeam = d.oceanTeam.filter((x) => parseInt(x, 10) !== i);
                    } else {
                      const num = parseInt(idx, 10);
                      if (Number.isFinite(num)) {
                        d.oceanWakeByNight[nightKey] = [num];
                        if (!d.oceanTeam.includes(num) && d.oceanTeam.length < 2) d.oceanTeam.push(num);
                        for (const i of prevAdds) { if (i !== num) d.oceanTeam = d.oceanTeam.filter((x) => parseInt(x, 10) !== i); }
                      }
                    }
                    f.draft = d;
                    saveState(appState);
                    showFlowTool();
                  } catch {}
                }
                if (field === "fl_intro_heir_pick") {
                  try {
                    const f = ensureFlow();
                    const d = f.draft || {};
                    if (!d.nightActionsByNight) d.nightActionsByNight = {};
                    if (!d.nightActionsByNight["0"]) d.nightActionsByNight["0"] = {};
                    d.nightActionsByNight["0"].heirPick = idx === "" ? null : parseInt(idx, 10);
                    f.draft = d;
                    saveState(appState);
                    showFlowTool();
                  } catch {}
                }
                if (field === "fl_mafia_shot" && idx !== "") {
                  const natoT = document.getElementById("fl_nato_target");
                  const natoG = document.getElementById("fl_nato_role_guess");
                  if (natoT) natoT.value = "";
                  if (natoG) natoG.value = "";
                }
                if (field === "fl_nato_target" || field === "fl_nato_role_guess") {
                  const natoT = document.getElementById("fl_nato_target");
                  const natoG = document.getElementById("fl_nato_role_guess");
                  const natoActive = (natoT && natoT.value !== "") || (natoG && natoG.value !== "");
                  if (natoActive) {
                    const shotEl = document.getElementById("fl_mafia_shot");
                    if (shotEl) shotEl.value = "";
                  }
                }
                try {
                  const f = ensureFlow();
                  const steps = getFlowSteps(f);
                  const cur = steps[Math.min(steps.length - 1, Math.max(0, f.step || 0))];
                  const mergeOnChange = !!(cur && cur.id && (String(cur.id).startsWith("night_step_") || (f.phase === "night" && steps.length > 1)));
                  snapshotNightActionsFromUI(mergeOnChange);
                  if (field === "fl_matador_disable" || field === "fl_magician_disable" || field === "fl_saul_buy_target") {
                    try { showFlowTool(); } catch {}
                  }
                } catch {}
                enforceNatoMafiaMutex();
                if (group) {
                  const val = String(input.value);
                  group.querySelectorAll(".nightPlayerCard").forEach((c) => {
                    const isSel = (c.getAttribute("data-idx") != null ? c.getAttribute("data-idx") : "") === val;
                    const base = "border-radius:14px;cursor:pointer;display:flex;align-items:center;justify-content:center;text-align:center;padding:10px;font-size:13px;line-height:1.3;transition:background .12s,border-color .12s;box-shadow:0 2px 8px rgba(0,0,0,.2);min-height:48px;touch-action:manipulation;user-select:none;";
                    const colorWeight = isSel ? "color:#fff;font-weight:1100;" : "color:rgba(255,255,255,.85);font-weight:950;";
                    c.style.cssText = base + (isSel ? NIGHT_CARD_SEL_STYLE : NIGHT_CARD_IDLE_STYLE) + colorWeight;
                  });
                }
              };
              document.addEventListener("pointerdown", handleNightCardTap, { capture: true });
              document.addEventListener("click", handleNightCardTap, { capture: true });
            }
            // Kabo gun toggle buttons — select which gun has the real bullet.
            try {
              [document.getElementById("kabo_gun1_real_btn"), document.getElementById("kabo_gun2_real_btn")].forEach((btn) => {
                if (!btn) return;
                btn.addEventListener("click", () => {
                  const gun = btn.dataset.gun; // "gun1" | "gun2"
                  const hiddenEl = document.getElementById("fl_capo_bullet_order");
                  if (hiddenEl) hiddenEl.value = gun;
                  snapshotNightActionsFromUI(mergeOnChange);
                  showFlowTool();
                });
              });
            } catch {}
          }
          // Intro night: Nostradamus and Heir picks are handled by card click delegates.
          if (cur && (cur.id === "intro_night_run" || cur.id === "intro_night_nostradamus")) { try { /* card delegates handle fl_intro_nost_pick3, fl_intro_heir_pick */ } catch {} }
          // mid_vote (legacy midday bomb page) removed

          const elimDrawBtn = document.getElementById("fl_elim_draw");
          if (elimDrawBtn) {
            elimDrawBtn.onclick = () => {
              const d = f.draft || {};
              const arr = (d.elimLeadersByDay && d.elimLeadersByDay[f.day]) ? d.elimLeadersByDay[f.day] : [];
              const ties = Array.isArray(arr) ? arr.slice().filter((x) => Number.isFinite(Number(x))) : [];
              if (!ties.length) return;
              const picked = ties[Math.floor(Math.random() * ties.length)];
              d.elimPickedByDay = (d.elimPickedByDay && typeof d.elimPickedByDay === "object") ? d.elimPickedByDay : {};
              d.elimPickedByDay[f.day] = picked;
              f.draft = d;
              addFlowEvent("day_elim_draw", { picked, ties });
              saveState(appState);
              showFlowTool();
              // Flash the result line so the moderator sees feedback even if the same player is re-drawn.
              try {
                const rl = document.getElementById("fl_elim_result_line");
                if (rl) {
                  rl.style.transition = "none";
                  rl.style.background = "rgba(99,179,237,.30)";
                  rl.style.borderRadius = "8px";
                  rl.style.padding = "4px 8px";
                  setTimeout(() => {
                    try {
                      rl.style.transition = "background .6s ease, padding .6s ease";
                      rl.style.background = "";
                      rl.style.padding = "";
                    } catch {}
                  }, 120);
                }
              } catch {}
            };
          }

          // (No separate "Out" button needed: elimination is applied on Save (single winner) or Draw (tie).)

          const giveGunBtn = document.getElementById("fl_gun_give");
          if (giveGunBtn) {
            giveGunBtn.onclick = () => {
              const toVal = (document.getElementById("fl_gun_give_to") || {}).value || "";
              const tp = (document.getElementById("fl_gun_type") || {}).value || "real";
              const note = document.getElementById("fl_gun_give_note");
              if (toVal === "") return;
              const idx = parseInt(toVal, 10);
              if (!Number.isFinite(idx)) return;
              const fromIdx = (() => {
                try {
                  const draw = appState.draw;
                  if (!draw || !draw.players) return null;
                  for (let i = 0; i < draw.players.length; i++) {
                    const p = draw.players[i];
                    if (p && p.roleId === "gunslinger" && p.alive !== false) return i;
                  }
                } catch {}
                return null;
              })();

              // If the gunner is disabled this night (Magician or Matador), block the give action.
              const currentDisabledIdx = (() => {
                try {
                  let p3 = null;
                  const ev3 = (f.events || []).slice().reverse().find((e) => e && e.kind === "night_actions" && e.phase === "night" && e.day === f.day && e.data);
                  if (ev3 && ev3.data) p3 = ev3.data;
                  if (!p3 && f.draft && f.draft.nightActionsByNight) {
                    const nk = String(f.day || 1);
                    p3 = f.draft.nightActionsByNight[nk] || null;
                  }
                  if (!p3) {
                    const magEl = document.getElementById("fl_magician_disable");
                    const matEl = document.getElementById("fl_matador_disable");
                    if (magEl && magEl.value !== "" && magEl.value !== null) {
                      const n = parseInt(magEl.value, 10);
                      if (Number.isFinite(n)) return n;
                    }
                    if (matEl && matEl.value !== "" && matEl.value !== null) {
                      const n = parseInt(matEl.value, 10);
                      if (Number.isFinite(n)) return n;
                    }
                    return null;
                  }
                  const scenarioGun = typeof getDrawScenarioForFlow === "function" ? getDrawScenarioForFlow() : "";
                  if (scenarioGun === "pedarkhande" && p3.matadorDisable != null && p3.matadorDisable !== undefined && Number.isFinite(Number(p3.matadorDisable))) {
                    return parseInt(p3.matadorDisable, 10);
                  }
                  if (p3.magicianDisable === null || p3.magicianDisable === undefined) return null;
                  const n3 = parseInt(p3.magicianDisable, 10);
                  return Number.isFinite(n3) ? n3 : null;
                } catch { return null; }
              })();
              if (fromIdx !== null && currentDisabledIdx !== null && currentDisabledIdx === fromIdx) {
                const note2 = document.getElementById("fl_gun_give_note");
                if (note2) { note2.style.display = "block"; note2.textContent = appLang === "fa" ? "تفنگدار در این شب غیرفعال است." : "Gunner is disabled this night."; }
                return;
              }

              // Night limits: (user request) no max total; keep max 1 real per night.
              const d = f.draft || {};
              const nightKey = String(f.day || 1);
              if (!d.nightGunGivesByNight || typeof d.nightGunGivesByNight !== "object") d.nightGunGivesByNight = {};
              let nightGives = Array.isArray(d.nightGunGivesByNight[nightKey]) ? d.nightGunGivesByNight[nightKey] : [];

              // Determine desired type (with self->fake rule and disabled-recipient rule).
              let type = (tp === "fake") ? "fake" : "real";
              if (fromIdx !== null && Number.isFinite(fromIdx) && fromIdx === idx) type = "fake";
              // If the recipient is disabled by Magician this night, downgrade real gun to fake.
              const disabledRecipient = (() => {
                try {
                  const ev2 = (f.events || []).slice().reverse().find((e) => e && e.kind === "night_actions" && e.phase === "night" && e.day === f.day && e.data);
                  const p2 = ev2 && ev2.data ? ev2.data : null;
                  if (!p2 || p2.magicianDisable === null || p2.magicianDisable === undefined) return null;
                  const n2 = parseInt(p2.magicianDisable, 10);
                  return Number.isFinite(n2) ? n2 : null;
                } catch { return null; }
              })();
              if (disabledRecipient !== null && disabledRecipient === idx) type = "fake";

              // Replace/update existing give to same recipient (doesn't consume extra quota).
              const exAt = nightGives.findIndex((x) => x && Number.isFinite(Number(x.to)) && parseInt(x.to, 10) === idx);
              const realUsed = nightGives.filter((x, i) => x && x.type === "real" && i !== exAt).length;

              if (type === "real" && realUsed >= 1) {
                if (note) { note.style.display = "block"; note.textContent = t("tool.flow.guns.limit1Real"); }
                return;
              }

              const entry = { from: fromIdx, to: idx, type, at: Date.now() };
              if (exAt >= 0) nightGives[exAt] = entry;
              else nightGives = nightGives.concat([entry]);
              d.nightGunGivesByNight[nightKey] = nightGives;
              f.draft = d;

              // Gunslinger can give anyone a gun, but can only give themselves a fake gun.
              if (!f.guns || typeof f.guns !== "object") f.guns = {};
              f.guns[idx] = { type, used: false, givenAt: Date.now() };
              addFlowEvent("gun_give", { from: fromIdx, to: idx, type: f.guns[idx].type });
              saveState(appState);
              showFlowTool();
            };
          }

          // Remove a gun (undo mistakes)
          try {
            const rmBtns = document.querySelectorAll("[data-gun-rm]");
            rmBtns.forEach((btn) => {
              btn.addEventListener("click", () => {
                try {
                  const raw = btn.getAttribute("data-gun-rm");
                  const idx = parseInt(String(raw || ""), 10);
                  if (!Number.isFinite(idx)) return;
                  // Remove gun from holder
                  if (f.guns && typeof f.guns === "object") {
                    try { delete f.guns[idx]; } catch { f.guns[idx] = undefined; }
                  }
                  // Remove from per-night give tracking (all nights, to be safe)
                  const d = f.draft || {};
                  if (d.nightGunGivesByNight && typeof d.nightGunGivesByNight === "object") {
                    for (const nk of Object.keys(d.nightGunGivesByNight)) {
                      const arr = Array.isArray(d.nightGunGivesByNight[nk]) ? d.nightGunGivesByNight[nk] : [];
                      d.nightGunGivesByNight[nk] = arr.filter((x) => !(x && Number.isFinite(Number(x.to)) && parseInt(x.to, 10) === idx));
                    }
                  }
                  f.draft = d;
                  // Cancel the matching gun_give event instead of logging a remove
                  try {
                    if (Array.isArray(f.events)) {
                      const gi = f.events.findIndex((e) =>
                        e && e.kind === "gun_give" &&
                        e.phase === f.phase && e.day === f.day &&
                        e.data && Number.isFinite(Number(e.data.to)) &&
                        parseInt(e.data.to, 10) === idx
                      );
                      if (gi !== -1) {
                        f.events.splice(gi, 1);
                      } else {
                        addFlowEvent("gun_remove", { to: idx });
                      }
                    }
                  } catch { addFlowEvent("gun_remove", { to: idx }); }
                  saveState(appState);
                  showFlowTool();
                } catch {}
              });
            });
          } catch {}

          // Ocean and Nostradamus night picks are handled by card delegates (single-select and multi-pick).

          // Inline Last Move draw (only present in day_elim when a player is picked)
          const lmElimBtn = document.getElementById("lm_draw_elim");
          if (lmElimBtn) {
            lmElimBtn.onclick = () => {
              try {
                const _lmBtnCfg = getScenarioConfig(getScenario());
                const supports = !!_lmBtnCfg.features?.lastMove;
                if (!supports) return;
                const lastMoveCards = _lmBtnCfg.eliminationCards || [];
                const used = new Set((appState.god && appState.god.lastMove && Array.isArray(appState.god.lastMove.used)) ? appState.god.lastMove.used : []);
                const remaining = lastMoveCards.filter((c) => !used.has(c.id));
                const note = document.getElementById("lm_note_elim");
                if (!remaining.length) {
                  if (note) {
                    note.style.display = "block";
                    note.textContent = t("tool.lastMove.allUsed");
                  }
                  return;
                }
                const picked = remaining[Math.floor(Math.random() * remaining.length)];
                if (!appState.god.lastMove || typeof appState.god.lastMove !== "object") appState.god.lastMove = { last: null, at: null, used: [] };
                if (!Array.isArray(appState.god.lastMove.used)) appState.god.lastMove.used = [];
                appState.god.lastMove.last = picked.id;
                appState.god.lastMove.at = Date.now();
                appState.god.lastMove.used.push(picked.id);
                saveState(appState);
                showFlowTool();
              } catch {}
            };
          }

          // UX: if gunslinger gives to self, force fake-only in dropdown.
          (function () {
            const toSel = document.getElementById("fl_gun_give_to");
            const typeSel = document.getElementById("fl_gun_type");
            if (!toSel || !typeSel) return;
            const realOpt = typeSel.querySelector('option[value="real"]');
            const giveBtn = document.getElementById("fl_gun_give");
            const adjust = () => {
              const tv = (toSel.value || "");
              const fidx = (() => {
                try {
                  const draw = appState.draw;
                  if (!draw || !draw.players) return null;
                  for (let i = 0; i < draw.players.length; i++) {
                    const p = draw.players[i];
                    if (p && p.roleId === "gunslinger" && p.alive !== false) return i;
                  }
                } catch {}
                return null;
              })();
              const tidx = tv === "" ? null : parseInt(tv, 10);
              const self = (fidx !== null && tidx !== null && Number.isFinite(fidx) && Number.isFinite(tidx) && fidx === tidx);
              const d = f.draft || {};
              const nightKey = String(f.day || 1);
              const nightGives = (d.nightGunGivesByNight && Array.isArray(d.nightGunGivesByNight[nightKey])) ? d.nightGunGivesByNight[nightKey] : [];
              const exAt = nightGives.findIndex((x) => x && Number.isFinite(Number(x.to)) && parseInt(x.to, 10) === tidx);
              const realUsed = nightGives.filter((x, i) => x && x.type === "real" && i !== exAt).length;
              // Disable real when self OR already used real quota (except editing existing real entry).
              if (realOpt) realOpt.disabled = !!self || (realUsed >= 1);
              if (self && typeSel.value === "real") typeSel.value = "fake";
              if (realUsed >= 1 && typeSel.value === "real") typeSel.value = "fake";

              // Give button is always enabled (no per-night max total).
              if (giveBtn) giveBtn.disabled = false;
            };
            try { toSel.addEventListener("change", adjust); } catch {}
            adjust();
          })();

          const fireGunBtn = document.getElementById("fl_gun_fire");
          if (fireGunBtn) {
            fireGunBtn.onclick = () => {
              const shVal = (document.getElementById("fl_gun_shooter") || {}).value || "";
              const tgVal = (document.getElementById("fl_gun_target") || {}).value || "";
              const note = document.getElementById("fl_gun_note");
              if (shVal === "" || tgVal === "") return;
              const shooter = parseInt(shVal, 10);
              const target = parseInt(tgVal, 10);
              if (!Number.isFinite(shooter) || !Number.isFinite(target)) return;
              const g = (f.guns && f.guns[shooter]) ? f.guns[shooter] : null;
              if (!g || g.used) return;

              // Capture alive state BEFORE marking dead so we can revert later.
              const targetPrevAlive = !!(draw.players[target] && draw.players[target].alive !== false);

              g.used = true;
              addFlowEvent("gun_shot", { shooter, target, type: g.type });

              // Track this shot for back-navigation revert.
              try {
                const dayKey = String(f.day || 1);
                if (!f.draft) f.draft = {};
                if (!f.draft.gunShotAppliedByDay || typeof f.draft.gunShotAppliedByDay !== "object") f.draft.gunShotAppliedByDay = {};
                if (!f.draft.gunShotAppliedByDay[dayKey] || typeof f.draft.gunShotAppliedByDay[dayKey] !== "object") f.draft.gunShotAppliedByDay[dayKey] = { shots: [] };
                if (!Array.isArray(f.draft.gunShotAppliedByDay[dayKey].shots)) f.draft.gunShotAppliedByDay[dayKey].shots = [];
                f.draft.gunShotAppliedByDay[dayKey].shots.push({ shooter, target, type: g.type, targetPrevAlive });
              } catch {}

              // Deaths are NOT applied immediately — they resolve when leaving this step (Next).
              // The pending shots list in the UI shows what has been recorded.
              saveState(appState);
              showFlowTool();
            };
          }

          // Undo an individual pending gun shot
          try {
            document.querySelectorAll("[data-gun-shot-rm]").forEach((btn) => {
              btn.addEventListener("click", () => {
                try {
                  const shooter = parseInt(btn.getAttribute("data-gun-shot-rm"), 10);
                  if (!Number.isFinite(shooter)) return;
                  const dayKey = String(f.day || 1);
                  const d = f.draft || {};
                  if (!d.gunShotAppliedByDay || !d.gunShotAppliedByDay[dayKey]) return;
                  const rec = d.gunShotAppliedByDay[dayKey];
                  if (Array.isArray(rec.shots)) {
                    rec.shots = rec.shots.filter((s) => parseInt(s.shooter, 10) !== shooter);
                  }
                  // Reset the gun's used flag so it can be re-fired
                  if (f.guns && f.guns[shooter]) f.guns[shooter].used = false;
                  // Remove the corresponding gun_shot event
                  if (Array.isArray(f.events)) {
                    f.events = f.events.filter((e) =>
                      !(e && e.kind === "gun_shot" &&
                        e.phase === f.phase && Number(e.day) === Number(f.day) &&
                        e.data && parseInt(e.data.shooter, 10) === shooter)
                    );
                  }
                  f.draft = d;
                  saveState(appState);
                  showFlowTool();
                } catch {}
              });
            });
          } catch {}

          // (No manual "Record actions" / bomb toggle buttons; changes auto-save.)
        }
